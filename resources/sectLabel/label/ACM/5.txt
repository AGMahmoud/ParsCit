title ||| A Dependability Perspective on Emerging Technologies
author ||| Lucian Prodan	Mihai Udrescu	Mircea Vladutiu
affiliation ||| Advanced Computing Systems and Architectures (ACSA) Laboratory,
affiliation ||| Computer Science and Engineering Department, “Politehnica” University of Timisoara,
address ||| 2 V.Parvan Blvd, 300223 Timisoara, Romania
note ||| www.acsa.upt.ro
address ||| +40-722-664779	+40-723-154989	+40-256-403258
email ||| lprodan@cs.upt.ro	mudrescu@cs.upt.ro	mvlad@cs.upt.ro
sectionHeader ||| ABSTRACT
bodyText ||| Emerging technologies are set to provide further provisions for
bodyText ||| computing in times when the limits of current technology of
bodyText ||| microelectronics become an ever closer presence. A technology
bodyText ||| roadmap document lists biologically-inspired computing and
bodyText ||| quantum computing as two emerging technology vectors for novel
bodyText ||| computing architectures [43]. But the potential benefits that will
bodyText ||| come from entering the nanoelectronics era and from exploring
bodyText ||| novel nanotechnologies are foreseen to come at the cost of
bodyText ||| increased sensitivity to influences from the surrounding
bodyText ||| environment. This paper elaborates on a dependability perspective
bodyText ||| over these two emerging technology vectors from a designer’s
bodyText ||| standpoint. Maintaining or increasing the dependability of
bodyText ||| unconventional computational processes is discussed in two
bodyText ||| different contexts: one of a bio-inspired computing architecture
bodyText ||| (the Embryonics project) and another of a quantum computational
bodyText ||| architecture (the QUERIST project).
sectionHeader ||| Categories and Subject Descriptors
category ||| B.8.1 [Performance and Reliability]: Reliability, Testing, and
category ||| Fault-Tolerance.
category ||| C.4 [Performance of Systems]: Fault-Tolerance, Reliability,
category ||| Availability, and Serviceability.
sectionHeader ||| General Terms
keyword ||| Design, Reliability, Theory.
sectionHeader ||| Keywords
keyword ||| Dependability, emerging technologies, evolvable hardware, bio-
keyword ||| inspired computing, bio-inspired digital design, Embryonics,
keyword ||| reliability, quantum computing, fault-tolerance assessment.
sectionHeader ||| 1. INTRODUCTION
bodyText ||| High-end computing has reached nearly every corner of our
bodyText ||| present day life, in a variety of forms taylored to accommodate
bodyText ||| either general purpose or specialized applications. Computers
copyright ||| Permission to make digital or hard copies of all or part of this work for
copyright ||| personal or classroom use is granted without fee provided that copies are
copyright ||| not made or distributed for profit or commercial advantage and that
copyright ||| copies bear this notice and the full citation on the first page. To copy
copyright ||| otherwise, or republish, to post on servers or to redistribute to lists,
copyright ||| requires prior specific permission and/or a fee.
note ||| CF’06, May 3–5, 2006, Ischia, Italy.
copyright ||| Copyright 2006 ACM 1-59593-302-6/06/0005...$5.00.
copyright ||| may be considerred as fine exponents of the present days’
copyright ||| technological wave – if not their finest, they certainly do count as
copyright ||| solid, indispensable support for the finest.
bodyText ||| From the very beginning of the computing advent, the main target
bodyText ||| was squeezing out any additional performance. The inception
bodyText ||| period was not always trouble-free, accurate computation results
bodyText ||| being required at an ever faster pace on a road that has become
bodyText ||| manifold: some applications do require computational speed as a
bodyText ||| top priority; others are set for the highest possible dependability,
bodyText ||| while still delivering sufficient performance levels.
bodyText ||| Several definitions for dependability have been proposed: “the
bodyText ||| ability of a system to avoid service failures that are more frequent
bodyText ||| or more severe than is acceptable” [2], or “the property of a
bodyText ||| computer system such that reliance can justifiably be placed on
bodyText ||| the service it delivers” [9][45]. Dependability is therefore a
bodyText ||| synthetic term specifying a qualitative system descriptor that can
bodyText ||| generally be quantified through a list of attributes including
bodyText ||| reliability, fault tolerance, availability, and others.
bodyText ||| In real world, a dependable system would have to operate
bodyText ||| normally over extended periods of time before experiencing any
bodyText ||| fail (reliability, availability) and to recover quickly from errors
bodyText ||| (fault tolerance, self-test and self-repair). The term “acceptable”
bodyText ||| has an essential meaning within the dependability’s definition,
bodyText ||| setting the upper limits of the damages that can be supported by
bodyText ||| the system while still remaining functional or computationally
bodyText ||| accurate. A dependability analysis should take into consideration
bodyText ||| if not quantitative figures for the acceptable damage limit, at least
bodyText ||| a qualitative parameter representation for its attributes.
bodyText ||| Dependable systems are therefore crucial for applications that
bodyText ||| prohibit or limit human interventions, such as long-term exposure
bodyText ||| to aggressive (or even hostile) environments. The best examples
bodyText ||| are long term operating machines as required by managing deep-
bodyText ||| underwater/nuclear activities and outer space exploration.
bodyText ||| There are three main concerns that should be posed through a
bodyText ||| system’s design in order to achieve high dependability [42]:
listItem ||| 1. Specifying the dependability requirements: selecting the
listItem ||| dependability requirements that have to be pursued in
listItem ||| building the computing system, based on known or assumed
listItem ||| goals for the part of the world that is directly affected by the
listItem ||| computing system;
listItem ||| 2. Designing and implementing the computing system so as to
listItem ||| achieve the dependability required. However, this step is hard
listItem ||| to implement since the system reliability cannot be satisfied
page ||| 187
bodyText ||| simply from careful design. Some techniques can be used to
bodyText ||| help to achieve this goal, such as using fault injection to
bodyText ||| evaluate the design process.
listItem ||| 3. Validating a system: gaining confidence that a certain
listItem ||| dependability requirement/goal has been attained.
bodyText ||| This paper will address these main concerns through an attempt to
bodyText ||| provide an in-depth view over modern computing directions and
bodyText ||| paradigms, which we consider to be representative for the efforts
bodyText ||| involved in improving overall dependability.
subsectionHeader ||| 1.1 Motivations
bodyText ||| We have listed some of the applications of dependable computing
bodyText ||| systems as linked to activities that take place in special
bodyText ||| environments, such as deep underwater or outer space. At a very
bodyText ||| first sight, these applications would appear specific enough to not
bodyText ||| encourage a specific design for dependability approach in
bodyText ||| computing. However, evidence suggest this is hardly the case; on
bodyText ||| the contrary, it is difficult to imagine a domain left unconquered
bodyText ||| by computer systems during times when industrial, transport,
bodyText ||| financial services and others do rely heavily on accurate computer
bodyText ||| operation at any given moment. If computer innacuracies could be
bodyText ||| more easily overlooked at home, professional environments
bodyText ||| cannot accept such missbehaviors.
bodyText ||| Yet the recent history of computing provides evidence that
bodyText ||| dependability is not a sine qua non feature. During their life
bodyText ||| cycle, electronic devices constantly suffer a number of influences
bodyText ||| that manifest predominantly over transient regimes, which in turn
bodyText ||| introduce a variety of errors unified in the literature under the
bodyText ||| name of transient faults, soft errors or single event upsets (SEUs).
bodyText ||| The rate electronic devices are affected with is known under the
bodyText ||| term of soft error rate or simply SER and is measured in fails per
bodyText ||| unit time. Because it relies on transient phenomena due to
bodyText ||| changing states and logical values, digital electronics makes up
bodyText ||| for a special category that is also affected by soft errors. No
bodyText ||| matter the name they are referred under, these errors affect the
bodyText ||| computing processes and are due to electromagnetic noise and/or
bodyText ||| external radiations rather than design or manufacturing flaws [28].
bodyText ||| One cause at the origin of soft fails affecting digital devices is
bodyText ||| known to be due to radioactive decay processes. Radioactive
bodyText ||| isotopes, widely used for a range of purposes, might contaminate
bodyText ||| semiconductor materials leading to soft errors; evidence is
bodyText ||| available throughout the literature, both by empirical observations
bodyText ||| and experimental results [20]. Consequently, cosmic rays,
bodyText ||| containing a broad range of energized atomic/subatomic particles
bodyText ||| may lead to the appearance of soft fails.
bodyText ||| Computers therefore are susceptive to soft errors, an issue that
bodyText ||| will potentially become essential with the advent of emerging
bodyText ||| technologies. As acknowledged by the International Technology
bodyText ||| Roadmap for Semiconductors (ITRS), issued at the end of 2004
bodyText ||| [43], the microelectronics industry faces a challenging task in
bodyText ||| going to and beyond 45nm scale in order to address “beyond
bodyText ||| CMOS” applications. Scaling down the technology will enable an
bodyText ||| extremely large number of devices to be integrated onto the same
bodyText ||| chip. However, the great challenge will be to ensure the new
bodyText ||| devices will be operational at this scale [6], since they will exhibit
bodyText ||| a sensitive behavior to soft fails. In order to address the negative
bodyText ||| effects brought by technology scaling, it is to be expected that
bodyText ||| significant control resources will need to be implemented [3].
bodyText ||| Another challenging aspect concerning emerging technologies is
bodyText ||| to match the newly developed device technologies with new
bodyText ||| system architectures, a synergistic/collaborative development of
bodyText ||| the two being seen as likely to be very rewarding. The potential of
bodyText ||| biologically-inspired and quantum computing architectures is
bodyText ||| acknowledged by the ITRS report on emerging technologies [43]
bodyText ||| (see Figure 1). This paper will investigate the relevance of soft
bodyText ||| fails and attempt to provide means of harnessing their negative
bodyText ||| effects on modern computing in the context of biologically-
bodyText ||| inspired and quantum computing architectures.
figureCaption ||| Figure 1: Bio-inspired and quantum computing are
bodyText ||| acknowledged as architectural technology vectors in emerging
bodyText ||| technologies [43]
subsectionHeader ||| 1.2 Paper Outline
bodyText ||| This paper is structured as follows. Section 2 will address the first
bodyText ||| main concern, that is, specifying and selecting dependability
bodyText ||| requirements that will have to be pursued when building a
bodyText ||| computational platform. Parameters that describe and quantify
bodyText ||| dependability attributes, such as reliability, will be introduced,
bodyText ||| with a highlight on their accepted models and their issues. A
bodyText ||| particular consideration will be given to the failure rate parameter,
bodyText ||| which is the basis of all reliability analyses.
bodyText ||| Section 3 will approach some of the means for design for
bodyText ||| dependability; it will therefore elaborate upon two emerging
bodyText ||| technology vectors, as seen by the ITRS report [43], which define
bodyText ||| two novel architectures, namely biologically-inspired (or bio-
bodyText ||| inspired) and quantum computing. We will introduce two projects
bodyText ||| and their corresponding architectures, called Embryonics (as a
bodyText ||| biologically-inspired computing platform) and QUERIST (as a
bodyText ||| quantum computing platform designed to allow and study error
bodyText ||| injection). These two architectures are representative for the
bodyText ||| coming age of nano-computing, where computational processes
bodyText ||| take place as encoded at the very inner core level of matter, be it
bodyText ||| semiconductor material (for nanoelectronics, targetted here by the
bodyText ||| Embryonics project) or atomic scale dynamics (for quantum
bodyText ||| computing, targetted here by the QUERIST project). This section
bodyText ||| will then introduce dependability aspects within bio-inspired
bodyText ||| computing (the Embryonics project being investigated in
bodyText ||| SubSection 3.1) and within quantum computing (the QUERIST
bodyText ||| project being investigated in SubSection 3.2).
bodyText ||| Finally, Section 4 will present the conclusions and prospects for
bodyText ||| designing emerging technology dependable computing systems,
bodyText ||| as we see them.
page ||| 188
sectionHeader ||| 2. DEPENDABILITY ATTRIBUTES
bodyText ||| An important dependability attribute for any given system lies in
bodyText ||| its capacity to operate reliably for a given time interval, knowing
bodyText ||| that normal operation was delivered at initial time [8]. Reliability
bodyText ||| functions are modelled as exponential functions of parameter A,
bodyText ||| which is the failure rate. The reliability of a system is the
bodyText ||| consequence of the reliability of all of its subsystems. The
bodyText ||| heterogeneity of the system leads to a difficult quantitative
bodyText ||| assessment of its overall reliability; moreover, estimating the
bodyText ||| reliability functions is further made difficult because formal
bodyText ||| rigour is not commercially available, this being kept under
bodyText ||| military mandate [44].
bodyText ||| The failure rate for a given system can be modelled as a function
bodyText ||| of the failure rates of its individual subsystems, suggestions being
bodyText ||| present in the MIL-HDBC-217 document, which is publicly
bodyText ||| available [44]. However, this document has been strongly
bodyText ||| criticized for its failure rate estimations based on the Arrhenius
bodyText ||| model, which relates the failure rate to the operating temperature:
bodyText ||| where K is a constant, KB is Boltzmann’s constant, T is the
bodyText ||| absolute temperature and E is the “activation energy” for the
bodyText ||| process [18]. Quantitative values for failure rates show significant
bodyText ||| differences between those predicted using MIL-HDBC-217 and
bodyText ||| those from testing real devices (see Figure 2). There are two
bodyText ||| conclusions that can be drawn from this:
listItem ||| 1. quantitative estimations for failure rate values are strongly
listItem ||| dependant on the quality of information used; unfortunately,
listItem ||| current reliable information about electronic devices is known
listItem ||| to be lacking [44];
listItem ||| 2. despite differences between predicted and real values, the
listItem ||| MIL-HDBC-217 methodology can be useful for qualitative
listItem ||| analyses in order to take decisions regarding sub-system parts
listItem ||| that should benefit from improved designs.
figureCaption ||| Figure 2. Predicted vs real failure rates plotted against
bodyText ||| temperature [18]
bodyText ||| So far the failure rate of digital devices has been considerred as
bodyText ||| due to internal causes. However, this is not always the case, soft
bodyText ||| fails being equally present due to the aggressive influences of the
bodyText ||| external environment, which also have to be modelled [22]. The
bodyText ||| external envirnment features highly dynamic changes in its
bodyText ||| parameters, which will eventually affect the normal operation of
bodyText ||| digital devices that lack sufficient protection or ability to adapt.
bodyText ||| Ideally, computing devices would behave in a consistent and
bodyText ||| accurate manner regardless of fluctuations in environmental
bodyText ||| parameters. This is either a consequence of soft error mitigation
bodyText ||| techniques or due to flexible hardware/software functionality that
bodyText ||| allow the system as a whole to adapt to environamental changes
bodyText ||| and tolerate induced faults.
bodyText ||| While certain soft error mitigation techniques are available, the
bodyText ||| technology scaling towards nanoelectronics affects their
bodyText ||| efficiency by integrating a larger number of devices per chip
bodyText ||| (which requires a larger amount of redundant/control logic or
bodyText ||| other measures), which feature, at the same time, smaller
bodyText ||| dimensions (which renders an electronic device much more
bodyText ||| senzitive to the influence of stray energetic particles that reach it
bodyText ||| as part of cosmic rays). Both aspects are involved in the
bodyText ||| development of the two emerging technology vectors mentioned
bodyText ||| in SubSection 1.1, although having slightly different motivations:
bodyText ||| while the nature of the quantum environment prohibits precise
bodyText ||| computation in the absence of fault tolerance techniques, such
bodyText ||| techniques are targetted by bio-inspired computing as means of
bodyText ||| improving the dependability of a computing platform.
subsectionHeader ||| 2.1 Bio-Inspired Computing
bodyText ||| If living beings may be considered to fulfill computational tasks,
bodyText ||| then Nature is the ultimate engineer: each of the living beings
bodyText ||| exhibit solutions that were successfully tested and refined in such
bodyText ||| ways human engineers will never afford. One reason is time: the
bodyText ||| testing period coinciding with the very existence of life itself.
bodyText ||| Another reason is variety and complexity: Nature has found and
bodyText ||| adapted a variety of solutions to address complex survivability
bodyText ||| issues in a dynamically changing environment. No matter how
bodyText ||| Nature approached the process of evolution, engineering could
bodyText ||| perhaps benefit most from drawing inspiration from its
bodyText ||| mechanisms rather from trying to develop particular techniques.
bodyText ||| Bio-inspired computing is not a new idea. John von Neumann was
bodyText ||| preoccupied to design a machine that could replicate itself and
bodyText ||| was quite interested in the study of how the behavior of the
bodyText ||| human brain could be implemented by a computer [13][14]. He
bodyText ||| also pioneered the field of dependable computing by studying the
bodyText ||| possibility of building reliable machines out of unreliable
bodyText ||| components [15]. Unfortunately, the dream of implementing his
bodyText ||| self-reproducing automata could not become true until the 1990s,
bodyText ||| when massively programmable logic opened the new era of
bodyText ||| reconfigurable computing.
bodyText ||| But when trying to adapt nature’s mechanisms in digital devices,
bodyText ||| it becomes most evident that biological organisms are rightfully
bodyText ||| the most intricate structures known to man. They continuously
bodyText ||| demonstrate a highly complex behavior due to massive, parallel
bodyText ||| cooperation between huge numbers of relatively simple elements,
bodyText ||| the cells. And considering uncountable variety of living beings,
bodyText ||| with a life span up to several hundreds (for the animal regnum) or
bodyText ||| even thousands (for the vegetal regnum) of years, it seems nature
bodyText ||| is the closest spring of inspiration for designing dependable, fault
bodyText ||| tolerant systems.
bodyText ||| Investigating the particularities of natural systems, a taxonomy of
bodyText ||| three categories of processes can be identified [32]:
listItem ||| 1. Phylogenetic processes constitute the first level of
listItem ||| organization of the living matter. They are concerned with the
listItem ||| temporal evolution of the genetic heritage of all individuals,
none ||| E
equation ||| λ= Ke KBT	(1)
equation ||| −
page ||| 189
bodyText ||| therefore mastering the evolution of all species. The
bodyText ||| phylogenetic processes rely on mechanisms such as
bodyText ||| recombination and mutation, which are essentially
bodyText ||| nondeterministic; the error rate ensures here nature’s
bodyText ||| diversity.
listItem ||| 2. Ontogenetic processes represent the second level of
listItem ||| organization of the living matter. They are also concerned
listItem ||| with the temporal evolution of the genetic heritage of, in this
listItem ||| case, a single, multicellular individual, therefore mastering an
listItem ||| individual’s development from the stage of a single cell, the
listItem ||| zygote, through succesive cellular division and specialization,
listItem ||| to the adult stage. These processes rely on deterministic
listItem ||| mechanisms; any error at this level results in malformations.
listItem ||| 3. Epigenetic processes represent the third level of organization
listItem ||| of the living matter. They are concerned with the integration
listItem ||| of interactions with the surrounding environment therefore
listItem ||| resulting in what we call learning systems.
bodyText ||| This taxonomy is important in that it provides a model called POE
bodyText ||| (from Phylogeny, Ontogeny and Epigenesis) that inspires the
bodyText ||| combination of processes in order to create novel bio-inspired
bodyText ||| hardware (see Figure 3). We believe this is also important from a
bodyText ||| dependability engineering perspective, for the following reasons:
listItem ||| 1. Phylogenetic processes were assimilated by modern
listItem ||| computing as evolutionary computation, including genetic
listItem ||| algorithms and genetic programming. The essence of any
listItem ||| genetic algorithm is the derivation of a solution space based
listItem ||| on recombination, crossover and mutation processes that
listItem ||| spawn a population of individuals, each encoding a possible
listItem ||| solution. One may consider that each such step, with the
listItem ||| exception of discovering the solution, is equivalent to a
listItem ||| process of error injection, which in turn leads to wandering
listItem ||| from the optimal solution (or class of solutions). However,
listItem ||| genetic algorithms prove to be successful despite this error
listItem ||| injection, the fitness function being responsible for the
listItem ||| successful quantification of the significance of the “error”.
listItem ||| Therefore genetic computation is intrinsicaly resilient to
listItem ||| faults and errors, largely due to the fact that they are part of
listItem ||| the very process that generates the solutions.
listItem ||| 2. Ontogenetic processes have been implemented in digital
listItem ||| hardware with modular and uniform architectures. Such an
listItem ||| architecture enables the implementation of mechanisms
listItem ||| similar to the cellular division and cellular differentiation that
listItem ||| take place in living beings [31]. These mechanisms bring the
listItem ||| advantage of distributed and hierarchical fault tolerance
listItem ||| strategies: the uniformity of the architecture also makes any
listItem ||| module to be universal, that is, to be able to take over the role
listItem ||| of any other damaged module.
listItem ||| 3. Epigenetic processes were assimilated by modern computing
listItem ||| mainly as artificial neural networks (or ANNs) as inspired by
listItem ||| the nervous system, and much less as inspired by the immune
listItem ||| or endocrine systems from superior multicellular living
listItem ||| beings. ANNs are known to have a generalization capacity,
listItem ||| that is, to respond well even if the input patterns are not part
listItem ||| of the patterns used during the learning phase. This means that
listItem ||| ANNs possess a certain ability to tolerante faults, whether
listItem ||| they manifest at the inputs or inside their intenal architecture.
bodyText ||| With the advent of field programmable logic (of which the most
bodyText ||| salient representative are the FPGAs) it is now possible to change
bodyText ||| hardware functionality through software, thus allowing
bodyText ||| information to govern matter in digital electronics. This is not
bodyText ||| dissimilar to what happens in nature: information coded in DNA
bodyText ||| affects the development of an organism. A special kind of such
bodyText ||| digital devices that change dynamically their behavior are known
bodyText ||| as evolvable or adaptive hardware; they are bio-inspired
bodyText ||| computing systems whose behaviors may change according to
bodyText ||| computational targets, or, if harsh or unknown environments are
bodyText ||| to be explored, for the purpose of maximizing dependability.
figureCaption ||| Figure 3. The POE model of bio-inspired systems [32]
subsectionHeader ||| 2.2 Quantum Computing
bodyText ||| Error detection and correction techniques are vital in quantum
bodyText ||| computing due to the destructive effect of the environment, which
bodyText ||| therefore acts as an omnipresent error generator. Error detection
bodyText ||| and correction must provide a safe recovery process within
bodyText ||| quantum computing processes through keeping error propagation
bodyText ||| under control. Without such dependability techniques there could
bodyText ||| be no realistic prospect of an operational quantum computational
bodyText ||| device [19].
bodyText ||| There are two main sources of errors: the first is due to the
bodyText ||| erroneous behavior of the quantum gate, producing the so-called
bodyText ||| processing errors; the second is due to the macroscopic
bodyText ||| environment that interacts with the quantum state, producing the
bodyText ||| storing and transmitting errors.
bodyText ||| The consistency of any quantum computation process can be
bodyText ||| destroyed by innacuracies and errors if the error probability in the
bodyText ||| basic components (qubits, quantum gates) excedes an accuracy
bodyText ||| threshold. This is a critical aspect since the microscopic quantum
bodyText ||| states are prone to frequent errors.
bodyText ||| The main error source is the decoherence effect [16]. The
bodyText ||| environment is constantly attempting to measure the sensitive
bodyText ||| quantum superposition state, a phenomenon that cannot be
bodyText ||| avoided technologically since it is not (yet) possible to isolate
bodyText ||| them perfectly. The superposition state will decay through
bodyText ||| measuring and will therefore become a projection of the state
bodyText ||| vector onto a basis vector (or eigenstate). The most insidious
bodyText ||| error, however, appears when decoherence affects the quantum
bodyText ||| amplitudes without destroying them; this is similar to small
bodyText ||| analog errors. Issues stated above are solved, on one hand,
bodyText ||| through intrinsic fault tolerance by technological implementation
bodyText ||| (topological interactions [1]) and, on the other hand, by error
bodyText ||| correcting techniques at the unitary (gate network) level. We will
bodyText ||| focus on the error detecting and correcting techniques, which are
bodyText ||| difficult to approach due to quantum constraints: the useful state
page ||| 190
bodyText ||| can neither be observed (otherwise it will decohere), nor can it be
bodyText ||| cloned.
subsubsectionHeader ||| 2.2.1 Background
bodyText ||| As expressed in bra-ket notation [16], the qubit is a normalized
bodyText ||| vector in some Hilbert space H2 , { 0 , 1 } being the orthonormal
bodyText ||| basis: ψ = a0 0 + a1 1 ( a0, a1 ∈ C are the so-called quantum
bodyText ||| amplitudes, representing the square root of the associated
bodyText ||| measurement probabilities for the eigenstates
bodyText ||| respectively, with a0 2 + a1 2 =1). Therefore, the qubit can be
bodyText ||| affected by 3 types of errors:
bodyText ||| Bit flip errors are somewhat similar to classical bit flip errors. For
bodyText ||| a single qubit things are exactly the same as in classical
bodyText ||| computation: 0 H 1 , 1 H 0 . For 2 or more qubits, flip errors
bodyText ||| affecting the state may modify it or leave it unchanged. For
bodyText ||| instance,	if we consider the so-called cat state
bodyText ||| ψ Cat = 2 ( 00 + 11 ) [19], and the first qubit is affected by a
bodyText ||| bit flip error, the resulting state will be yr Cat H 2 ( 10 + 01) .
bodyText ||| But, if both qubits are affected by bit flips, there will be no
bodyText ||| change in the state: V Cat H 2 ( 11 + 00 ) = ψ Cat
bodyText ||| Phase errors affect the phase of one of the qubit&apos;s amplitudes and
bodyText ||| is expressed as 0 H 0 , 1 H − 1 . This type of error is very
bodyText ||| dangerous, due to its propagation behavior but it only makes
bodyText ||| sense when dealing with superposition states. If we consider an
bodyText ||| equally weighted qubit superposition state and inject a phase
bodyText ||| error, this results in 2 ( 0 + 1 )H 2 ( 0 − 1 ) .
bodyText ||| There is a strict correspondence between bit flip and phase error
bodyText ||| types due to the way they map onto Hilbert spaces with the same
bodyText ||| dimension but different basis. The bit flip is an error from the
bodyText ||| { 0 , 1 } , whereas the phase error appears in the
bodyText ||| same space with basis r	0 + 1, �(0 − 1 )⎫⎬⎭ or{ +
bodyText ||| The space basis conversion, in this case, is made by applying the
bodyText ||| Hadamard transform; Figure 4 shows an example of transforming
bodyText ||| a bit flip error into a phase error (A, and vice versa (B.
bodyText ||| Small amplitude errors: amplitudes a0 and a1 of the quantum bit
bodyText ||| can be affected by small errors, similar to analog errors. Even if
bodyText ||| such an error does not destroy the superposition and conserves the
bodyText ||| value of the superposed states, small amplitude errors could
bodyText ||| accumulate over time, eventually ruining the computation. In
bodyText ||| order to avoid this situation, specific methodologies for digitizing
bodyText ||| small errors are used to reduce them to a non-fault or a bit-flip
bodyText ||| [19].
bodyText ||| Due to the quantum physics laws, fault tolerance techniques have
bodyText ||| to comply with the following computational constraints:
listItem ||| – The observation destroys the state. Since observation is
listItem ||| equivalent to measurement, this leads to destroying the
listItem ||| useful state superposition.
listItem ||| – Information copying is impossible. Quantum physics renders
listItem ||| the cloning of a quantum state impossible, meaning that a
listItem ||| quantum state cannot be copied correctly. Therefore
listItem ||| quantum error correction must address the following
listItem ||| problems:
bodyText ||| Non-destructive measurement. Despite the first constraint it is
bodyText ||| necessary to find a way to measure the encoded information
bodyText ||| without destroying it. Because the encoded state cannot be
bodyText ||| measured directly, one needs to properly prepare some scratch
bodyText ||| (ancilla) qubits, which can then be measured.
bodyText ||| Fault-tolerant recovery. Due to the high error rate in quantum
bodyText ||| computational devices, it is likely that the error recovery itself
bodyText ||| will be affected by errors. If the recovery process is not fault-
bodyText ||| tolerant, then any error coding becomes useless.
bodyText ||| Phase error backward propagation. If we consider the XOR gate
bodyText ||| from Figure 5(A, a flip error affecting the target qubit (b) will
bodyText ||| propagate backwards and also affect the source qubit. This is due
bodyText ||| to the gate network equivalence from Figure 5(B and the basis
bodyText ||| transformation described by Figure 4.
figureCaption ||| Figure 4. Correspondence between bit flip and phase errors
figureCaption ||| Figure 5. (A The backward propagation of a phase error for
bodyText ||| the XOR gate; (B Gate network equivalence
bodyText ||| In order to deal with the problems described the next strategies
bodyText ||| have to be followed:
bodyText ||| Digitizing small errors. The presence of small errors is not a
bodyText ||| major concern, as they can be digitized using a special technique
bodyText ||| based on measuring auxiliary (ancilla) qubits [19].
bodyText ||| Ancilla usage. Since qubit cloning is impossible, a majority
bodyText ||| voting strategy is difficult to implement. However, by using
bodyText ||| ancilla qubits, the eigenstate information can be duplicated inside
bodyText ||| the existing superposition, resulting in the entanglement of the
bodyText ||| ancilla with the useful data. Because any measurement performed
bodyText ||| on the ancilla could have repercussions on the useful qubits, the
bodyText ||| appropriate strategy will employ special coding for both data
bodyText ||| qubits and ancilla (data errors only will be copied onto the
bodyText ||| ancilla), followed by the computation of an error syndrome,
bodyText ||| which has to be obtained through measuring the ancilla (see
bodyText ||| Figure 6).
bodyText ||| Avoiding massive spreading of phase errors. As shown
bodyText ||| previously, a phase error on the target qubit will propagate on all
bodyText ||| source qubits. The solution is to use more ancilla qubits as targets,
bodyText ||| so that no ancilla qubit is used more than once.
none ||| 0 and 1
none ||| 	2
none ||| space with basis
page ||| 191
none ||| 1
figureCaption ||| Figure 6. Fault-tolerant procedure with ancilla qubits
bodyText ||| Ancilla and syndrome accuracy. Setting the ancilla code to some
bodyText ||| known quantum state could be an erroneous process. Computing
bodyText ||| the syndrome is also prone to errors. Hence, on one hand, one has
bodyText ||| to make sure that the ancilla qubits are in the right state by
bodyText ||| verifying and recovering them if needed; on the other hand, in
bodyText ||| order to have a reliable syndrome, it must be computed
bodyText ||| repeatedly.
bodyText ||| Error recovery. As the small errors can be digitized (therefore,
bodyText ||| they are either corrected or transformed into bit flip errors), the
bodyText ||| recovery must deal only with bit flip and phase errors. A state that
bodyText ||| needs to be recovered is described by:
bodyText ||| Correcting a bit flip error 1means applying the negation unitarytransformation UN = ux = ° Oj to the affected qubit. To
bodyText ||| correct phase and combined errors, the following unitary
bodyText ||| operators	will	have	to	be	applied	respectively:
equation ||| ⎡1	0 ⎤	⎡0	−i ⎤
equation ||| UZ=⎢0	−1], UY = UN⋅UZ	⎣i	.
equation ||| 			0 ⎥⎦
subsubsectionHeader ||| 2.2.2 Quantum Error Correcting Codes
bodyText ||| Quantum error coding and correcting (QECC) is performed with
bodyText ||| special coding techniques inspired from the classic Hamming
bodyText ||| codes. The classical error coding is adapted so that it becomes
bodyText ||| suitable for the quantum strategy, allowing only the ancilla qubits
bodyText ||| to be measured.
bodyText ||| The state-of-the-art in QECC is represented by the stabilizer
bodyText ||| encoding, a particular case being the Steane codes (the Shor codes
bodyText ||| may also be used [29]). Steane&apos;s 7-qubit code is a single error
bodyText ||| correcting code inspired from classical Hamming coding and can
bodyText ||| be adapted for ancilla coding as well. Therefore it cannot recover
bodyText ||| from two identical qubit faults, but it can recover from a bit flip a
bodyText ||| phase flip. The Steane 7-qubit coding of 0 and 1 consists of
bodyText ||| an equally weighted superposition of all the valid Hamming 7-bit
bodyText ||| words with an even and odd number of 1s, respectively:
equation ||| = 1
equation ||| S	3	odd⎞u0u1u2u3c0c1c2
equation ||| ⎜	⎟
equation ||| ⎝	⎠
equation ||| =1 1111111 + 1101000 + 1010001 + 1000110
equation ||| 232
equation ||| + 0110100 + 0100011 + 0011010 + 0001101
bodyText ||| Applying the Steane coding on an arbitrary given quantum state
equation ||| ψ = a0 0 +a1 1 transforms it into V S = a0 0 S + a1 1 S. This
bodyText ||| code was designed to correct bit-flip errors, but by changing the
bodyText ||| basis (through a Hadamard transform) the phase error transforms
bodyText ||| into a bit flip error, which can then be corrected:
subsubsectionHeader ||| 2.2.3 Fault Tolerance Methodologies
bodyText ||| Quantum error-correcting codes exist for r errors, r ∈ ICY, r ≥ 1.
bodyText ||| Therefore a non-correctable error occurs if a number of r +1
bodyText ||| errors occur simultaneously before the recovery process.
bodyText ||| If the probability of a quantum gate error or storage error in the
bodyText ||| time unit is of orderξ , then the probability of an error affecting
bodyText ||| the processed data block becomes of order �r+1 , which is
bodyText ||| negligible if r is sufficiently large. However, by increasing r the
bodyText ||| safe recovery also becomes more complex and hence prone to
bodyText ||| errors: it is possible that r +1 errors accumulate in the block
bodyText ||| before the recovery is performed.
bodyText ||| Considering the relationship between r and the number of
bodyText ||| computational steps required for computing the syndrome is
bodyText ||| polynomial of the order rp . It was proven that in order to reduce
bodyText ||| as much as possible the error probability r must be chosen so that
none ||| 1
none ||| −
bodyText ||| r — e 1K p [7][19]. By consequence, if attempting to execute N
bodyText ||| cycles Sof error correction without any r+1 errors accumulating
bodyText ||| before the recovery ends, then N — exp⎜ξp
none ||| ⎛ − 1
bodyText ||| . Therefore the
bodyText ||| accuracy degree will be of the form � —(logN)−p , which is
bodyText ||| better than the accuracy degree corresponding to the no-coding
bodyText ||| case, � — N-1. However, there exists a Nmax so that if N &gt; Nmax
bodyText ||| then non-correctable error becomes likely, which limits the length
bodyText ||| of the recovery process. Given the extremely large number of
bodyText ||| gates employed by a quantum algorithm implementation, Nmax
bodyText ||| also has to be very large; for Shor&apos;s algorithm Nmax must be
bodyText ||| higher than 3⋅109 [30].
bodyText ||| As shown in Figure 7, the required accuracy degree approaches
bodyText ||| today&apos;s technological limits (tipically 10-3 for p=4) after N=105.
bodyText ||| For a fault tolerant encoding solution for Shor algorithm
bodyText ||| implementation this should have happened after N=109 [19][34].
bodyText ||| +	(2)	Additional fault tolerance must be employed in order to preserve
figure ||| ⎯⎯⎯→⎨error ⎧ ⎪ ⎪ ⎪ ⎪ ⎩
figure ||| a
figure ||| a1 0 + a0 1 for a flip error
figure ||| .
figure ||| a0 0 −a1 1 for a phase error
figure ||| a1 0 − a0 1 for both flip and phase errors
figure ||| 0 0 +a1 1 if no error occurs
figure ||| a00+a11
figure ||| = 1 0000000 + 0010111 + 0101110 + 0111001
figure ||| + 1001011 + 1011100 + 1100101 + 1110010
figure ||| 232
figure ||| (
figure ||| )
figure ||| 1
figure ||| =
figure ||| S	232	evelu0`2u3c01c2)
figure ||| 0
figure ||| u0u1u2u3c0c1c2
figure ||| +	(3)
figure ||| )
figure ||| 0 S =H⋅ 0S= 1
figure ||| 1 S =H⋅ 1 S = 1
figure ||| 2
figure ||| 2
figure ||| (0S+1S)
figure ||| (0S−1S)
none ||| (4)
bodyText ||| reliable quantum computation over an arbitrary number of
bodyText ||| computational steps. Concatenated coding represents one such
bodyText ||| technique, which improves the reliability by shaping the size of
page ||| 192
bodyText ||| the code blocks and the number of code levels. It is also resource
bodyText ||| demanding and vulnerable to correlated errors [19][37].
bodyText ||| Another approach, replacing the concatenated codes, is based on
bodyText ||| Reconfigurable Quantum Gate Arrays (RQGAs) [34][37], which
bodyText ||| are used for configuring ECC circuits based on stabilizer codes
bodyText ||| [7][33]. By using a quantum configuration register for the RQGA
bodyText ||| (i.e. a superposition of classical configurations), the
bodyText ||| reconfigurable circuit is brought to a state where it represents a
bodyText ||| simultaneous superposition of distinct ECC circuits. After
bodyText ||| measuring the configuration register, only one ECC circuit is
bodyText ||| selected and used; if k distinct ECC circuits were superposed and
bodyText ||| the gate error rate is � , then the overall gate error probability
bodyText ||| becomes �k (see Figure 8). As a result, the accuracy threshold
bodyText ||| value for the RQGA solution clearly dominates the technological
bodyText ||| accuracy limit, as shown in Figure 9 [37].
figureCaption ||| Figure 7. Accuracy plots: p=3 for xi1, p=4 for xi2, p=5 for xi3;
bodyText ||| xi4 for no-coding, ref is the reference accuracy (i.e. the
bodyText ||| accuracy allowed by today&apos;s state of the art technology)
figureCaption ||| Figure 8. A quantum configuration register acts as a
bodyText ||| superposition of k distinct circuits sharing the same input
bodyText ||| state and the same output qubits
sectionHeader ||| 3. DEPENDABLE SYSTEM DESIGN
bodyText ||| In order to model the erroneous behavior of a device of system it
bodyText ||| is necessary to understand the causality of phenomena concerned.
bodyText ||| A defect affecting a device from a physical point of view is called
bodyText ||| a fault, or a fail. Faults may be put in evidence through logical
bodyText ||| misbehavior, in which case they transform into errors. Finally,
bodyText ||| errors accumulating can lead to system failure [8]. The fault-
bodyText ||| error-failure causal chain is essential to developping techniques
bodyText ||| that reduce the risk of error occurrence, even in the presence of
bodyText ||| faults, in order to minimize the probability of a system failure,
bodyText ||| and can be architecture specific. We will elaborate next on
bodyText ||| techniques used by a bio-inspired and by a quantum computing
bodyText ||| platform.
figureCaption ||| Figure 9. Evolution of accuracy threshold value for RQHW
bodyText ||| stabilizer codes (xir); the technological accuracy limit (dim) is
bodyText ||| also provided for a relevant comparison
subsectionHeader ||| 3.1 The Embryonics Approach
bodyText ||| Several years before his untimely death John von Neumann began
bodyText ||| developping a theory of automata, which was to contain a
bodyText ||| systematic theory of mixed mathematical and logical forms,
bodyText ||| aimed to a better understanding of both natural systems and
bodyText ||| computers [14]. The essence of von Neumann’s message appears
bodyText ||| to entail the formula “genotype + ribotype = phenotype”. He
bodyText ||| provided the foundations of a self-replicating machine (the
bodyText ||| phenotype), consisting of its complete description (the genotype),
bodyText ||| which is interpreted by a ribosome (the ribotype).
bodyText ||| Embryonics (a contraction for embryonic electronics) is a long
bodyText ||| term research project launched by the Logic Systems Laboratory
bodyText ||| at the Swiss Federal Institute of Technology, Lausanne,
bodyText ||| Switzerland. Its aim is to explore the potential of biologically-
bodyText ||| inspired mechanisms by borrowing and adapting them from
bodyText ||| nature into digital devices for the purpose of endowing them with
bodyText ||| the remarkable robustness present in biological entities [39].
bodyText ||| Though perhaps fuzzy at a first glance, analogies between biology
bodyText ||| and electronics are presented in Table 1 [12][31].
bodyText ||| But if we consider that the function of a living cell is determined
bodyText ||| by the genome, and that a computer’s functionality is determined
bodyText ||| by the operating program, then the two worlds may be regarded as
bodyText ||| sharing a certain degree of similarity. Three fundamental features
bodyText ||| shared by living entities are required to be targetted by
bodyText ||| Embryonics in order to embody the formula “genotype + ribotype
bodyText ||| = phenotype” into digital hardware:
listItem ||| –multicellular organisms are made of a finite number of cells,
listItem ||| which in turn are made of a finite number of chemically
listItem ||| bonded molecules;
listItem ||| –each cell (beginning with the original cell, the zygote) may
listItem ||| generate one or several daughter cell(s) through a process
listItem ||| called cellular division; both the parent and the daughter
listItem ||| cell(s) share the same genetic information, called the genome;
listItem ||| –different types of cells may exist due to cellular
listItem ||| differentiation, a process through which only a part of the
listItem ||| genome is executed.
bodyText ||| These fundamental features led the Embryonics project to settle
bodyText ||| for an architectural hierarchy of four levels (see Figure 10). We
bodyText ||| will not delve very deep inside the Embryonics’phylosophy, as
bodyText ||| such details were broadly covered by literature [12][20][23][24]
bodyText ||| [25][40]; we will, however, introduce each of the four levels in
page ||| 193
bodyText ||| order to be able to see how this bio-inspired platform fits modern
bodyText ||| design for dependability efforts.
tableCaption ||| Table 1. Analogies present in Embryonics [12]
table ||| Biology	Electronics
table ||| Multicellular organism	Parallel computer systems
table ||| Cell	Processor
table ||| Molecule	FPGA Element
figureCaption ||| Figure 10. Structural hierarchy in Embryonics [12]
bodyText ||| The upmost level in Embryonics, bearing a certain similarity to
bodyText ||| what is found in nature, is the population level, composed of a
bodyText ||| number of organisms. One level down the hierarchy constitutes
bodyText ||| the organismic level, and corresponds to individual entities in a
bodyText ||| variety of functionalities and sizes. Each of the organisms may be
bodyText ||| further decomposed into smaller, simpler parts, called cells, which
bodyText ||| in turn may be decomposed in molecules. According to
bodyText ||| Embryonics, a biological organism corresponds in the world of
bodyText ||| digital systems to a complete computer, a biological cell is
bodyText ||| equivalent to a processor, and the smallest part in biology, the
bodyText ||| molecule, may be seen as the smallest, programmable element in
bodyText ||| digital electronics (see Table 1).
bodyText ||| An extremely valuable consequence of the Embryonics
bodyText ||| architecture is that each cell is &quot;universal&quot;, containing a copy of
bodyText ||| the whole of the organism’s genetic material, the genome. This
bodyText ||| enables very flexible redundancy strategies, the living organisms
bodyText ||| being capable of self-repair (healing) or self-replication (cloning)
bodyText ||| [12]. Self-replication may be of great interest in the
bodyText ||| nanoelectronics era, where extremely large areas of
bodyText ||| programmable logic will probably render any centralized control
bodyText ||| very inefficient. Instead, the self-replication mechanism
bodyText ||| implemented in Embryonics will allow the initial colonization of
bodyText ||| the entire programmable array in a decentralized and distributed
bodyText ||| manner. Figure 11 presents an example of such colonization. At
bodyText ||| initial time the configuration bitstream (containing the genome)
bodyText ||| enters the bottom left corner of a programmable array and, at each
bodyText ||| clock cycle, the genome is pushed through and partitions the
bodyText ||| programmable space accordingly.
bodyText ||| From a dependability standpoint, the Embryonics hierarchical
bodyText ||| architecture offers incentives for an also hierarchical self-repair
bodyText ||| strategy. Because the target applications are those in which the
bodyText ||| failure frequency must be very low to be “acceptable”, two levels
bodyText ||| of self-repair are offered: at the molecular level (programmable
bodyText ||| logic is susceptible to soft fail occurrences) and at the cellular
bodyText ||| level (soft fails manifest at this level as soft errors).
bodyText ||| Let us consider an example of a simple cell made of 3 lines and 3
bodyText ||| columns of molecules, of which one column contains spare
bodyText ||| molecules. If a fault occurs inside an active cell, it can be repaired
bodyText ||| through transferring its functionality toward the appropriate spare
bodyText ||| molecule, which will become active (see Figure 12).
figureCaption ||| Figure 11. Space colonization in Embryonics [11]
figureCaption ||| Figure 12. Self-repair at the molecular level: faulty molecule
figureCaption ||| E is replaced by spare molecule H, which becomes active [39]
bodyText ||| The self-repair process at molecular level ensures the fault
bodyText ||| recovery as long as there are spare molecules left for repair.
bodyText ||| However, it is possible for a cell to experience a multiple error, in
bodyText ||| which case the self-repair mechanism at the molecular level can
bodyText ||| no longer reconfigure the inside of the cell successfully. If such a
bodyText ||| situation arises, then a second self-repair strategy is trigerred at a
bodyText ||| higher level. The cell will “die”, therefore trigerring the self-
bodyText ||| repair at the cellular level, the entire column containing the faulty
bodyText ||| cell (cell C in this example) being deactivated, its role being taken
bodyText ||| by the nearest spare column to the right (see Figure 13).
bodyText ||| A critique that could be addressed to the current Embryonics
bodyText ||| design would be its strategy of self-repair at the higher, cellular
bodyText ||| level: in case of a faulty cell, an entire column containing that cell
bodyText ||| will be deactivated, its role being transferred to the first available
bodyText ||| column of spares to the right (see Figure 13). There are two points
bodyText ||| in which this strategy could benefit:
page ||| 194
listItem ||| 1. Instead of deactivating a whole column of cells, it would be
listItem ||| more efficient to only deactivate the faulty cell only (see
listItem ||| Figure 14). The resources affected by the role transfer would
listItem ||| be greatly reduced (one cell versus an entire column),
listItem ||| coupled with the fact that particle flux generating soft fails is
listItem ||| unlikely to be homogeneous and isotrope. This means
listItem ||| regions assimilable more likely to cells rather than entire
listItem ||| column of cells would be more affected by soft fails, not to
listItem ||| mention that during genetic data transfer (required by taking
listItem ||| over the role of the faulty cell) there is a greater risk of
listItem ||| enduring a new soft fail (moving data is much more sensitive
listItem ||| to soft fails than static data) [5][10].
listItem ||| 2. Such a strategy would be consistent with that used for the
listItem ||| self-repair at the molecular level, which would simplify a
listItem ||| thorough reliability analysis. Concatenated coding would
listItem ||| also seem easier to be implemented and the strategy
listItem ||| consistency would mean that concatenated coding would not
listItem ||| be limited to a two-level hierarchy [20][21].
figureCaption ||| Figure 13. Molecular self-repair failure: the cell “dies”
figureCaption ||| (bottom), triggering the cellular self-repair (top) [39]
bodyText ||| We consider a cell of M lines and N columns, being composed of
bodyText ||| modules of M lines and n+s columns (for instance, the cell
bodyText ||| presented in Figure 12 consists of a single such module of two
bodyText ||| active columns and one spare column), of which s are spares. In
bodyText ||| order to meet certain reliability criteria, it is necessary to know
bodyText ||| what is the number s of spare columns of molecules that
bodyText ||| correspond to n columns of active molecules, that is, the
bodyText ||| horizontal dimensions for such a module. We will not provide a
bodyText ||| thorough reliability analysis, as this has been done previously
bodyText ||| [4][17][20][21]; instead, we will analyze the influences of the
bodyText ||| proposed consistent self-repair strategy at both molecular and
bodyText ||| cellular levels through the use of logic molecules. Therefore
bodyText ||| Equation (5) holds:
equation ||| k
equation ||| RModRow (t)=Prob{ no fails} (t) + ∑ Prob{ i fails} (t)
equation ||| i=1	(5)
equation ||| N=k(n+s)
bodyText ||| where RModRow(t) represents the reliability function for a row
bodyText ||| within a module. Then, considering the failure rate for one
bodyText ||| molecule λ, the probability of all molecules (both active and
bodyText ||| spare) to operate normally in a module’s row becomes:
equation ||| Prob{ no fails} (t) = e−&quot;n+s)t	(6)
bodyText ||| The probability of a row enduring i fails in the active molecules
bodyText ||| part is the conditional probability of having n-i active molecules
bodyText ||| operating normally, while a number of s-i spare molecules are
bodyText ||| ready to activate (that is, they are not affected by errors
bodyText ||| themselves):
equation ||| Prob{ i fails} (t) = Prob{ i fails active} (t)
equation ||| ⋅Prob{i spares ok}(t)
equation ||| Prob{ i fails active} (t) = (n Je λ(n-i)t (1 − eλ(n-i)t)	(8)
equation ||| i	l
equation ||| Prob{ i spares ok} (t) = (k )e−λit (1 − a λ(k−i)t
equation ||| i
bodyText ||| Then the reliability function for an entire cell is the cummulated
bodyText ||| reliability functions for the total number of modules:
equation ||| RCell(t) = [RModRow(t)]MN`	(10)
figureCaption ||| Figure 14. Proposed reconfiguration strategy at the cellular
bodyText ||| level
bodyText ||| A self-repair strategy that conserves the consistency between the
bodyText ||| molecular and the cellular level would allow for a more
bodyText ||| straightforward reliability analysis. Basically, it would be
bodyText ||| sufficient to substitute dimension parameters in Equations (5)-
bodyText ||| (10) with those approapriate to the analysis of an organism
bodyText ||| instead of a cell. To illustrate this, we will consider an organism
bodyText ||| of M* lines and N* columns, being composed of modules of M*
bodyText ||| lines and n*+s* columns, of which s* are spares; we will also use
bodyText ||| the organism partitioning into modules, similar to the partitioning
bodyText ||| of cells used before. Therefore Equation (5) transforms into
bodyText ||| Equation (11):
equation ||| k
equation ||| RCellMR (t)=Prob*{nofails}(t)+∑Prob* { ifails} (t) i = 1	(11)
equation ||| N*=k*(n +s )
bodyText ||| where RCellMR (t) represents the reliability function for a row of
bodyText ||| cells within an organism module. In this case, the significance of
bodyText ||| the terms will be as follows:
equation ||| Prob {no fails} (t) = [RCell ( tj +s	(12)
equation ||| ⋅
equation ||| (7)
equation ||| (9)
page ||| 195
bodyText ||| While Equation (7) continues to hold under the form of Equation
bodyText ||| (13), the significance of its terms will change according to the
bodyText ||| dimensions at the cellular level:
equation ||| ⎛ ⎞ −
equation ||| Prob*{ifailsactive}(t)=⎜
equation |||  i
equation ||| (t)(1−R
equation ||| L
equation ||| ll(t
equation ||| ⎛ ⎞	−
equation ||| Prob*{isparesok}(t)=⎜k*
equation ||| J
equation ||| RCiell(t)(1−RCkelli(t))	(15) i
equation ||| t0, t1,..., tm−1 will be given by
equation ||| The outputs ofthe firstcycle, whichare also inputs forthe
equation ||| The used FTAMs are only valid if the relationship between the
bodyText ||| experimental ξsim and the assumed singular error rateξ is of the
equation ||| order gsim _ � 2 [19].
equation ||| ) )(14)
bodyText ||| Finally, similar to Equation(10), the reliabilityfunctionforan
bodyText ||| entire organism is the cummulated re
bodyText ||| liability functions for the
bodyText ||| total number of its modules:
equation ||| ROrg(t)=
equation |||  [
equation ||| RCellMR(t)
equation ||| ]
equation ||| MN
equation |||  �
equation ||| +
equation ||| s	(16)
bodyText ||| Equations (5) to (16) provide the basics forathorough reliability
bodyText ||| analysis for the proposed, uniformstrategy ofhierarchical
bodyText ||| reconfiguration, as opposedto the analysis providedby [21],
bodyText ||| whichspecifically targetted the currentEmbryonics architecture.
bodyText ||| Despite having settled the reliabilitymodel, bothanalyses are
bodyText ||| incomplete, inthatthe failure rate parameteris missing, which
bodyText ||| makes aprecise, quantitative dependability targetdifficultto
bodyText ||| meet. However, areliability analysis is still valuable from a
bodyText ||| qualitative pointofview, allowingadirectcomparison of
bodyText ||| differentsystems.
subsectionHeader ||| 3.2 The QUERISTApproach
bodyText ||| Inorderto deal with errors inducedby the constantinfluence of
bodyText ||| the external environmentuponcomputational processes, the
bodyText ||| following assumptions were made: errors appear randomly, are
bodyText ||| uncorrelated (neitherinspace, norintime), there are no storage
bodyText ||| errors, andthere are no leakage phenomenainvolved[19].
bodyText ||| Classical HDL-based faultinjectionmethodologies can be
bodyText ||| mappedto simulatingquantumcircuits withoutintervention
bodyText ||| providedthatthe new errorand faultmodels are takeninto
bodyText ||| account[35]. Ofcourse, efficiencycriteriarequire thatthey be
bodyText ||| adaptedto one ofthe available efficientsimulationframeworks
bodyText ||| [36][38][41]. QUERIST(from QUantum ERrorInjection
bodyText ||| Simulation Tool) is the name ofsucha project, fostering
bodyText ||| simulated faultinjectiontechniques inquantum circuits [34].
bodyText ||| Similarto classical computation, simulatedfaultinjection is used
bodyText ||| in orderto evaluate the employed FTAMS (FaultTolerance
bodyText ||| Algorithms andMethodologies) [26][27].
bodyText ||| Anoverview ofthe QUERISTprojectis presented in Figure 15.
bodyText ||| The three cycles ofinitialization, simulation, anddata
bodyText ||| computationare commonto bothclassical andquantum
bodyText ||| approaches. The firstcycle takes the quantumcircuitHDL
bodyText ||| description as aninput. Two abstractinputs are considered, the
bodyText ||| HDL model andthe assumederrormodel; the firstinfluences how
bodyText ||| the HDLdescription is presented, while the secondone dictates
bodyText ||| the testscenario by definingthe start/stop simulationstates (since
bodyText ||| qubits are equallyprone to error, all the signals mustbe
bodyText ||| observed). HDLmodelingofquantumcircuits inorderto attain
bodyText ||| effi
bodyText ||| cient simulation is discussed in [34][35][36][38].
page ||| 196
bodyText ||| secondcycle consists oftime diagrams forall qubits, from the
bodyText ||| startto the stop states. Useful information, extracted fromthe raw,
bodyText ||| bubble-bit-represented, qubittraces are comparedto correctqubit
bodyText ||| values, the resultbeingthe probabilistic accuracy thresholdvalue,
bodyText ||| inthe thirdcycle. The initialization andsimulation cycles depend
bodyText ||| on specific aspects ofquantum circuitsimulation [35]. The data
bodyText ||| processing cycle is independentfromthe specific simulation
bodyText ||| framework andis aimedatdeterminingthe accuracythresholdas
bodyText ||| the mainreliability measure thatalso defines the feasibility ofthe
bodyText ||| quantum circuitimplementations.
bodyText ||| Suppose that, atsimulationtime twe observe signals
bodyText ||| {s0,s1,...,sn}
bodyText |||  . In ouranalysis,
bodyText ||| si
bodyText |||  is the state observedduringnon-
bodyText ||| faulty simulation, so forthe same state ina faulty environmentwe
bodyText ||| will have the state
bodyText ||| si* .
bodyText ||| Forvalidationofthe quantum FTAMs, we needto compare
bodyText ||| si
bodyText ||| with
bodyText ||| si*.
bodyText |||  This can be done by using operator
bodyText |||  d
bodyText ||| if
bodyText ||| (si,s
bodyText ||| ;
bodyText ||| )
bodyText |||  . This
bodyText ||| mean
bodyText ||| s that the total number of overall state errors at simulation
bodyText ||| n − 1
bodyText ||| time tis
bodyText ||| . et=∑d
bodyText ||| if
bodyText ||| (si,s
bodyText ||| ;
bodyText ||| )The error rate on the overall observed
sectionHeader ||| 4. CONCLUSIONS
bodyText ||| This paper presented arguments in favor of two novel computing
bodyText ||| architectures for the purpose of addressing the challenges raised
bodyText ||| by the forthcoming nanoelectronics era. Distributed self-testing
bodyText ||| and self-repairing will probably become a must in the next years
bodyText ||| as centralized control logic is expected to become unable to
bodyText ||| harness the extremely large number of devices, all equally prone
bodyText ||| to errors, that will be integrated onto the same chip. Bio-inspired
bodyText ||| computing brings valuable techniques that explore the potential of
bodyText ||| massively parallel, distributed computation and fault-tolerance
bodyText ||| that will likely provide an essential help to jumpstart new
bodyText ||| nanoelectronic architectures. As one of the representatives of bio-
bodyText ||| inspired computing, the Embryonics project presents a
bodyText ||| hierarchical architecture that achieves fault tolerance through
bodyText ||| implementing an also hierarchical reconfiguration. A similar
bodyText ||| approach for maximizing fault tolerance is present in quantum
bodyText ||| computing, the QUERIST project; even if bio-inspired and
bodyText ||| quantum computing may seem dissimilar at a first glance, they
bodyText ||| both achieve fault tolerance by adapting the same techniques from
bodyText ||| classical computing and using essentially the same error model.
bodyText ||| Nanoelectronics will potentially change the way computing
bodyText ||| systems are designed, not only because of the sheer number of
bodyText ||| devices that will coexist onto the same chip, but also because of
bodyText ||| the sensitivity of these devices.
equation ||| Prob*
equation ||| { i fails} (t) = Prob* { i fails active} (t)
equation ||| ⋅
equation ||| ⋅ Prob* { i spares ok} (t)
equation ||| (13)
equation ||| i=0
figureCaption ||| simulation cycle, consistofatestscenario and an executable HDL
figureCaption ||| model withthe correspondingentanglementanalysis, dictatedby
figureCaption ||| the bubble-bitencoded quantum states [36][38]. The outputofthe
figureCaption ||| states at moments
equation ||| 1 m−1
equation ||| ξsim	∑ et •
equation ||| m
equation ||| j=0 �
figureCaption ||| Figure 15. An overview of the QUERIST project
bodyText ||| Therefore, if nanoelectronics is to be employed to build
bodyText ||| dependable computing machines (a certain contradiction
bodyText ||| notwithstanding), valuable expertise in design can be drawn from
bodyText ||| natural sciences. While biology provides countless examples of
bodyText ||| successfully implemented fault tolerance strategies, physics offers
bodyText ||| theoretical foundations, both of which were found to share
bodyText ||| common ground. It is perhaps a coincidence worth exploring in
bodyText ||| digital computing.
sectionHeader ||| 5. REFERENCES
reference ||| [1] Aharonov, D., Ben-Or, M. Fault Tolerant Quantum
reference ||| Computation with Constant Error. Proc. ACM 29th Ann.
reference ||| Symposium on Theory of Computing, El Paso, Texas, May
reference ||| 1997, pp. 176-188.
reference ||| [2] Avižienis, A., Laprie, J.C., Randell, B., Landwehr, C. Basic
reference ||| Concepts and Taxonomy of Dependable and Secure
reference ||| Computing. IEEE Transactions on Dependable and Secure
reference ||| Computing, 1, 1 (Jan-Mar 2004), 11-33.
reference ||| [3] Butts, M., DeHon, A., Golstein, S.C. Molecular Electronics:
reference ||| Devices, Systems and Tools for Gigagate, Gigabit Chips.
reference ||| Proc. Intl. Conference on CAD (ICCAD’02), 2002, pp. 433-
reference ||| 440.
reference ||| [4] Canham, R., Tyrrell, A. An Embryonic Array with Improved
reference ||| Efficiency and Fault Tolerance. Proc. IEEE NASA/DoD
reference ||| Conference on Evolvable Hardware, Chicago Il, 2003, 275-
reference ||| 282.
reference ||| [5] Gaisler, J. Evaluation of a 32-Bit Microprocessor with Built-
reference ||| In Concurrent Error Detection. Proc. 27th Annual Intl.
reference ||| Symposium on Fault-Tolerant Computing (FTCS-27), 1997,
reference ||| pp. 42-46.
reference ||| [6] Goldstein, S.C. The Challenges and Opportunities of
reference ||| Nanoelectronics. Proc. Government Microcircuit Applica-
reference ||| tions and Critical Technology Conference (GOMAC Tech -
reference ||| 04), Monterey, CA, March 2004.
reference ||| [7] Gottesman, D. Class of quantum error-correcting codes
reference ||| saturating the quantum Hamming bound. Phys. Rev. A 54,
reference ||| 1996, pp. 1862-1868.
reference ||| [8] Johnson, B.W. Design and Analysis of Fault-Tolerant
reference ||| Digital Systems. Addison-Wesley, 1989.
reference ||| [9] Laprie, J.-C. (Ed.). Dependability: Basic Concepts and
reference ||| Terminology. Dependable Computing and Fault-Tolerant
reference ||| Systems Series, Vol. 5, Springer-Verlag, Vienna, 1992.
reference ||| [10] Liden, P., Dahlgren, P., Johansson, R., Karlsson, J. On
reference ||| Latching Probability of Particle Induced Transients in
reference ||| Combinational Networks. Proc. Intl. Symposium on Fault-
reference ||| Tolerant Computing (FTCS-24), 1994, pp.340-349.
reference ||| [11] Mange, D., Sipper, M., Stauffer, A., Tempesti, G. Toward
reference ||| Robust Integrated Circuits: The Embryonics Approach. Proc.
reference ||| of the IEEE, vol. 88, No. 4, April 2000, pp. 516-541.
reference ||| [12] Mange, D. and Tomassini, M. eds. Bio -Inspired Computing
reference ||| Machines: Towards Novel Computational Architectures.
reference ||| Presses Polytechniques et Universitaires Romandes,
reference ||| Lausanne, Switzerland, 1998.
reference ||| [13] Von Neumann, J. The Computer and the Brain (2nd edition).
reference ||| Physical Science, 2000.
reference ||| [14] Von Neumann, J. The Theory of Self-Reproducing
reference ||| Automata. A. W. Burks, ed. University of Illinois Press,
reference ||| Urbana, IL, 1966.
reference ||| [15] Von Neumann, J. Probabilistic Logic and the Synthesis of
reference ||| Reliable Organisms from Unreliable Components. In C.E.
reference ||| Shannon, J. McCarthy (eds.) Automata Studies, Annals of
reference ||| Mathematical Studies 34, Princeton University Press, 1956,
reference ||| 43-98.
reference ||| [16] Nielsen, M.A., Chuang, I.L. Quantum Computation and
reference ||| Quantum Information. Cambridge University Press, 2000.
reference ||| [17] Ortega, C., Tyrrell, A. Reliability Analysis in Self-Repairing
reference ||| Embryonic Systems. Proc. 1st NASA/DoD Workshop on
reference ||| Evolvable Hardware, Pasadena CA, 1999, 120-128.
reference ||| [18] O’Connor, P.D.T. Practical Reliability Engineering. John
reference ||| Wiley &amp; Sons, 4th edition, 2002.
reference ||| [19] Preskill, J. Fault Tolerant Quantum Computation. In H.K.
reference ||| Lo, S. Popescu and T.P. Spiller, eds. Introduction to
reference ||| Quantum Computation, World Scientific Publishing Co.,
reference ||| 1998.
page ||| 197
reference ||| [20] Prodan, L. Self-Repairing Memory Arrays Inspired by
reference ||| Biological Processes. Ph.D. Thesis, “Politehnica” University
reference ||| of Timisoara, Romania, October 14, 2005.
reference ||| [21] Prodan, L., Udrescu, M., Vladutiu, M. Survivability Analysis
reference ||| in Embryonics: A New Perspective. Proc. IEEE NASA/DoD
reference ||| Conference on Evolvable Hardware, Washington DC, 2005,
reference ||| 280-289.
reference ||| [22] Prodan, L., Udrescu, M., Vladutiu, M. Self-Repairing
reference ||| Embryonic Memory Arrays. Proc. IEEE NASA/DoD
reference ||| Conference on Evolvable Hardware, Seattle WA, 2004, 130-
reference ||| 137.
reference ||| [23] Prodan, L., Tempesti, G., Mange, D., and Stauffer, A.
reference ||| Embryonics: Electronic Stem Cells. Proc. Artificial Life VIII,
reference ||| The MIT Press, Cambridge MA, 2003, 101-105.
reference ||| [24] Prodan, L., Tempesti, G., Mange, D., and Stauffer, A.
reference ||| Embryonics: Artificial Cells Driven by Artificial DNA.
reference ||| Proc. 4th International Conference on Evolvable Systems
reference ||| (ICES2001), Tokyo, Japan, LNCS vol. 2210, Springer,
reference ||| Berlin, 2001, 100-111.
reference ||| [25] Prodan, L., Tempesti, G., Mange, D., and Stauffer, A.
reference ||| Biology Meets Electronics: The Path to a Bio-Inspired
reference ||| FPGA. In Proc. 3rd International Conference on Evolvable
reference ||| Systems (ICES2000), Edinburgh, Scotland, LNCS 1801,
reference ||| Springer, Berlin, 2000, 187-196.
reference ||| [26] Rimen, M., Ohlsson, J., Karlsson, J., Jenn, E., Arlat, J.
reference ||| Validation of fault tolerance by fault injection in VHDL
reference ||| simulation models. Rapport LAAS No. 92469, December
reference ||| 1992.
reference ||| [27] Rimen, M., Ohlsson, J., Karlsson, J., Jenn, E., Arlat, J.
reference ||| Design guidelines of a VHDL-based simulation tool for the
reference ||| validation of fault tolerance. Rapport LAAS No931 70, Esprit
reference ||| Basic Research Action No. 6362, May 1993.
reference ||| [28] Shivakumar, P., Kistler, M., Keckler, S.W., Burger, D.,
reference ||| Alvisi, L. Modelling the Effect of Technology Trends on the
reference ||| Soft Error Rate of Combinational Logic. Proc. Intl.
reference ||| Conference on Dependable Systems and Networks (DSN),
reference ||| June 2002, pp. 389-398.
reference ||| [29] Shor, P. Fault-tolerant quantum computation.
reference ||| arXiv.org:quant-ph/9605011, 1996.
reference ||| [30] Shor, P. Algorithms for Quantum Computation: Discrete
reference ||| Logarithms and Factoring. Proc. 35th Symp. on Foundations
reference ||| of Computer Science, 1994, pp. 124-134.
reference ||| [31] Sipper, M., Mange, D., Stauffer, A. Ontogenetic Hardware.
reference ||| BioSystems, 44, 3, 1997, 193-207.
reference ||| [32] Sipper, M., Sanchez, E., Mange, D., Tomassini, M., Perez-
reference ||| Uribe, A., Stauffer, A. A Phylogenetic, Ontogenetic and
reference ||| Epigenetic View of Bio-Inspired Hardware Systems. IEEE
reference ||| Transactions on Evolutionary Computation, 1, 1, April 1997,
reference ||| 83-97.
reference ||| [33] Steane, A. Multiple Particle Interference and Quantum Error
reference ||| Correction. Proc. Roy. Soc. Lond. A 452, 1996, pp. 2551.
reference ||| [34] Udrescu, M. Quantum Circuits Engineering: Efficient
reference ||| Simulation and Reconfigurable Quantum Hardware. Ph.D.
reference ||| Thesis, “Politehnica” University of Timisoara, Romania,
reference ||| November 25, 2005.
reference ||| [35] Udrescu, M., Prodan, L., Vladutiu, M. Simulated Fault
reference ||| Injection in Quantum Circuits with the Bubble Bit
reference ||| Technique. Proc. International Conference &quot;Adaptive and
reference ||| Natural Computing Algorithms&quot;, pp. 276-279.
reference ||| [36] Udrescu, M., Prodan, L., Vladutiu, M. The Bubble Bit
reference ||| Technique as Improvement of HDL-Based Quantum Circuits
reference ||| Simulation. IEEE 38th Annual Simulation Symposium, San
reference ||| Diego CA, USA, 2005, pp. 217-224.
reference ||| [37] Udrescu, M., Prodan, L., Vladutiu, M. Improving Quantum
reference ||| Circuit Dependability with Reconfigurable Quantum Gate
reference ||| Arrays. 2nd ACM International Conference on Computing
reference ||| Frontiers, Ischia, Italy, 2005, pp. 133-144.
reference ||| [38] Udrescu, M., Prodan, L., Vladutiu, M. Using HDLs for
reference ||| describing quantum circuits: a framework for efficient
reference ||| quantum algorithm simulation. Proc. 1st ACM Conference
reference ||| on Computing Frontiers, Ischia, Italy, 2004, 96-110.
reference ||| [39] Tempesti, G. A Self-Repairing Multiplexer-Based FPGA
reference ||| Inspired by Biological Processes. Ph.D. Thesis No. 1827,
reference ||| Logic Systems Laboratory, The Swiss Federal Institute of
reference ||| Technology, Lausanne, 1998.
reference ||| [40] Tempesti, G., Mange, D., Petraglio, E., Stauffer, A., Thoma
reference ||| Y. Developmental Processes in Silicon: An Engineering
reference ||| Perspective. Proc. IEEE NASA/DoD Conference on
reference ||| Evolvable Hardware, Chicago Il, 2003, 265-274.
reference ||| [41] Viamontes, G., Markov, I., Hayes, J.P. High-performance
reference ||| QuIDD-based Simulation of Quantum Circuits. Proc. Design
reference ||| Autom. and Test in Europe (DATE), Paris, France, 2004, pp.
reference ||| 1354-1359.
reference ||| [42] Yu, Y., Johnson, B.W. A Perspective on the State of
reference ||| Research on Fault Injection Techniques. Technical Report
reference ||| UVA-CSCS-FIT-001, University of Virginia, May 20, 2002.
reference ||| [43] ***. ITRS – International Technology Roadmap for Semic-
reference ||| onductors, Emerging Research Devices, 2004, http://www.
reference ||| itrs.net/Common/2004Update/2004_05_ERD.pdf
reference ||| [44] ***. Society of Reliability Engineers, http://www.sre.org/
reference ||| pubs/
reference ||| [45] ***. http://www.dependability.org/wg10.4/
page ||| 198
