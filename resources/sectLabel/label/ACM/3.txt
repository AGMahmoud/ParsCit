title ||| A Computational Approach to Reflective Meta-Reasoning about
title ||| Languages with Bindings *
author ||| Aleksey Nogin Alexei Kopylov Xin Yu Jason Hickey
affiliation ||| Department of Computer Science
affiliation ||| California Institute of Technology
address ||| M/C 256-80, Pasadena, CA 91125
email ||| {nogin,kopylov,xiny,jyh}@cs.caltech.edu
sectionHeader ||| Abstract
bodyText ||| We present a foundation for a computational meta-theory of lan-
bodyText ||| guages with bindings implemented in a computer-aided formal rea-
bodyText ||| soning environment. Our theory provides the ability to reason ab-
bodyText ||| stractly about operators, languages, open-ended languages, classes
bodyText ||| of languages, etc. The theory is based on the ideas of higher-order
bodyText ||| abstract syntax, with an appropriate induction principle parameter-
bodyText ||| ized over the language (i. e. a set of operators) being used. In our ap-
bodyText ||| proach, both the bound and free variables are treated uniformly and
bodyText ||| this uniform treatment extends naturally to variable-length bind-
bodyText ||| ings. The implementation is reflective, namely there is a natural
bodyText ||| mapping between the meta-language of the theorem-prover and the
bodyText ||| object language of our theory. The object language substitution op-
bodyText ||| eration is mapped to the meta-language substitution and does not
bodyText ||| need to be defined recursively. Our approach does not require de-
bodyText ||| signing a custom type theory; in this paper we describe the im-
bodyText ||| plementation of this foundational theory within a general-purpose
bodyText ||| type theory. This work is fully implemented in the MetaPRL the-
bodyText ||| orem prover, using the pre-existing NuPRL-like Martin-L¨of-style
bodyText ||| computational type theory. Based on this implementation, we lay
bodyText ||| out an outline for a framework for programming language experi-
bodyText ||| mentation and exploration as well as a general reflective reasoning
bodyText ||| framework. This paper also includes a short survey of the existing
bodyText ||| approaches to syntactic reflection.
sectionHeader ||| Categories and Subject Descriptors D.3.1 [Programming Lan-
sectionHeader ||| guages]: Formal Definitions and Theory—Syntax; F.4.3 [Math-
sectionHeader ||| ematical Logic and Formal Languages]: Formal Languages—
sectionHeader ||| Operations on languages
sectionHeader ||| General Terms Languages, Theory, Verification
sectionHeader ||| Keywords Higher-Order Abstract Syntax, Reflection, Type The-
sectionHeader ||| ory, Meta PRL, N uPRL, Programming Language Experimentation,
sectionHeader ||| Languages with Bindings.
footnote ||| * An extended version of this paper is available as Caltech Technical Report
footnote ||| CaltechCSTR:2005.003 [NKYH05]
copyright ||| Permission to make digital or hard copies of all or part of this work for personal or
copyright ||| classroom use is granted without fee provided that copies are not made or distributed
copyright ||| for profit or commercial advantage and that copies bear this notice and the full citation
copyright ||| on the first page. To copy otherwise, to republish, to post on servers or to redistribute
copyright ||| to lists, requires prior specific permission and/or a fee.
note ||| MERLIN’05 September 30, 2005, Tallinn, Estonia.
copyright ||| Copyright �c 2005 ACM 1-59593-072-8/05/0009...$5.00.
sectionHeader ||| 1. Introduction
subsectionHeader ||| 1.1 Reflection
bodyText ||| Very generally, reflection is the ability of a system to be “self-
bodyText ||| aware” in some way. More specifically, by reflection we mean the
bodyText ||| property of a computational or formal system to be able to access
bodyText ||| and internalize some of its own properties.
bodyText ||| There are many areas of computer science where reflection
bodyText ||| plays or should play a major role. When exploring properties of
bodyText ||| programming languages (and other languages) one often realizes
bodyText ||| that languages have at least two kinds of properties — semantic
bodyText ||| properties that have to do with the meaning of what the language’s
bodyText ||| constructs express and syntactic properties of the language itself.
bodyText ||| Suppose for example that we are exploring some language that
bodyText ||| contains arithmetic operations. And in particular, in this language
bodyText ||| one can write polynomials like x2 +2x + 1. In this case the number
bodyText ||| of roots of a polynomial is a semantic property since it has to do
bodyText ||| with the valuation of the polynomial. On the other hand, the degree
bodyText ||| of a polynomial could be considered an example of a syntactic
bodyText ||| property since the most natural way to define it is as a property of
bodyText ||| the expression that represents that polynomial. Of course, syntactic
bodyText ||| properties often have semantic consequences, which is what makes
bodyText ||| them especially important. In this example, the number of roots of
bodyText ||| a polynomial is bounded by its degree.
bodyText ||| Another area where reflection plays an important role is run-
bodyText ||| time code generation — in most cases, a language that supports
bodyText ||| run-time code generation is essentially reflective, as it is capable
bodyText ||| of manipulating its own syntax. In order to reason about run-time
bodyText ||| code generation and to express its semantics and properties, it is
bodyText ||| natural to use a reasoning system that is reflective as well.
bodyText ||| There are many different flavors of reflection. The syntactic
bodyText ||| reflection we have seen in the examples above, which is the ability
bodyText ||| of a system to internalize its own syntax, is just one of these
bodyText ||| many flavors. Another very important kind of reflection is logical
bodyText ||| reflection, which is the ability of a reasoning system or logic to
bodyText ||| internalize and reason about its own logical properties. A good
bodyText ||| example of a logical reflection is reasoning about knowledge —
bodyText ||| since the result of reasoning about knowledge is knowledge itself,
bodyText ||| the logic of knowledge is naturally reflective [Art04].
bodyText ||| In most cases it is natural for reflection to be iterated. In the
bodyText ||| case of syntactic reflection we might care not only about the syntax
bodyText ||| of our language, but also about the syntax used for expressing the
bodyText ||| syntax, the syntax for expressing the syntax for expressing the
bodyText ||| syntax and so forth. In the case of the logic of knowledge it is
bodyText ||| natural to have iterations of the form “I know that he knows that
bodyText ||| I know ...”.
bodyText ||| When a formal system is used to reason about properties of pro-
bodyText ||| gramming languages, iterated reflection magnifies the power of the
page ||| 2
bodyText ||| system, making it more natural to reason not just about individual
bodyText ||| languages, but also about classes of languages, language schemas,
bodyText ||| and so on. More generally, reflection adds a lot of additional power
bodyText ||| to a formal reasoning system [GS89, Art99]. In particular, it is
bodyText ||| well-known [G¨od36, Mos52, EM71, Par71] that reflection allows
bodyText ||| a super-exponential reduction in the size of certain proofs. In addi-
bodyText ||| tion, reflection could be a very useful mechanism for implement-
bodyText ||| ing proof search algorithms [ACU93, GWZ00, CFW04]. See also
bodyText ||| [Har95] for a survey of reflection in theorem proving.
subsectionHeader ||| 1.2 Uniform Reflection Framework
bodyText ||| For each of the examples in the previous section there are many
bodyText ||| ad-hoc ways of achieving the specific benefits of a specific fla-
bodyText ||| vor of reflection. This work aims at creating a unifying reflective
bodyText ||| framework that would allow achieving most of these benefits in a
bodyText ||| uniform manner, without having to reinvent and re-implement the
bodyText ||| basic reflective methodology every time. We believe that such a
bodyText ||| framework will increase the power of the formal reasoning tools,
bodyText ||| and it may also become an invaluable tool for exploring the proper-
bodyText ||| ties of novel programming languages, for analyzing run-time code
bodyText ||| generation, and for formalizing logics of knowledge.
bodyText ||| This paper establishes a foundation for the development of this
bodyText ||| framework — a new approach to reflective meta-reasoning about
bodyText ||| languages with bindings. We present a theory of syntax that:
listItem ||| •	in a natural way provides both a higher-order abstract syntax
listItem ||| (HOAS) approach to bindings and a de Bruijn-style approach
listItem ||| to bindings, with easy and natural translation between the two;
listItem ||| •	provides a uniform HOAS-style approach to both bound and
listItem ||| free variables that extends naturally to variable-length “vectors”
listItem ||| of binders;
listItem ||| •	permits meta-reasoning about languages — in particular, the
listItem ||| operators, languages, open-ended languages, classes of lan-
listItem ||| guages etc. are all first-class objects that can be reasoned about
listItem ||| both abstractly and concretely;
listItem ||| •	comes with a natural induction principle for syntax that can be
listItem ||| parameterized by the language being used;
listItem ||| •	provides a natural mapping between the object syntax and meta-
listItem ||| syntax that is free of exotic terms, and allows mapping the
listItem ||| object-level substitution operation directly to the meta-level one
listItem ||| (i.e. P-reduction);
listItem ||| •	is fully derived in a pre-existing type theory in a theorem
listItem ||| prover;
listItem ||| •	is designed to serve as a foundation for a general reflective
listItem ||| reasoning framework in a theorem prover;
listItem ||| •	is designed to serve as a foundation for a programming lan-
listItem ||| guage experimentation framework.
bodyText ||| The paper is structured as follows. Our work inherits a large
bodyText ||| number of ideas from previous efforts and we start in Section 2
bodyText ||| with a brief survey of existing techniques for formal reasoning
bodyText ||| about syntax. Next in Section 3 we outline our approach to rea-
bodyText ||| soning about syntax and in Section 4 we present a formal account
bodyText ||| of our theory based on a Martin-L¨of style computational type the-
bodyText ||| ory [CAB+86, HAB+] and the implementation of that account in
bodyText ||| the MetaPRL theorem prover [Hic97, Hic99, Hic01, HNC+03,
bodyText ||| HNK+, HAB+]. Then in Section 5 we outline our plan for building
bodyText ||| a uniform reflection framework based on the syntactic reflection.
bodyText ||| Finally, in Section 6 we resume the discussion of related work that
bodyText ||| was started in Section 2.
bodyText ||| 1.3 Notation and Terminology
bodyText ||| We believe that our approach to reasoning about syntax is fairly
bodyText ||| general and does not rely on any special features of the theo-
bodyText ||| rem prover we use. However, since we implement this theory in
bodyText ||| MetaPRL, we introduce some basic knowledge about MetaPRL
bodyText ||| terms.
bodyText ||| A MetaPRL term consists of:
listItem ||| 1. An operator name (like “sum”), which is a unique name indi-
listItem ||| cating the logic and component of a term;
listItem ||| 2. A list of parameters representing constant values; and
listItem ||| 3. A set of subterms with possible variable bindings.
bodyText ||| We use the following syntax to describe terms, based on the N u P R L
bodyText ||| definition [ACHA90]:
bodyText ||| In addition, MetaPRL has a meta-syntax somewhat similar to
bodyText ||| the higher-order abstract syntax presented in Pfenning and Elliott
bodyText ||| [PE88]. MetaPRL uses the second-order variables in the style of
bodyText ||| Huet and Lang [HL78] to describe term schemas. For example,
bodyText ||| Xx.V [x], where V is a second-order variable of arity 1, is a schema
bodyText ||| that stands for an arbitrary term whose top-level operator is X.
bodyText ||| This meta-syntax requires that every time a binding occurrence
bodyText ||| is explicitly specified in a schema, all corresponding bound occur-
bodyText ||| rences have to be specified as well. This requirement makes it very
bodyText ||| easy to specify free variable restrictions — for example, Xx.V,
bodyText ||| where V is a second-order meta-variable of arity 0, is a schema
bodyText ||| that stands for an arbitrary term whose top-level operator is X and
bodyText ||| whose body does not have any free occurrences of the variable
bodyText ||| bound by that X. In particular, the schema Xx. V matches the term
bodyText ||| Xy.1, but not the term Xx.x.
bodyText ||| In addition, this meta-language allows specifying certain term
bodyText ||| transformations, including implicit substitution specifications. For
bodyText ||| example, a beta reduction transformation may be specified using
bodyText ||| the following schema:
equation ||| (Xx.V1 [x]) V2 H V1 [V2]
bodyText ||| Here the substitution of V2 for x in V1 is specified implicitly.
bodyText ||| Throughout this paper we will use this second-order notation to
bodyText ||| denote arbitrary terms — namely, unless stated otherwise, when we
bodyText ||| write “Xx.t[x]” we mean an arbitrary term of this form, not a term
bodyText ||| containing a concrete second-order variable named “t”.
bodyText ||| As in LF [HHP93] we assume that object level variables (i.e.
bodyText ||| the variables of the language whose syntax we are expressing)
bodyText ||| are directly mapped to meta-theory variables (i.e. the variable of
bodyText ||| the language that we use to express the syntax). Similarly, we
bodyText ||| assume that the object-level binding structure is mapped to the
bodyText ||| meta-level binding structure. In other words, the object-level notion
bodyText ||| of the “binding/bound occurrence” is a subset of that in the meta-
bodyText ||| language. We also consider a-equal terms — both on the object
bodyText ||| level and on the meta-level — to be identical and we assume that
bodyText ||| substitution avoids capture by renaming.
bodyText ||| The sequent schema language we use [NH02] contains a num-
bodyText ||| ber of more advanced features in addition to those outlined here.
bodyText ||| However, for the purposes of this presentation, the basic features
bodyText ||| outlined above are sufficient.
sectionHeader ||| 2. Previous Models of Reflection
bodyText ||| In 1931 G¨odel used reflection to prove his famous incompleteness
bodyText ||| theorem [G¨od31]. To express arithmetic in arithmetic itself, he
bodyText ||| assigned a unique number (a G¨odel number) to each arithmetic
equation ||| opname
equation ||| �- J 
equation ||| operator name
equation ||| [p1; .. .; pn] f�v1.t1; . . . ; �vm.tm}
equation ||| Y	Y	J
equation ||| parameters	subterms
page ||| 3
bodyText ||| formula. A G¨odel number of a formula is essentially a numeric
bodyText ||| code of a string of symbols used to represent that formula.
bodyText ||| A modern version of the G¨odel’s approach was used by Aitken
bodyText ||| et al. [ACHA90, AC92, ACU93, Con94] to implement reflection
bodyText ||| in the NuPRL theorem prover [CAB+86, ACE+00]. A large part
bodyText ||| of this effort was essentially a reimplementation of the core of the
bodyText ||| NuPRL prover inside NuPRL’s logical theory.
bodyText ||| In G¨odel’s approach and its variations (including Aitken’s one),
bodyText ||| a general mechanism that could be used for formalizing one logical
bodyText ||| theory in another is applied to formalizing a logical theory in itself.
bodyText ||| This can be very convenient for reasoning about reflection, but for
bodyText ||| our purposes it turns out to be extremely impractical. First, when
bodyText ||| formalizing a theory in itself using generic means, the identity
bodyText ||| between the theory being formalized and the one in which the
bodyText ||| formalization happens becomes very obfuscated, which makes it
bodyText ||| almost impossible to relate the reflected theory back to the original
bodyText ||| one. Second, when one has a theorem proving system that already
bodyText ||| implements the logical theory in question, creating a completely
bodyText ||| new implementation of this logical theory inside itself is a very
bodyText ||| tedious redundant effort. Another practical disadvantage of the
bodyText ||| G¨odel numbers approach is that it tends to blow up the size of
bodyText ||| the formulas; and iterated reflection would cause the blow-up to
bodyText ||| be iterated as well, making it exponential or worse.
bodyText ||| A much more practical approach is being used in some pro-
bodyText ||| gramming languages, such as Lisp and Scheme. There, the com-
bodyText ||| mon solution is for the implementation to expose its internal syntax
bodyText ||| representation to user-level code by the quote constructor (where
bodyText ||| quote (t) prevents the evaluation of the expression t). The prob-
bodyText ||| lems outlined above are solved instantly by this approach: there is
bodyText ||| no blow-up, there is no repetition of structure definitions, there is
bodyText ||| even no need for verifying that the reflected part is equivalent to the
bodyText ||| original implementation since they are identical. Most Scheme im-
bodyText ||| plementations take this even further: the eval function is the inter-
bodyText ||| nal function for evaluating a Scheme expression, which is exposed
bodyText ||| to the user-level; Smith [Smi84] showed how this approach can
bodyText ||| achieve an infinite tower of processors. A similar language with the
bodyText ||| quotation and antiquotation operators was introduced in [GMO03].
bodyText ||| This approach, however, violates the congruence property with
bodyText ||| respect to computation: if two terms are computationally equal then
bodyText ||| one can be substituted for the other in any context. For instance,
bodyText ||| although 2 * 2 is equal to 4, the expressions “2*2” and “4” are
bodyText ||| syntactically different, thus we can not substitute 2*2 by 4 in
bodyText ||| the expression quote(2*2). The congruence property is essential
bodyText ||| in many logical reasoning systems, including the NuPRL system
bodyText ||| mentioned above and the MetaPRL system [HNC+03, HNK+,
bodyText ||| HAB+] that our group uses.
bodyText ||| A possible way to expose the internal syntax without violat-
bodyText ||| ing the congruence property is to use the so-called “quoted” or
bodyText ||| “shifted” operators [AA99, Bar01, Bar05] rather than quoting the
bodyText ||| whole expression at once. For any operator op in the original lan-
bodyText ||| guage, we add the quoted operator (denoted as op) to represent a
bodyText ||| term built with the operator op. For example, if the original lan-
bodyText ||| guage contains the constant “0” (which, presumably, represents the
bodyText ||| number 0), then in the reflected language, 0 would stand for the
bodyText ||| term that denotes the expression “0”. Generally, the quoted opera-
bodyText ||| tor has the same arity as the original operator, but it is defined on
bodyText ||| syntactic terms rather than on semantic objects. For instance, while
bodyText ||| * is a binary operator on numbers, * is a binary operator on terms.
bodyText ||| Namely, if t1 and t2 are syntactic terms that stand for expressions
bodyText ||| e1 and e2 respectively, then t1 *t2 is a new syntactic term that stands
bodyText ||| for the expression e1 *e2. Thus, the quotation of the expression 1 *2
bodyText ||| would be 1 * 2.
bodyText ||| In general, the well-formedness (typing) rule for a quoted oper-
bodyText ||| ator is the following:
equation ||| t1 E Term	...	tn E Term
equation ||| op{t1; ... ; tn} E Term
equation ||| where Term is a type of terms.
bodyText ||| Note that quotations can be iterated arbitrarily many times,
bodyText ||| allowing us to quote quoted terms. For instance, 1 stands for the
bodyText ||| term that denotes the term that denotes the numeral 1.
bodyText ||| Problems arise when quoting expressions that contain binding
bodyText ||| variables. For example, what is the quotation of Xx.x? There are
bodyText ||| several possible ways of answering this question. A commonly
bodyText ||| used approach [PE88, DH94, DFH95, ACM02, ACM03] in logical
bodyText ||| frameworks such as Elf [Pfe89], LF [HHP93], and Isabelle [PN90,
bodyText ||| Pau94] is to construct an object logic with a concrete X operator
bodyText ||| that has a type like
equation ||| (Term -+ Term) -+ Term or (Var -+ Term) -+ Term.
bodyText ||| In this approach, the quoted Xx.x might look like X(Xx.x) and the
bodyText ||| quoted Xx.1 might look like X(Xx.1). Note that in these examples
bodyText ||| the quoted terms have to make use of both the syntactic (i. e. quoted)
bodyText ||| operator X and the semantic operator X.
bodyText ||| Exotic Terms. Naive implementations of the above approach
bodyText ||| suffer from the well-known problem of exotic terms [DH95,
bodyText ||| DFH95]. The issue is that in general we can not allow applying
bodyText ||| the X operator to an arbitrary function that maps terms to terms (or
bodyText ||| variables to terms) and expect the result of such an application to
bodyText ||| be a “proper” reflected term.
bodyText ||| Consider for example the following term:
equation ||| X(Xx. if x = 1 then 1 else 2)
bodyText ||| It is relatively easy to see that it is not a real syntactic term and
bodyText ||| can not be obtained by quoting an actual term. (For comparison,
bodyText ||| consider X(Xx. if x = 1 then 1 else 2), which is a quotation of
bodyText ||| Xx. if x = 1 then 1 else 2).
bodyText ||| How can one ensure that Xe denotes a “real” term and not an
bodyText ||| “exotic” one? That is, is it equal to a result of quoting an actual
bodyText ||| term of the object language? One possibility is to require e to be
bodyText ||| a substitution function; in other words it has to be equal to an
bodyText ||| expression of the form Xx.t[x] where t is composed entirely of term
bodyText ||| constructors (i.e. quoted operators) and x, while using destructors
bodyText ||| (such as case analysis, the if operator used in the example above,
bodyText ||| etc) is prohibited.
bodyText ||| There are a number of approaches to enforcing the above restric-
bodyText ||| tion. One of them is the usage of logical frameworks with restricted
bodyText ||| function spaces [PE88, HHP93], where X-terms may only con-
bodyText ||| tain constructors. Another is to first formalize the larger type that
bodyText ||| does include exotic terms and then to define recursively a predicate
bodyText ||| describing the “validity” or “well-formedness” of a term [DH94,
bodyText ||| DFH95] thus removing the exotic terms from consideration. Yet
bodyText ||| another approach is to create a specialized type theory that com-
bodyText ||| bines the idea of restricted function spaces with a modal type oper-
bodyText ||| ator [DPS97, DL99, DL01]. There the case analysis is disallowed
bodyText ||| on objects of “pure” type T, but is allowed on objects of a special
bodyText ||| type ❑T. This allows expressing both the restricted function space
bodyText ||| “T1 -+ T2” and the unrestricted one “(�T1) -+ T2” within a single
bodyText ||| type theory.
bodyText ||| Another way of regarding the problem of exotic terms is that it
bodyText ||| is caused by the attempt to give a semantic definition to a primarily
bodyText ||| syntactic property. A more syntax-oriented approach was used by
bodyText ||| Barzilay et al. [BA02, BAC03, Bar05]. In Barzilay’s approach, the
bodyText ||| quoted version of an operator that introduces a binding has the
bodyText ||| same shape (i.e. the number of subterms and the binding structure)
bodyText ||| as the original one and the variables (both the binding and the
none ||| (1)
page ||| 4
bodyText ||| bound occurrences) are unaffected by the quotation. For instance,
bodyText ||| the quotation of Xx.x is just Xx.x.
bodyText ||| The advantages of this approach include:
listItem ||| •	This approach is simple and clear.
listItem ||| •	Quoted terms have the same structure as original ones, inherit-
listItem ||| ing a lot of properties of the object syntax.
listItem ||| •	In all the above approaches, the a-equivalence relation for
listItem ||| quoted terms is inherited “for free”. For example, Xx.x and
listItem ||| Xy.y are automatically considered to be the same term.
listItem ||| •	Substitution is also easy: we do not need to re-implement the
listItem ||| substitution that renames binding variables to avoid the capture
listItem ||| of free variables; we can use the substitution of the original
listItem ||| language instead.
bodyText ||| To prune exotic terms, Barzilay says that Xx.t[x] is a valid term
bodyText ||| when Xx.t[x] is a substitution function. He demonstrates that it is
bodyText ||| possible to formalize this notion in a purely syntactical fashion. In
bodyText ||| this setting, the general well-formedness rule for quoted terms with
bodyText ||| bindings is the following:
equation ||| is substk {x1, · · · , xk.t[&quot;x]}	· · ·	is substl {z 1, · · · , zl.s[&quot;z]}
equation ||| op{x1, · · · , xk.t[&quot;x]; · · · ; z1, · · · , zl.s[&quot;z]} E Term
bodyText ||| (2)
bodyText ||| where is substn {x1 , · · · , xn.t[&quot;x]} is the proposition that t is a sub-
bodyText ||| stitution function over variables x1 , · · · , xn (in other words, it is a
bodyText ||| syntactic version of the Valid predicate of [DH94, DFH95]). This
bodyText ||| proposition is defined syntactically by the following two rules:
equation ||| is substn {x1, · · · , xn . xi}
equation ||| and
equation ||| is substn+k{x1, · · · , xn,y1, · · · , yk.t[&quot;x;&quot;y]}
equation ||| ...
equation ||| is substn+l {x1, · · · , xn, z1, ··· , zl.s[&quot;x; &quot;z]}}
equation ||| is substn {x1 · · ·xn.op{y1 · · ·yk.t[&quot;x; &quot;y]; · · · ; z1 · · ·zl.s[&quot;x; &quot;z]}}
bodyText ||| In this approach the is substn {} and X operators are essentially
bodyText ||| untyped (in NuPRL type theory, the computational properties of
bodyText ||| untyped terms are at the core of the semantics; types are added on
bodyText ||| top of the untyped computational system).
bodyText ||| Recursive Definition and Structural Induction Principle. A
bodyText ||| difficulty shared by both the straightforward implementations of
bodyText ||| the (Term -+ Term) -+ Term approach and by the Barzilay’s one
bodyText ||| is the problem of recursively defining the Term type. We want to
bodyText ||| define the Term type as the smallest set satisfying rules (1) and (2).
bodyText ||| Note, however, that unlike rule (1), rule (2) is not monotonic in the
bodyText ||| sense that is substk {x1, · · · , xk.t[&quot;x]} depends non-monotonically
bodyText ||| on the Term type. For example, to say whether Xx.t[x] is a term, we
bodyText ||| should check whether t is a substitution function over x. It means at
bodyText ||| least thatfor every x in Term, t[x] should be in Term as well. Thus
bodyText ||| we need to define the whole type Term before using (2), which
bodyText ||| produces a logical circle. Moreover, since X has type (Term -+
bodyText ||| Term) -+ Term, it is hard to formulate the structural induction
bodyText ||| principle for terms built with the X term constructor.
bodyText ||| Variable-Length Lists of Binders. In Barzilay’s approach, for
bodyText ||| each number n, is substn {} is considered to be a separate operator
bodyText ||| — there is no way to quantify over n, and there is no way to
bodyText ||| express variable-length lists of binders. This issue of expressing the
bodyText ||| unbounded-length lists of binders is common to some of the other
bodyText ||| approaches as well.
bodyText ||| Meta-Reasoning. Another difficulty that is especially apparent
bodyText ||| in Barzilay’s approach is that it only allows reasoning about con-
bodyText ||| crete operators in concrete languages. This approach does not pro-
bodyText ||| vide the ability to reason about operators abstractly; in particular,
bodyText ||| there is no way to state and prove meta-theorems that quantify over
bodyText ||| operators or languages, much less classes of languages.
sectionHeader ||| 3. Higher-Order Abstract Syntax
sectionHeader ||| with Inductive Definitions
bodyText ||| Although it is possible to solve the problems outlined in the previ-
bodyText ||| ous Section (and we will return to the discussion of some of those
bodyText ||| solutions in Section 6), our desire is to avoid these difficulties from
bodyText ||| the start. We propose a natural model of reflection that manages to
bodyText ||| work around those difficulties. We will show how to give a sim-
bodyText ||| ple recursive definition of terms with binding variables, which does
bodyText ||| not allow the construction of exotic terms and does allow structural
bodyText ||| induction on terms.
bodyText ||| In this Section we provide a conceptual overview of our ap-
bodyText ||| proach; details are given in Section 4.
subsectionHeader ||| 3.1 Bound Terms
bodyText ||| One of the key ideas of our approach is how we deal with terms
bodyText ||| containing free variables. We extend to free variables the principle
bodyText ||| that variable names do not really matter. In fact, we model free
bodyText ||| variables as bindings that can be arbitrarily a-renamed. Namely,
bodyText ||| we will write bterm{x1, · · · , xn.t[&quot;x]} for a term t over variables
bodyText ||| x1, · · ·, xn. For example, instead of term x*y we will use the
bodyText ||| term bterm{x, y.x*y} when it is considered over variables x and
bodyText ||| y and bterm{x, y, z.x*y} when it is considered over variables x,
bodyText ||| y and z. Free occurrences of xi in t[&quot;x] are considered bound
bodyText ||| in bterm{x1, · · · , xn.t[&quot;x]} and two a-equal bterm{} expressions
bodyText ||| (“bterms”) are considered to be identical.
bodyText ||| Not every bterm is necessarily well-formed. We will define the
bodyText ||| type of terms in such a way as to eliminate exotic terms. Consider
bodyText ||| for example a definition of lambda-terms.
construct ||| EXAMPLE 1. We can define a set of reflected lambda-terms as the
construct ||| smallest set such that
listItem ||| •	bterm{x1, · · · , xn.xi}, where 1 &lt; i &lt; n, is a lambda-term (a
listItem ||| variable);
listItem ||| •	ifbterm{x1, · · · , xn, xn+1.t[&quot;x] ) is a lambda-term, then
listItem ||| bterm{x1 , · · · , xn .Xxn+1 .t[&quot;x])
listItem ||| is also a lambda-term (an abstraction);
listItem ||| •	if bterm{x1, · · · , xn.t1 [&quot;x]} and bterm{x1, · · · , xn.t2[&quot;x]} are
listItem ||| lambda-terms, then
listItem ||| bterm{x1; · · · ; xn.apply{t1 [&quot;x]; t2[&quot;x]}}
listItem ||| is also a lambda-term (an application).
bodyText ||| In a way, bterms could be understood as an explicit coding for
bodyText ||| Barzilay’s substitution functions. And indeed, some of the basic
bodyText ||| definitions are quite similar. The notion of bterms is also very
bodyText ||| similar to that of local variable contexts [FPT99].
subsectionHeader ||| 3.2 Terminology
bodyText ||| Before we proceed further, we need to define some terminology.
construct ||| DEFINITION 1. We change the notion of subterm so that the sub-
construct ||| terms of a bterm are also bterms. For example, the immediate sub-
construct ||| terms of bterm{x, y.x*y} are bterm{x, y.x} and bterm{x, y.y}; the
construct ||| immediate subterm ofbterm{x.Xy.x} is bterm{x, y.x}.
construct ||| DEFINITION 2. We call the number of outer binders in a bterm
construct ||| expression its binding depth. Namely, the binding depth of the
construct ||| bterm bterm{x1, · · · , xn.t[&quot;x]} is n.
construct ||| DEFINITION 3. Throughout the rest of the paper we use the notion
construct ||| of operator shape. The shape ofan operator is a list ofnatural num-
construct ||| bers each stating how many new binders the operator introduces on
page ||| 5
bodyText ||| the corresponding subterm. The length of the shape list is therefore
bodyText ||| the arity of the operator. For example, the shape of the + operator
bodyText ||| is [0; 0] and the shape of the X operator is [1].
bodyText ||| The mapping from operators to shapes is also sometimes called
bodyText ||| a binding signature of a language [FPT99, Plo90].
construct ||| DEFINITION 4. Let op be an operator with shape [d1; · · · ; dN],
construct ||| and let btl be a list of bterms [b1; · · · ; bM]. We say that btl is
construct ||| compatible with op at depth n when,
listItem ||| 1. N=M;
listItem ||| 2. the binding depth of bterm bj is n + dj for each 1 &lt; j &lt; N.
subsectionHeader ||| 3.3 Abstract Operators
bodyText ||| Expressions of the form bterm{&quot;x.op{· · · }} can only be used to ex-
bodyText ||| press syntax with concrete operators. In other words, each expres-
bodyText ||| sion of this form contains a specific constant operator op. However,
bodyText ||| we would like to reason about operators abstractly; in particular,
bodyText ||| we want to make it possible to have variables of the type “Op” that
bodyText ||| can be quantified over and used in the same manner as operator
bodyText ||| constants. In order to address this we use explicit term constructors
bodyText ||| in addition to bterm{&quot;x.op{· · · }} constants.
bodyText ||| The expression mk bterm{n; “op”; btl}, where “op” is some en-
bodyText ||| coding of the quoted operator op, stands for a bterm with binding
bodyText ||| depth n, operator op and subterms btl. Namely,
equation ||| mk bterm{n; op; bterm{x1 , · · · , xn, &quot;y1 .t1 [&quot;x; &quot;y1]} :: · · · ::
equation ||| bterm{x1, · · · ,xn,&quot;yk.tk[&quot;x; &quot;yk]} :: nil}
equation ||| is bterm{x1, · · · , xn.op {&quot;y1 .t1 [&quot;x; &quot;y1]; · · · ; &quot;yk.tk[&quot;x; &quot;yk]}}. Here,
equation ||| nil is the empty list and :: is the list cons operator and there-
equation ||| fore the expression b1 :: · · · :: bn :: nil represents the concrete list
equation ||| [b1; ··· ; bn].
bodyText ||| Note that if we know the shape of the operator op and we know
bodyText ||| that the mk bterm expression is well-formed (or, more specifically,
bodyText ||| if we know that btl is compatible with op at depth n), then it
bodyText ||| would normally be possible to deduce the value of n (since n is
bodyText ||| the difference between the binding depth of any element of the list
bodyText ||| btl and the corresponding element of the shape(op) list). There are
bodyText ||| two reasons, however, for supplying n explicitly:
listItem ||| •	When btl is empty (in other words, when the arity of op is 0),
listItem ||| the value of n can not be deduced this way and still needs to be
listItem ||| supplied somehow. One could consider 0-arity operators to be a
listItem ||| special case, but this results in a significant loss of uniformity.
listItem ||| •	When we do not know whether an mk bterm expression is
listItem ||| necessarily well-formed (and as we will see it is often useful
listItem ||| to allow this to happen), then a lot of definitions and proofs
listItem ||| are greatly simplified when the binding depth of mk bterm
listItem ||| expressions is explicitly specified.
bodyText ||| Using the mk bterm constructor and a few other similar con-
bodyText ||| structors that will be introduced later, it becomes easy to reason ab-
bodyText ||| stractly about operators. Indeed, the second argument to mk bterm
bodyText ||| can now be an arbitrary expression, not just a constant. This has a
bodyText ||| cost of making certain definitions slightly more complicated. For
bodyText ||| example, the notion of “compatible with op at depth n” now be-
bodyText ||| comes an important part of the theory and will need to be explicitly
bodyText ||| formalized. However, this is a small price to pay for the ability to
bodyText ||| reason abstractly about operators, which easily extends to reason-
bodyText ||| ing abstractly about languages, classes of languages and so forth.
subsectionHeader ||| 3.4 Inductively Defining the Type of Well-Formed Bterms
bodyText ||| There are two equivalent approaches to inductively defining the
bodyText ||| general type (set) of all well-formed bterms. The first one follows
bodyText ||| the same idea as in Example 1:
listItem ||| •	bterm{x1 , · · · , xn.xi } is a well-formed bterm for 1 &lt; i &lt; n;
listItem ||| •	mk bterm{n; op; btl} is a well-formed bterm when op is a well-
listItem ||| formed quoted operator and btl is a list of well-formed bterms
listItem ||| that is compatible with op at some depth n.
bodyText ||| If we denote bterm{x1, · · · , xl, y, z1, · · · , zr.y} as var{l; r},
bodyText ||| we can restate the base case of the above definition as “var{l; r},
bodyText ||| where l and r are arbitrary natural numbers, is a well-formed
bodyText ||| bterm”. Once we do this it becomes apparent that the above def-
bodyText ||| inition has a lot of similarities with de Bruijn-style indexing of
bodyText ||| variables [dB72]. Indeed, one might call the numbers l and r the
bodyText ||| left and right indices of the variable var{l; r}.
bodyText ||| It is possible to provide an alternate definition that is closer to
bodyText ||| pure HOAS:
listItem ||| •	bnd{x.t[x]}, where t is a well-formed substitution function, is
listItem ||| a well-formed bterm (the bnd operation increases the binding
listItem ||| depth of t by one by adding x to the beginning of the list of t’s
listItem ||| outer binders).
listItem ||| •	mk term{op; btl}, where op is a well-formed quoted operator,
listItem ||| and btl is a list of well-formed bterms that is compatible with
listItem ||| op at depth 0, is a well-formed bterm (of binding depth 0).
bodyText ||| Other than better capturing the idea of HOAS, the latter defini-
bodyText ||| tion also makes it easier to express the reflective correspondence
bodyText ||| between the meta-syntax (the syntax used to express the theory of
bodyText ||| syntax, namely the one that includes the operators mk bterm, bnd,
bodyText ||| etc.) and the meta-meta-syntax (the syntax that is used to express
bodyText ||| the theory of syntax and the underlying theory, in other words, the
bodyText ||| syntax that includes the second-order notations.) Namely, provided
bodyText ||| that we define the subst{bt; t} operation to compute the result of
bodyText ||| substituting a closed term t for the first outer binder of the bterm
bodyText ||| bt, we can state that
equation ||| subst{bnd{x.t1 [x]} ; t2} ≡ t1 [t2] (3)
equation ||| (where t1 and t2 are literal second-order variables). In other words,
equation ||| we can state that the substitution operator subst and the implicit
equation ||| second-order substitution in the “meta-meta-” language are equiv-
equation ||| alent.
bodyText ||| The downside of the alternate definition is that it requires defin-
bodyText ||| ing the notion of “being a substitution function”.
subsectionHeader ||| 3.5 Our Approach
bodyText ||| In our work we try to combine the advantages of both approaches
bodyText ||| outlined above. In the next Section we present a theory that includes
bodyText ||| both the HOAS-style operations (bnd, mk term) and the de Bruijn-
bodyText ||| style ones (var, mk bterm). Our theory also allows deriving the
bodyText ||| equivalence (3). In our theory the definition of the basic syntactic
bodyText ||| operations is based on the HOAS-style operators; however, the
bodyText ||| recursive definition of the type of well-formed syntax is based on
bodyText ||| the de Bruijn-style operations. Our theory includes also support for
bodyText ||| variable-length lists of binders.
sectionHeader ||| 4. Formal Implementation in a Theorem Prover
bodyText ||| In this Section we describe how the foundations of our theory are
bodyText ||| formally defined and derived in the NuPRL-style Computational
bodyText ||| Type Theory in the MetaPRL Theorem Prover. For brevity, we
bodyText ||| will present a slightly simplified version of our implementation;
bodyText ||| full details are available in the extended version of this paper
bodyText ||| [NKYH05, Appendix].
subsectionHeader ||| 4.1 Computations and Types
bodyText ||| In our work we make heavy usage of the fact that our type theory
bodyText ||| allows us to define computations without stating upfront (or even
bodyText ||| knowing) what the relevant types are. In NuPRL-style type theo-
page ||| 6
bodyText ||| ries (which some even dubbed “untyped type theory”), one may de-
bodyText ||| fine arbitrary recursive functions (even potentially nonterminating
bodyText ||| ones). Only when proving that such function belongs to a particular
bodyText ||| type, one may have to prove termination. See [All87a, All87b] for
bodyText ||| a semantics that justifies this approach.
bodyText ||| The formal definition of the syntax of terms consists of two
bodyText ||| parts:
listItem ||| •	The definition of untyped term constructors and term oper-
listItem ||| ations, which includes both HOAS-style operations and de
listItem ||| Bruijn-style operations. As it turns out, we can establish most
listItem ||| of the reduction properties without explicitly giving types to all
listItem ||| the operations.
listItem ||| •	The definition of the type of terms. We will define the type of
listItem ||| terms as the type that contains all terms that can be legitimately
listItem ||| constructed by the term constructors.
subsectionHeader ||| 4.2 HOAS Constructors
bodyText ||| At the core of our term syntax definition are two basic HOAS-style
bodyText ||| constructors:
listItem ||| •	bnd{x.t[x]} is meant to represent a term with a free variable x.
listItem ||| The intended semantics (which will not become explicit until
listItem ||| later) is that bnd{x.t[x]} will only be considered well-formed
listItem ||| when t is a substitution function.
bodyText ||| Internally, bnd{x.t[x]} is implemented simply as the pair
bodyText ||| (0, Xx.t[x]). This definition is truly internal and is used only
bodyText ||| to prove the properties of the two destructors presented below;
bodyText ||| it is never used outside of this Section (Section 4.2).
listItem ||| •	mk term{op; ts} pairs op with ts. The intended usage of this
listItem ||| operation (which, again, will only become explicit later) is that
listItem ||| it represents a closed term (i.e. a bterm of binding depth 0) with
listItem ||| operator op and subterms ts. It will be considered well-formed
listItem ||| when op is an operator and ts is a list of terms that is compatible
bodyText ||| with op at depth 0. For example, mk term{X; bnd{x.x}} is Xx.x.
bodyText ||| Internally, mk term{op; ts} is implemented as the nested pair
bodyText ||| (1, (op, ts)). Again, this definition is never used outside of this
bodyText ||| Section.
bodyText ||| We also implement two destructors:
listItem ||| •	subst{bt; t} is meant to represent the result of substituting term
listItem ||| t for the first variable of the bterm bt. Internally, subst{bt; t}
listItem ||| is defined simply as an application (bt.2) t (where bt.2 is the
listItem ||| second element of the pair bt).
bodyText ||| We derive the following property of this substitution operation:
equation ||| subst{bnd{x.t1 [x]} ; t2} ≡ t1 [t2]
equation ||| where “≡” is the computational equality relation1 and t1 and
equation ||| t2 may be absolutely arbitrary, even ill-typed. This derivation
equation ||| is the only place where the internal definition of subst{bt; t} is
equation ||| used.
bodyText ||| Note that the above equality is exactly the “reflective property
bodyText ||| of substitution” (3) that was one of the design goals for our
bodyText ||| theory.
listItem ||| •	weak dest {bt; bcase; op, ts.mkt case[op; ts]} is designed to
listItem ||| provide a way to find out whether bt is a bnd{} or a mk term{op; ts}
footnote ||| 1 In NuPRL-style type theories the computational equality relation (which
footnote ||| is also sometimes called “squiggle equality” and is sometimes denoted
bodyText ||| as“∼” or “←-+”) is the finest-grained equality relation in the theory.
bodyText ||| When a ≡ b is true, a may be replaced with b in an arbitrary context.
bodyText ||| Examples of computational equality include beta-reduction Xx.a[x]b ≡
bodyText ||| a[b], arithmetical equalities (1 + 2 ≡ 3), and definitional equality (an
bodyText ||| abstraction is considered to be computationally equal to its definition).
bodyText ||| and to “extract” the op and ts in the latter case. In the rest of
bodyText ||| this paper we will use the “pretty-printed” form for weak dest
bodyText ||| — “match bt with bnd{ } -+ bcase I mk term{op; ts} -+
bodyText ||| mkt case[op; ts]”. Internally, it is defined as
bodyText ||| if bt.1 = 0 then bcase else mkt case[bt.2.1; bt.2.2].
bodyText ||| From this internal definition we derive the following properties
bodyText ||| of weak dest:
equation ||| ⎛	⎞
equation ||| matchbnd{x.t[x]} with
equation ||| ⎝bnd{ } -+ bcase	⎠
equation ||| bcase
equation ||| mk term{op; ts} -+ mkt case[op; ts]≡
equation ||| ⎛
equation ||| matchmk term{op; ts} with
equation ||| ⎝bnd{ } -+ bcase
equation ||| Imk term{o; t} -+ mkt case[o; t]
equation ||| 4.3 Vector HOAS Operations
bodyText ||| As we have mentioned at the end of Section 2, some approaches to
bodyText ||| reasoning about syntax make it hard or even impossible to express
bodyText ||| arbitrary-length lists of binders. In our approach, we address this
bodyText ||| challenge by allowing operators where a single binding in the meta-
bodyText ||| language stands for a list of object-level bindings. In particular, we
bodyText ||| allow representing bnd{x1.bnd{x2. · · · bnd{xn.t[x1; ... ; xn]} · · ·}}
bodyText ||| as
bodyText ||| vbnd{n; x.t[nth{1; x}; . . . ; nth{n; x}]}, where “nth{i; l}” is the “i-
bodyText ||| th element of the list l” function.
bodyText ||| We define the following vector-style operations:
listItem ||| •	vbnd{n; x.t[x]} represents a “telescope” of nested bnd opera-
listItem ||| tions. It is defined by induction2 on the natural number n as
listItem ||| follows:
equation ||| vbnd{0; x.t[x]}:= t[nil]
equation ||| vbnd{n + 1; x.t[x]}:= bnd{v.vbnd{n; x.t[v :: x]}}
bodyText ||| We also introduce vbnd{n; t} as a simplified notation for
bodyText ||| vbnd{n; x.t} when t does not have free occurrences of x.
listItem ||| •	vsubst{bt; ts} is a “vector” substitution operation that is meant
listItem ||| to represent the result of simultaneous substitution of the terms
listItem ||| in the ts list for the first ItsI variables of the bterm bt (here IlI is
listItem ||| the length of the list l). vsubst{bt; ts} is defined by induction on
listItem ||| the list ts as follows:
equation ||| vsubst{bt; nil}:= bt
equation ||| vsubst{bt; t :: ts}:= vsubst{subst{bt; t} ; ts}
bodyText ||| Below are some of the derived properties of these operations:
equation ||| 	bnd{v.t[v]} ≡ vbnd{1; hd(v)}	(4)
equation ||| Vm , n E N.
equation ||| �vbnd{m +n; x.t[x]} ≡ vbnd{m; y.vbnd{n; z.t[y@z]}}) (5)
equation ||| 	Vl E List. (vsubst{vbnd{Il I; v.t[v]} ;l} ≡ t[l])	(6)
equation ||| Vl E List.Vn E N. �(n ≥ IlI) ⇒	(7)
equation ||| (vsubst{vbnd{n; v.t[v]} ;l} ≡ vbnd{n − IlI; v.bt[l@v]}))
equation ||| Vn E N.	(8)
equation ||| vbnd{n; l.vsubst{vbnd{n; v.t[v]} ;l}} ≡ vbnd{n; l.t[l]})
bodyText ||| where “hd” is the list “head” operation, “@” is the list append
bodyText ||| operation, “List” is the type of arbitrary lists (the elements of a list
bodyText ||| do not have to belong to any particular type), N is the type of natural
bodyText ||| numbers, and all the variables that are not explicitly constrained to
bodyText ||| a specific type stand for arbitrary expressions.
footnote ||| 2 Our presentation of the inductive definitions is slightly simplified by
footnote ||| omitting some minor technical details. See [NKYH05, Appendix] for
footnote ||| complete details.
equation ||| ⎞⎠ ≡mkt case[op; ts]
page ||| 7
bodyText ||| Equivalence (5) allows the merging and splitting of vector bnd
bodyText ||| operations. Equivalence (6) is a vector variant of equivalence (3).
bodyText ||| Equivalence (8) is very similar to equivalence (6) applied in the
bodyText ||| vbnd{n; l. · · ·} context, except that (8) does not require l to be a
bodyText ||| member of any special type.
subsectionHeader ||| 4.4 De Bruijn-style Operations
bodyText ||| Based on the HOAS constructors defined in the previous two sec-
bodyText ||| tions, we define two de Bruijn-style constructors.
listItem ||| •	var{i; j} is defined as vbnd{i; bnd{v.vbnd{j; v}}}. It is easy to
listItem ||| see that this definition indeed corresponds to the informal
equation ||| bterm{x1,··· ,xl, y, z1,··· , zr .y}
equation ||| definition given in Section 3.4.
equation ||| •	mk bterm{n; op; ts} is meant to compute a bterm of binding
equation ||| depth n, with operator op, and with ts as its subterms. This op-
equation ||| eration is defined by induction on natural number n as follows:
equation ||| mk bterm{0; op; ts}:= mk term{op; ts}
equation ||| mk bterm{n + 1; op; ts}:=
equation ||| bnd{v.mk bterm{n; op; map Xt.subst{t; v} ts}}
bodyText ||| Note that, if ts is a list of bnd expressions (which is the intended
bodyText ||| usage of the mk bterm operation), then the
equation ||| bnd{v. · · · map Xt.subst{t; v} ts · · ·}
bodyText ||| has the effect of stripping the outer bnd from each of the mem-
bodyText ||| bers of the ts list and “moving” them into a single “merged” bnd
bodyText ||| on the outside.
bodyText ||| We also define a number of de Bruijn-style destructors, i.e., op-
bodyText ||| erations that compute various de Bruijn-style characteristics of a
bodyText ||| bterm. Since the var and mk bterm constructors are defined in terms
bodyText ||| of the HOAS constructors, the destructors have to be defined in
bodyText ||| terms of HOAS operations as well. Because of this, these defini-
bodyText ||| tions are often far from straightforward.
bodyText ||| It is important to emphasize that the tricky definitions that we
bodyText ||| use here are only needed to establish the basic properties of the
bodyText ||| operations we defined. Once the basic theory is complete, we can
bodyText ||| raise the level of abstraction and no usage of this theory will
bodyText ||| ever require using any of these definitions, being aware of these
bodyText ||| definitions, or performing similar tricks again.
listItem ||| •	bdepth{t} computes the binding depth of term t. It is defined
listItem ||| recursively using the Y combinator as
equation ||| rXb.matchb with
equation ||| Y	bnd{ } -+ 1 + f (subst{b; mk term{0; 0}})
equation ||| |mkterm{ ; }-+0
bodyText ||| In effect, this recursive function strips the outer binders from a
bodyText ||| bterm one by one using substitution (note that here we can use
bodyText ||| an arbitrary mk bterm expression as a second argument for the
bodyText ||| substitution function; the arguments to mk bterm do not have
bodyText ||| to have the “correct” type) and counts the number of times it
bodyText ||| needs to do this before the outermost mk bterm is exposed.
bodyText ||| We derive the following properties of bdepth:
equation ||| Vl, r E ICY. (bdepth {var{l; r}} ≡ (l +r + 1));
equation ||| Vn E ICY.(bdepth{mk bterm{n; op; ts}} ≡ n).
bodyText ||| Note that the latter equivalence only requires n to have the
bodyText ||| “correct” type, while op and ts may be arbitrary. Since the
bodyText ||| bdepth operator is needed for defining the type of Term of well-
bodyText ||| formed bterms, at this point we would not have been able to
bodyText ||| express what the “correct” type for ts would be.
bodyText ||| •	left{t} is designed to compute the “left index” of a var expres-
bodyText ||| sion. It is defined as
equation ||| 	�	�
equation ||| Xf.Xb.Xl.
equation ||| match b with	�
equation ||| 	Y	bnd{ } -+
equation ||| �1 + f (subst{b; mk term {l; 0}})(l + 1) � �
equation ||| |mk term{lf; ) -+ lf
bodyText ||| In effect, this recursive function substitutes mk term{0; 0}
bodyText ||| for the first binding of t, mk term{1; 0} for the second one,
bodyText ||| mk term{2; 0} for the next one and so forth. Once all the binders
bodyText ||| are stripped and a mk term{l; 0} is exposed, l is the index
bodyText ||| we were looking for. Note that here we intentionally supply
bodyText ||| mk term with an argument of a “wrong” type (ICY instead of
bodyText ||| Op); we could have avoided this, but then the definition would
bodyText ||| have been significantly more complicated.
bodyText ||| As expected, we derive that
equation ||| Vl, r E ICY.(left{var{l; r}} ≡ l).
listItem ||| •	right{t} computes the “right index” of a var expression. It
listItem ||| is trivial to define in terms of the previous two operators:
listItem ||| right{t}:= bdepth{t} − left{t} − 1.
listItem ||| •	get op{t; op} is an operation such that
equation ||| Vn E ICY.(get op{mk bterm{n; op; ts} ; opf) ≡ op),
equation ||| Vl, r E ICY. ((get op{var{i; j} ; op} ≡ op).
bodyText ||| Its definition is similar to that of left{}.
listItem ||| •	subterms{t} is designed to recover the last argument of a
listItem ||| mk bterm expression. The definition is rather technical and
listItem ||| complicated, so we omit it; see [NKYH05, Appendix C] for
listItem ||| details. The main property of the subterms operation that we
listItem ||| derive is
bodyText ||| Vn E ICY.Vbtl E List.(subterms{mk bterm{n; op; btl}} ≡
bodyText ||| map Xb.vbnd{n; v.vsubst{b; v}} btl)
bodyText ||| The right-hand side of this equivalence is not quite the plain
bodyText ||| “btl” that one might have hoped to see here. However, when
bodyText ||| btl is a list of bterms with binding depths at least n, which is
bodyText ||| necessarily the case for any well-formed mk bterm{n; op; btl},
bodyText ||| equivalence (8) would allow simplifying this right-hand side to
bodyText ||| the desired btl.
subsectionHeader ||| 4.5 Operators
bodyText ||| For this basic theory the exact representation details for operators
bodyText ||| are not essential and we define the type of operators Op abstractly.
bodyText ||| We only require that operators have decidable equality and that
bodyText ||| there exist a function of the type Op -+ ICY List that computes
bodyText ||| operators’ shapes.
bodyText ||| Using this shape function and the bdepth function from Sec-
bodyText ||| tion 4.4, it is trivial to formalize the “ts is compatible with op at
bodyText ||| depth n” predicate of Definition 4. We denote this predicate as
bodyText ||| shape compat{n; op; ts} and define it as
equation ||| |shape{op}| = |btl|A
equation ||| Vi E 1..|btl|.bdepth{nth{btl; i}} = n +nth{shape{op}; i}
subsectionHeader ||| 4.6 The Type of Terms
bodyText ||| In this section we will define the type of terms (i.e. well-formed
bodyText ||| bterms), Term, as the type of all terms that can be constructed by
bodyText ||| the de Bruijn constructors from Section 4.4. That is, the Term type
bodyText ||| contains all expressions of the forms:
listItem ||| •	var{i; j} for all natural numbers i, j; or
equation ||| )t
equation ||| t0
page ||| 8
listItem ||| • mk bterm{n; op; ts} for any natural number n, operator op, and
listItem ||| list of terms ts that is compatible with op at depth n.
bodyText ||| The Term type is defined as a fixpoint of the following function
bodyText ||| from types to types:
equation ||| Iter(X) := Image(dom(X); x.mk(x)),
bodyText ||| where
listItem ||| •	Image is a type constructor such that Image(T; x. f [xl) is the
listItem ||| type of all the f [tl for t e T (for it to be well-formed, T must
listItem ||| be a well-formed type and f must not have any free variables
listItem ||| except for x);
listItem ||| •	dom(X) is a type defined as
equation ||| (N×N)+(n:N× op:Op× {ts:X List I shape compat{n; op; ts}});
listItem ||| •	and mk(x) (where x is presumably a member of the type
listItem ||| dom(X)) is defined as
equation ||| matchx with
equation ||| inl (i, j) -+ var{i ; j}
equation ||| Iinr (n, op, ts) -+ mk bterm{n; op; ts} .
bodyText ||| The fixpoint of Iter is reached by defining
listItem ||| •	Term0 := Void (an empty type)
listItem ||| •	Termn+1 := Iter(Termn)
listItem ||| •	Term := U Termn
listItem ||| neN
bodyText ||| We derive the intended introduction rules for the Term type:
equation ||| i eN	j eN
equation ||| var{i ; j} e Term
equation ||| and
equation ||| n e N op e Op ts e TermList shape compat{n; op; ts}
equation ||| .
equation ||| mk bterm{n; op; ts} e Term
bodyText ||| Also, the structural induction principle is derived for the Term
bodyText ||| type. Namely, we show that to prove that some property P[tl holds
bodyText ||| for any term t, it is sufficient to prove
listItem ||| •	(Base case) P holds for all variables, that is, P[var{i ; j}l holds
listItem ||| for all natural numbers i and j;
listItem ||| •	(Induction step) P[mk bterm{n; op; ts}l is true for any natural
listItem ||| number n, any operator op, and any list of terms ts that is
listItem ||| compatible with op at depth n, provided P[tl is true for any
listItem ||| element t of the list ts.
bodyText ||| Note that the type of “terms over n variables” (where n = 0 cor-
bodyText ||| responds to closed terms) may be trivially defined using the Term
bodyText ||| type and the “subset” type constructor — {t : Term II bdepth{t} =
bodyText ||| n}.
sectionHeader ||| 5. Conclusions and Future Work
bodyText ||| In Sections 3 and 4 we have presented a basic theory of syntax
bodyText ||| that is fully implemented in a theorem prover. As we mentioned in
bodyText ||| the introduction, the approach is both natural and expressive, and
bodyText ||| provides a foundation for reflective reasoning about classes of lan-
bodyText ||| guages and logics. However, we consider this theory to be only
bodyText ||| the first step towards building a user-accessible uniform reflection
bodyText ||| framework and a user-accessible uniform framework for program-
bodyText ||| ming language reasoning and experimentation, where tasks similar
bodyText ||| to the ones presented in the POPLMARK challenge [ABF+05] can
bodyText ||| be performed easily and naturally. In this section we provide an out-
bodyText ||| line of our plans for building such frameworks on top of the basic
bodyText ||| syntactic theory.
subsectionHeader ||| 5.1 Higher-Level User Interface
bodyText ||| One obvious shortcoming of the theory presented in Sections 3
bodyText ||| and 4 is that it provides only the basic low-level operations such
bodyText ||| as bnd, var, subterms, etc. It presents a very low-level account of
bodyText ||| syntax in a way that would often fail to abstract away the details
bodyText ||| irrelevant to the user.
bodyText ||| To address this problem we are planning to provide user in-
bodyText ||| terface functionality capable of mapping the high-level concepts
bodyText ||| to the low-level ones. In particular, we are going to provide an
bodyText ||| interface that would allow instantiating general theorems to spe-
bodyText ||| cific collections of operators and specific languages. Thus, the user
bodyText ||| will be able to write something like “reflect language [Xx..;
bodyText ||| apply{.; .}] ” and the system will create all the components outlined
bodyText ||| in Example 1:
listItem ||| •	It will create a definition for the type
equation ||| Language[Xx..; apply{.; .}l
bodyText ||| of reflected lambda-terms (where Language[ll is a general def-
bodyText ||| inition of a language over a list of operators l);
listItem ||| •	It will state and derive the introduction rules for this type;
listItem ||| •	It will state and derive the elimination rule for this type (the
listItem ||| induction principle).
bodyText ||| Moreover, we are planning to support even more complicated lan-
bodyText ||| guage declarations, such as
equation ||| t := int I t -+ t; e := v I Xx : t.e[xl I apply{e; e}
bodyText ||| that would cause the system to create mutually recursive type
bodyText ||| definitions and appropriate rules.
bodyText ||| Finally, we are also planning to support “pattern bindings” that
bodyText ||| are needed for a natural encoding of ML-like pattern matching
bodyText ||| (such as the one sketched in the POPLMARK challenge [ABF+05]).
bodyText ||| As far as the underlying theory goes, we believe that the mecha-
bodyText ||| nisms very similar to the “vector bindings” presented in Section 4.3
bodyText ||| will be sufficient here.
subsectionHeader ||| 5.2 “Dereferencing” Quoted Terms
bodyText ||| As in Barzilay’s work, the quoted operator approach makes it easy
bodyText ||| to define the “unquoting” (or “dereferencing”) operator [lunq. If t
bodyText ||| is a syntactic term, then [tllunq is the value represented by t. By
bodyText ||| definition,
equation ||| [op{t1; ... ; tn}lunq = op{[t1lunq; ... ; [tnllunq}.
equation ||| For instance, [2 * 3lunq is 2 * 3 (i.e. 6).
bodyText ||| In order to define unquoting on terms with bindings, we need to
bodyText ||| introduce the “guard” operation hp pi such that [bt)llunq is t for an
bodyText ||| arbitrary expression t. Then [lunq can be defined as follows:
equation ||| [op{x1, ..., xk.t[x1; ... ; xkl; ... ;z1, ..., zl.s[z1; ... ; zll}lunq =
equation ||| op{x1, . . . ,xk.[[t[(ix1 ; ... ; Ixk�llunq;
equation ||| . . .	;
equation ||| z1, . . . , zl.[s[(z1�� ; ... ; (1zl�llunq}.
equation ||| For example, [[Xx.2*xlunq = Xx.[2*��x�llunq = Xx.[2lunq *
equation ||| [bx)lunq =Xx.2 * x.
bodyText ||| The unquote operation establishes the identity between the orig-
bodyText ||| inal syntax and the reflected syntax, making it a “true” reflection.
bodyText ||| Note that the type theory (which ensures, in particular, that
bodyText ||| only terminating functions may be shown to belong to a function
bodyText ||| type) would keep the [ llunq operation from introducing logical
bodyText ||| paradoxes.3
footnote ||| 3 This is, obviously, not a proper argument. While a proper argument can be
footnote ||| made here, it is outside of the scope of this particular paper.
page ||| 9
bodyText ||| Also, since the notion of the quoted operators is fully open-
bodyText ||| ended, each new language added to the system will automatically
bodyText ||| get to use the Q lunq operation for all its newly introduced opera-
bodyText ||| tors.
subsectionHeader ||| 5.3 Logical Reflection
bodyText ||| After defining syntactic reflection, it is easy to define logical reflec-
bodyText ||| tion. If we consider the proof system open-ended, then the logical
bodyText ||| reflection is trivial — when P is a quotation of a proposition, we
bodyText ||| can regard “QPlunq” as meaning “P is true”. The normal modal
bodyText ||| rules for the Qlunq modality are trivially derivable. For example
bodyText ||| modus ponens
equation ||| QP  =:�  Qlunq =:� QPlunq =:� QQQlunq
bodyText ||| is trivially true because if we evaluate the first Qllunq (remember,
equation ||| QP =:� Qlunq = (QPlunq =:� QQlunq)
bodyText ||| by definition of Qlunq), we get an obvious tautology
bodyText ||| (QPlunq =:� QQQlunq) =:� QPlunq =:� QQlunq.
bodyText ||| In order to consider a closed proof system (in other words, if
bodyText ||| we want to be able to do induction over derivations), we would
bodyText ||| need to define a provability predicate for that system. We are
bodyText ||| planning to provide user interface functionality that would allow
bodyText ||| users to describe a set of proof rules and the system would generate
bodyText ||| appropriate proof predicate definitions and derive appropriate rules
bodyText ||| (in a style similar to the one outlined in Section 5.1 for the case of
bodyText ||| language descriptions).
sectionHeader ||| 6. Related Work
bodyText ||| In Section 2 we have already discussed a number of approaches
bodyText ||| that we consider ourselves inheriting from. Here we would like to
bodyText ||| revisit some of them and mention a few other related efforts.
bodyText ||| Our work has a lot in common with the HOAS implemented in
bodyText ||| Coq by Despeyroux and Hirschowitz [DH94]. In both cases, the
bodyText ||| more general space of terms (that include the exotic ones) is later
bodyText ||| restricted in a recursive manner. In both cases, the higher-order
bodyText ||| analogs of first-order de Bruijn operators are defined and used as a
bodyText ||| part of the “well-formedness” specification for the terms. Despey-
bodyText ||| roux and Hirschowitz use functions over infinite lists of variables
bodyText ||| to define open terms, which is similar to our vector bindings.
bodyText ||| There are a number of significant differences as well. Our ap-
bodyText ||| proach is sufficiently syntactical, which allows eliminating all ex-
bodyText ||| otic terms, even those that are extensionally equal to the well-
bodyText ||| formed ones, while the more semantic approach of [DH94,
bodyText ||| DFH95] has to accept such exotic terms (their solution to this prob-
bodyText ||| lem is to consider an object term to be represented by the whole
bodyText ||| equivalence class of extensionally equal terms); more generally
bodyText ||| while [DH94] states that “this problem of extensionality is recur-
bodyText ||| rent all over our work”, most of our lemmas establish identity and
bodyText ||| not just equality, thus avoiding most of the issues of extensional
bodyText ||| equality. In our implementation, the substitution on object terms is
bodyText ||| mapped directly to P-reduction, while Despeyroux et al. [DFH95]
bodyText ||| have to define it recursively. In addition, we provide a uniform ap-
bodyText ||| proach to both free and bound variables that naturally extends to
bodyText ||| variable-length “vector” bindings.
bodyText ||| While our approach is quite different from the modal X-calculus
bodyText ||| one [DPS97, DL99, DL01], there are some similarities in the in-
bodyText ||| tuition behind it. Despeyroux et al. [DPS97] says “Intuitively, we
bodyText ||| interpret ❑B as the type of closed objects of type B. We can iter-
bodyText ||| ate or distinguish cases over closed objects, since all constructors
bodyText ||| are statically known and can be provided for.” The intuition be-
bodyText ||| hind our approach is in part based on the canonical model of the
bodyText ||| NuPRL type theory [All87a, All87b], where each type is mapped
bodyText ||| to an equivalence relations over the closed terms of that type.
bodyText ||| Gordon and Melham [GM96] define the type of X-terms as a
bodyText ||| quotient of the type of terms with concrete binding variables over
bodyText ||| a-equivalence. Michael Norrish [Nor04] builds upon this work by
bodyText ||| replacing certain variable “freshness” requirements with variable
bodyText ||| “swapping”. This approach has a number of attractive properties;
bodyText ||| however, we believe that the level of abstraction provided by the
bodyText ||| HOAS-style approaches makes the HOAS style more convenient
bodyText ||| and accessible.
bodyText ||| Ambler, Crole, and Momigliano [ACM02] have combined the
bodyText ||| HOAS with the induction principle using an approach which in
bodyText ||| some sense is opposite to ours. Namely, they define the HOAS
bodyText ||| operators on top of the de Bruijn definition of terms using higher
bodyText ||| order pattern matching. In a later work [ACM03] they have de-
bodyText ||| scribed the notion of “terms-in-infinite-context” which is quite sim-
bodyText ||| ilar to our approach to vector binding. While our vector bindings
bodyText ||| presented in Section 4.3 are finite length, the exact same approach
bodyText ||| would work for the infinite-length “vectors” as well.
sectionHeader ||| Acknowledgments
bodyText ||| The authors are grateful to Eli Barzilay whose ideas were an in-
bodyText ||| spiration for some of the work that lead to this paper. We are also
bodyText ||| grateful for his comments on an early draft of this paper.
bodyText ||| We are grateful to the anonymous reviewers for their very thor-
bodyText ||| ough and fair feedback and many helpful suggestions.
sectionHeader ||| References
reference ||| [AA99] Eric Aaron and Stuart Allen. Justifying calculational logic
reference ||| by a conventional metalinguistic semantics. Technical Report
reference ||| TR99-1771, Cornell University, Ithaca, New York, September
reference ||| 1999.
reference ||| [ABF+05] Brian E. Aydemir, Aaron Bohannon, Matthew Fairbairn,
reference ||| J. Nathan Foster, Benjamin C. Pierce, Peter Sewell, Dimitrios
reference ||| Vytiniotis, Geoffrey Washburn, Stephanie Weirich, and Steve
reference ||| Zdancewic. Mechanized metatheory for the masses: The
reference ||| POPLmark challenge. Available fromhttp://www.cis.
reference ||| upenn.edu/group/proj/plclub/mmm/,2005.
reference ||| [AC92] William Aitken and Robert L. Constable. Reflecting on
reference ||| NuPRL : Lessons 1–4. Technical report, Cornell University,
reference ||| Computer Science Department, Ithaca, NY, 1992.
reference ||| [ACE+00] Stuart Allen, Robert Constable, Richard Eaton, Christoph
reference ||| Kreitz, and Lori Lorigo. The NuPRL open logical envi-
reference ||| ronment. In David McAllester, editor, Proceedings of the
reference ||| 17th International Conference on Automated Deduction, vol-
reference ||| ume 1831 of Lecture Notes in Artificial Intelligence, pages
reference ||| 170–176. Springer Verlag, 2000.
reference ||| [ACHA90] Stuart F. Allen, Robert L. Constable, Douglas J. Howe,
reference ||| and William Aitken. The semantics of reflected proof. In
reference ||| Proceedings of the 5th Symposium on Logic in Computer
reference ||| Science, pages 95–197. IEEE Computer Society Press, June
reference ||| 1990.
reference ||| [ACM02] Simon Ambler, Roy L. Crole, and Alberto Momigliano.
reference ||| Combining higher order abstract syntax with tactical theorem
reference ||| proving and (co)induction. In TPHOLs ’02: Proceedings
reference ||| of the 15th International Conference on Theorem Proving
reference ||| in Higher Order Logics, pages 13–30, London, UK, 2002.
reference ||| Springer-Verlag.
reference ||| [ACM03] S. J. Ambler, R. L. Crole, and Alberto Momigliano. A
reference ||| definitional approach to primitive recursion over higher
reference ||| order abstract syntax. In Proceedings of the 2003 workshop
reference ||| on Mechanized reasoning about languages with variable
reference ||| binding, pages 1–11. ACM Press, 2003.
reference ||| [ACU93] William Aitken, Robert L. Constable, and Judith Underwood.
reference ||| Metalogical Frameworks II: Using reflected decision pro-
reference ||| cedures.Journal of Automated Reasoning, 22(2):171–221,
reference ||| 1993.
page ||| 10
reference ||| [All87a]	Stuart F. Allen. A Non-type-theoretic Definition of Martin-
reference ||| L¨of’s Types. In D. Gries, editor, Proceedings ofthe 2nd IEEE
reference ||| Symposium on Logic in Computer Science, pages 215–224.
reference ||| IEEE Computer Society Press, June 1987.
reference ||| [All87b]	Stuart F. Allen. A Non-Type-Theoretic Semantics for Type-
reference ||| Theoretic Language. PhD thesis, Cornell University, 1987.
reference ||| [Art99]	Sergei Artemov. On explicit reflection in theorem proving
reference ||| and formal verification. In Ganzinger [Gan99], pages 267–
reference ||| 281.
reference ||| [Art04]	Sergei Artemov. Evidence-based common knowledge.
reference ||| Technical Report TR-2004018, CUNY Ph.D. Program in
reference ||| Computer Science Technical Reports, November 2004.
reference ||| [BA02]	Eli Barzilay and Stuart Allen. Reflecting higher-order abstract
reference ||| syntax in NuPRL. In Victor A. Carre˜no, C´ezar A. Mu˜noz,
reference ||| and Sophi`ene Tahar, editors, Theorem Proving in Higher
reference ||| Order Logics; Track B Proceedings of the 15th International
reference ||| Conference on Theorem Proving in Higher Order Logics
reference ||| (TPHOLs 2002), Hampton, VA, August 2002, pages 23–32.
reference ||| National Aeronautics and Space Administration, 2002.
reference ||| [BAC03]	Eli Barzilay, Stuart Allen, and Robert Constable. Practical
reference ||| reflection in NuPRL. Short paper presented at 18th Annual
reference ||| IEEE Symposium on Logic in Computer Science, June 22–
reference ||| 25, Ottawa, Canada, 2003.
reference ||| [Bar01]	Eli Barzilay. Quotation and reflection in NuPRL and Scheme.
reference ||| Technical Report TR2001-1832, Cornell University, Ithaca,
reference ||| New York, January 2001.
reference ||| [Bar05]	Eli Barzilay. Implementing Reflection in NuPRL. PhD thesis,
reference ||| Cornell University, 2005. In preparation.
reference ||| [CAB+86] Robert L. Constable, Stuart F. Allen, H. M. Bromley, W. R.
reference ||| Cleaveland, J. F. Cremer, R. W. Harper, Douglas J. Howe,
reference ||| T. B. Knoblock, N. P. Mendler, P. Panangaden, James T.
reference ||| Sasaki, and Scott F. Smith. Implementing Mathematics with
reference ||| the NuPRL ProofDevelopment System. Prentice-Hall, NJ,
reference ||| 1986.
reference ||| [CFW04]	Luis Crus-Filipe and Freek Weidijk. Hierarchical reflection.
reference ||| In Slind et al. [SBG04], pages 66–81.
reference ||| [Con94]	Robert L. Constable. Using reflection to explain and enhance
reference ||| type theory. In Helmut Schwichtenberg, editor, Proof and
reference ||| Computation, volume 139 of NATO Advanced Study Insti-
reference ||| tute, International Summer School held in Marktoberdorf,
reference ||| Germany, July 20-August 1, NATO Series F, pages 65–100.
reference ||| Springer, Berlin, 1994.
reference ||| [dB72]	N. G. de Bruijn. Lambda calculus notation with nameless
reference ||| dummies, a tool for automatic formula manipulation, with
reference ||| application to the Church-Rosser theorem. Indagaciones
reference ||| Mathematische, 34:381–392, 1972. This also appeared in the
reference ||| Proceedings of the Koninklijke Nederlandse Akademie van
reference ||| Wetenschappen, Amsterdam, series A, 75, No. 5.
reference ||| [DFH95]	Jo¨elle Despeyroux, Amy Felty, and Andr´e Hirschowitz.
reference ||| Higher-order abstract syntax in Coq. In M. Dezani-
reference ||| Ciancaglini and G. Plotkin, editors, Proceedings of the
reference ||| International Conference on Typed Lambda Calculus and
reference ||| its Applications, volume 902 of Lecture Notes in Computer
reference ||| Science, pages 124–138. Springer-Verlag, April 1995. Also
reference ||| appears as INRIA research report RR-2556.
reference ||| [DH94]	Jo¨elle Despeyroux and Andr´e Hirschowitz. Higher-order
reference ||| abstract syntax with induction in Coq. In LPAR ’94:
reference ||| Proceedings of the 5th International Conference on Logic
reference ||| Programming and Automated Reasoning, volume 822
reference ||| of Lecture Notes in Computer Science, pages 159–173.
reference ||| Springer-Verlag, 1994. Also appears as INRIA research
reference ||| report RR-2292.
reference ||| [DH95]	James Davis and Daniel Huttenlocher. Shared annotations for
reference ||| cooperative learning. In Proceedings of the ACM Conference
reference ||| on Computer Supported Cooperative Learning, September
reference ||| 1995.
reference ||| [DL99]	Jo¨elle Despeyroux and Pierre Leleu. A modal lambda
reference ||| calculus with iteration and case constructs. In T. Altenkirch,
reference ||| W. Naraschewski, and B. Reus, editors, Types for Proofs
reference ||| and Programs: International Workshop, TYPES ’98, Kloster
reference ||| Irsee, Germany, March 1998, volume 1657 of Lecture Notes
reference ||| in Computer Science, pages 47–61, 1999.
reference ||| [DL01]	Jo¨elle Despeyroux and Pierre Leleu. Recursion over objects
reference ||| of functional type. Mathematical Structures in Computer
reference ||| Science, 11(4):555–572, 2001.
reference ||| [DPS97]	Jo¨elle Despeyroux, Frank Pfenning, and Carsten Sch¨urmann.
reference ||| Primitive recursion for higher–order abstract syntax. In
reference ||| R. Hindley, editor, Proceedings of the Third International
reference ||| Conference on Typed Lambda Calculus and Applications
reference ||| (TLCA’97), volume 1210 of Lecture Notes in Computer
reference ||| Science, pages 147–163. Springer-Verlag, April 1997. An
reference ||| extended version is available as Technical Report CMU-CS-
reference ||| 96-172, Carnegie Mellon University.
reference ||| [EM71]	Andrzej Ehrenfeucht and Jan Mycielski. Abbreviating
reference ||| proofs by adding new axioms. Bulletin of the American
reference ||| Mathematical Society, 77:366–367, 1971.
reference ||| [F+86]	Solomon Feferman et al., editors. Kurt G¨odel Collected
reference ||| Works, volume 1. Oxford University Press, Oxford,
reference ||| Clarendon Press, New York, 1986.
reference ||| [FPT99]	Marcelo Fiore, Gordon Plotkin, and Daniele Turi. Abstract
reference ||| syntax and variable binding. In Proceedings of 14th IEEE
reference ||| Symposium on Logic in Computer Science, pages 193+. IEEE
reference ||| Computer Society Press, 1999.
reference ||| [Gan99]	Harald Ganzinger, editor. Proceedings of the 16th Interna-
reference ||| tional Conference on Automated Deduction, volume 1632
reference ||| of Lecture Notes in Artificial Intelligence, Berlin, July 7–10
reference ||| 1999. Trento, Italy.
reference ||| [GM96]	A. D. Gordon and T. Melham. Five axioms of alpha-
reference ||| conversion. In J. von Wright, J. Grundy, and J. Harrison,
reference ||| editors, Theorem Proving in Higher Order Logics: 9th
reference ||| International Conference, Turku, Finland, August 1996:
reference ||| Proceedings, volume 1125 of Lecture Notes in Computer
reference ||| Science, pages 173–190. Springer-Verlag, 1996.
reference ||| [GMO03] Jim Grundy, Tom Melham, and John O’Leary. A reflective
reference ||| functional language for hardware design and theorem
reference ||| proving. Technical Report PRG-RR-03-16, Oxford Univerity,
reference ||| Computing Laboratory, 2003.
reference ||| [G¨od31 ]	Kurt G¨odel. ¨Uber formal unentscheidbare s¨atze der principia
reference ||| mathematica und verwandter systeme I. Monatshefte f¨ur
reference ||| Mathematik und Physik, 38:173–198, 1931. English version
reference ||| in [vH67].
reference ||| [G¨od36]	K. G¨odel. ¨Uber die L¨ange von beweisen. Ergebnisse
reference ||| eines mathematischen Kolloquiums, 7:23–24, 1936. English
reference ||| translation in [F+86], pages 397–399.
reference ||| [GS89]	F. Giunchiglia and A. Smaill. Reflection in constructive
reference ||| and non-constructive automated reasoning. In H. Abramson
reference ||| and M. H. Rogers, editors, Meta-Programming in Logic
reference ||| Programming, pages 123–140. MIT Press, Cambridge,
reference ||| Mass., 1989.
reference ||| [GWZ00] H. Geuvers, F. Wiedijk, and J. Zwanenburg. Equational rea-
reference ||| soning via partial reflection. In J. Harrison and M. Aagaard,
reference ||| editors, Theorem Proving in Higher Order Logics: 13th Inter-
reference ||| national Conference, TPHOLs 2000, volume 1869 of Lecture
reference ||| Notes in Computer Science, pages 162–178. Springer-Verlag,
reference ||| 2000.
reference ||| [HAB+]	Jason J. Hickey, Brian Aydemir, Yegor Bryukhov, Alexei
reference ||| Kopylov, Aleksey Nogin, and Xin Yu. A listing of Meta PRL
reference ||| theories. http://metaprl.org/theories.pdf.
reference ||| [Har95]	J. Harrison. Metatheory and reflection in theorem proving:
reference ||| A survey and critique. Technical Report CRC-53, SRI
reference ||| International, Cambridge Computer Science Research
reference ||| Centre, Millers Yard, Cambridge, UK, February 1995.
page ||| 11
reference ||| [HHP93]	Robert Harper, Furio Honsell, and Gordon Plotkin. A
reference ||| framework for defining logics. Journal of the Association
reference ||| for Computing Machinery, 40(1):143–184, January 1993. A
reference ||| revised and expanded verion of ’87 paper.
reference ||| [Hic97]	Jason J. Hickey. NuPRL-Light: An implementation
reference ||| framework for higher-order logics. In William McCune,
reference ||| editor, Proceedings of the 14th International Conference
reference ||| on Automated Deduction, volume 1249 of Lecture Notes in
reference ||| Artificial Intelligence, pages 395–399. Springer, July 13–17
reference ||| 1997. An extended version of the paper can be found at
reference ||| http://www.cs.caltech.edu/~jyh/papers/cade14_
reference ||| nl/default.html.
reference ||| [Hic99]	Jason J. Hickey. Fault-tolerant distributed theorem proving.
reference ||| In Ganzinger [Gan99], pages 227–231.
reference ||| [Hic01]	Jason J. Hickey. The MetaPRL Logical Programming
reference ||| Environment. PhD thesis, Cornell University, Ithaca, NY,
reference ||| January 2001.
reference ||| [HL78]	G´erard P. Huet and Bernard Lang. Proving and applying
reference ||| program transformations expressed with second-order
reference ||| patterns. Acta Informatica, 11:31–55,1978.
reference ||| [HNC+03] Jason Hickey, Aleksey Nogin, Robert L. Constable,
reference ||| Brian E. Aydemir, Eli Barzilay, Yegor Bryukhov, Richard
reference ||| Eaton, Adam Granicz, Alexei Kopylov, Christoph Kreitz,
reference ||| Vladimir N. Krupski, Lori Lorigo, Stephan Schmitt, Carl
reference ||| Witty, and Xin Yu. MetaPRL — A modular logical en-
reference ||| vironment. In David Basin and Burkhart Wolff, editors,
reference ||| Proceedings of the 16th International Conference on Theo-
reference ||| rem Proving in Higher OrderLogics (TPHOLs 2003), volume
reference ||| 2758 of Lecture Notes in Computer Science, pages 287–303.
reference ||| Springer-Verlag, 2003.
reference ||| [HNK+]	Jason J. Hickey, Aleksey Nogin, Alexei Kopylov, et al.
reference ||| MetaPRL home page. http://metaprl.org/.
reference ||| [Mos52]	Andrzej Mostowski. Sentences undecidable in formalized
reference ||| arithmetic: an exposition of the theory of Kurt G¨odel.
reference ||| Amsterdam: North-Holland, 1952.
reference ||| [NH02]	Aleksey Nogin and Jason Hickey. Sequent schema for
reference ||| derived rules. In Victor A. Carre˜no, C´ezar A. Mu˜noz,
reference ||| and Sophi`ene Tahar, editors, Proceedings of the 15th
reference ||| International Conference on Theorem Proving in Higher
reference ||| Order Logics (TPHOLs 2002), volume 2410 of Lecture Notes
reference ||| in Computer Science, pages 281–297. Springer-Verlag, 2002.
reference ||| [NKYH05] Aleksey Nogin, Alexei Kopylov, Xin Yu, and Jason Hickey.
reference ||| A computational approach to reflective meta-reasoning
reference ||| about languages with bindings. Technical Report Cal-
reference ||| techCSTR:2005.003, California Institure of Technology,
reference ||| 2005. Available at http://resolver.caltech.edu/
reference ||| CaltechCSTR:2005.003.
reference ||| [Nor04]	Michael Norrish. Recursive function definition for types with
reference ||| binders. In Slind et al. [SBG04], pages 241–256.
reference ||| [Par71]	R. Parikh. Existence and feasibility in arithmetic. The Journal
reference ||| ofSymbolic Logic, 36:494–508,1971.
reference ||| [Pau94]	Lawrence C. Paulson. Isabelle: A Generic Theorem Prover,
reference ||| volume 828 of Lecture Notes in Computer Science. Springer-
reference ||| Verlag, New York, 1994.
reference ||| [PE88]	Frank Pfenning and Conal Elliott. Higher-order abstract
reference ||| syntax. In Proceedings oftheACMSIGPLAN’88 Conference
reference ||| on Programming Language Design and Implementation
reference ||| (PLDI), volume 23(7) of SIGPLANNotices, pages 199–208,
reference ||| Atlanta, Georgia, June 1988. ACM Press.
reference ||| [Pfe89]	Frank Pfenning. Elf: a language for logic definition and
reference ||| verified metaprogramming. In Proceedings of the 4th IEEE
reference ||| Symposium on Logic in Computer Science, pages 313–322,
reference ||| Asilomar Conference Center, Pacific Grove, California, June
reference ||| 1989. IEEE Computer Society Press.
reference ||| [Plo90]	Gordon Plotkin. An illative theory of relations. In R. Cooper,
reference ||| K. Mukai, and J. Perry, editors, Situation Theory and Its
reference ||| Applications, Volume 1, number 22 in CSLI Lecture Notes,
reference ||| pages 133–146. Centre for the Study of Language and
reference ||| Information, 1990.
reference ||| [PN90]	L. Paulson and T. Nipkow. Isabelle tutorial and user’s man-
reference ||| ual. Technical report, University of Cambridge Computing
reference ||| Laboratory, 1990.
reference ||| [SBG04]	Konrad Slind, Annette Bunker, and Ganesh Gopalakrishnan,
reference ||| editors. Proceedings of the 17th International Conference
reference ||| on Theorem Proving in Higher Order Logics (TPHOLs
reference ||| 2004), volume 3223 of Lecture Notes in Computer Science.
reference ||| Springer-Verlag, 2004.
reference ||| [Sch01]	Carsten Sch¨urmann. Recursion for higher-order encodings.
reference ||| In L. Fribourg, editor, Computer Science Logic, Proceedings
reference ||| of the 10th Annual Conference of the EACSL, volume 2142
reference ||| of Lecture Notes in Computer Science, pages 585–599.
reference ||| Springer-Verlag, 2001.
reference ||| [Smi84]	B.C. Smith. Reflection and semantics in Lisp. Principles of
reference ||| Programming Languages, pages 23–35, 1984.
reference ||| [vH67]	J. van Heijenoort, editor. From Frege to G¨odel: A Source
reference ||| Book in Mathematical Logic, 1879–1931. Harvard University
reference ||| Press, Cambridge, MA, 1967.
page ||| 12
