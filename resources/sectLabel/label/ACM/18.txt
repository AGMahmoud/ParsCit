title ||| A Resilient Packet-Forwarding Scheme against Maliciously
title ||| Packet-Dropping Nodes in Sensor Networks
author ||| Suk-Bok Lee and Yoon-Hwa Choi
affiliation ||| Department of Computer Engineering
affiliation ||| Hongik University
address ||| 121-791 Seoul, Korea
email ||| {sblee, yhchoi}@cs.hongik.ac.kr
sectionHeader ||| ABSTRACT
bodyText ||| This paper focuses on defending against compromised nodes’
bodyText ||| dropping of legitimate reports and investigates the misbe-
bodyText ||| havior of a maliciously packet-dropping node in sensor net-
bodyText ||| works. We present a resilient packet-forwarding scheme us-
bodyText ||| ing Neighbor Watch System (NWS), specifically designed
bodyText ||| for hop-by-hop reliable delivery in face of malicious nodes
bodyText ||| that drop relaying packets, as well as faulty nodes that
bodyText ||| fail to relay packets. Unlike previous work with multipath
bodyText ||| data forwarding, our scheme basically employs single-path
bodyText ||| data forwarding, which consumes less power than multipath
bodyText ||| schemes. As the packet is forwarded along the single-path
bodyText ||| toward the base station, our scheme, however, converts into
bodyText ||| multipath data forwarding at the location where NWS de-
bodyText ||| tects relaying nodes’ misbehavior. Simulation experiments
bodyText ||| show that, with the help of NWS, our forwarding scheme
bodyText ||| achieves a high success ratio in face of a large number of
bodyText ||| packet-dropping nodes, and effectively adjusts its forwarding
bodyText ||| style, depending on the number of packet-dropping nodes
bodyText ||| en-route to the base station.
sectionHeader ||| Categories and Subject Descriptors
category ||| C.2.0 [Computer-Communication Networks]: General—
category ||| Security and protection
sectionHeader ||| General Terms
keyword ||| Security, Algorithm, Reliability
sectionHeader ||| Keywords
keyword ||| Sensor Network Security, Reliable Delivery, Packet-dropping
keyword ||| Attacks, Secure Routing
sectionHeader ||| 1. INTRODUCTION
bodyText ||| Wireless sensor networks consist of hundreds or even thou-
bodyText ||| sands of small devices each with sensing, processing, and
copyright ||| Permission to make digital or hard copies of all or part of this work for
copyright ||| personal or classroom use is granted without fee provided that copies are
copyright ||| not made or distributed for profit or commercial advantage and that copies
copyright ||| bear this notice and the full citation on the first page. To copy otherwise, to
copyright ||| republish, to post on servers or to redistribute to lists, requires prior specific
copyright ||| permission and/or a fee.
note ||| SASN’06, October 30, 2006, Alexandria, Virginia, USA.
copyright ||| Copyright 2006 ACM 1-59593-554-1/06/0010 ...$5.00.
bodyText ||| communicating capabilities to monitor the real-world envi-
bodyText ||| ronment. They are envisioned to play an important role
bodyText ||| in a wide variety of areas ranging from critical military-
bodyText ||| surveillance applications to forest fire monitoring and the
bodyText ||| building security monitoring in the near future. In such a
bodyText ||| network, a large number of sensor nodes are distributed to
bodyText ||| monitor a vast field where the operational conditions are
bodyText ||| harsh or even hostile. To operate in such environments, se-
bodyText ||| curity is an important aspect for sensor networks and secu-
bodyText ||| rity mechanisms should be provided against various attacks
bodyText ||| such as node capture, physical tampering, eavesdropping,
bodyText ||| denial of service, etc [23, 33, 38].
bodyText ||| Previous research efforts against outsider attacks in key-
bodyText ||| management schemes [4, 13, 32] and secure node-to-node
bodyText ||| communication mechanisms [24, 32] in sensor networks are
bodyText ||| well-defined. Those security protections, however, break
bodyText ||| down when even a single legitimate node is compromised.
bodyText ||| It turns out to be relatively easy to compromise a legiti-
bodyText ||| mate node [14], which is to extract all the security infor-
bodyText ||| mation from the captured node and to make malicious code
bodyText ||| running for the attacker’s purpose.
bodyText ||| Even a small number of compromised nodes can pose
bodyText ||| severe security threats on the entire part of the network,
bodyText ||| launching several attacks such as dropping legitimate re-
bodyText ||| ports, injecting bogus sensing reports, advertising inconsis-
bodyText ||| tent routing information, eavesdropping in-network commu-
bodyText ||| nication using exposed keys, etc. Such disruption by the
bodyText ||| insider attacks can be devastating unless proper security
bodyText ||| countermeasures against each type of attacks are provided.
bodyText ||| In reality, detecting all of the compromised nodes in the
bodyText ||| network is not always possible, so we should pursue grace-
bodyText ||| ful degradation [35], with a small number of compromised
bodyText ||| nodes. The fundamental principle for defense against the
bodyText ||| insider attacks is to restrict the security impact of a node
bodyText ||| compromise as close to the vicinity of the compromised node
bodyText ||| as possible.
bodyText ||| When the attacker compromises a legitimate node, it may
bodyText ||| first try to replicate the captured node indefinitely with the
bodyText ||| same ID and spread them over the network. Against such
bodyText ||| attacks, a distributed detection mechanism (based on emer-
bodyText ||| gent properties [11]) has been proposed by Parno et al. [31].
bodyText ||| In addition, Newsome et al. [30] have presented the tech-
bodyText ||| niques that prevent the adversary from arbitrarily creating
bodyText ||| new IDs for nodes.
bodyText ||| Using cryptographic information obtained from a cap-
bodyText ||| tured node, attackers can establish pairwise keys with any
bodyText ||| legitimate nodes in order to eavesdrop communication any-
page ||| 59
bodyText ||| where in the network. Localized key-establishment scheme
bodyText ||| by Zhu et al. [46] is a good solution against such an in-
bodyText ||| sider attack. Since the scheme does not allow a cloned node
bodyText ||| (by inside-attackers) to establish pairwise keys with any le-
bodyText ||| gitimate nodes except the neighbors of the compromised
bodyText ||| nodes, the cryptographic keys extracted from the compro-
bodyText ||| mised node are of no use for attackers.
bodyText ||| Compromised nodes can also inject false sensing reports
bodyText ||| to the network (i.e. report fabrication attacks [39]), which
bodyText ||| causes false alarms at the base station or the aggregation
bodyText ||| result to far deviate from the true measurement. Proposed
bodyText ||| en-route filtering mechanisms [8, 39, 41, 44, 47] that de-
bodyText ||| tect and drop such false reports effectively limit the impact
bodyText ||| of this type of attacks. Also, proposed secure aggregation
bodyText ||| protocols [34, 40] have addressed the problem of false data
bodyText ||| injection, and they ensure that the aggregated result is a
bodyText ||| good approximation to the true value in the presence of a
bodyText ||| small number of compromised nodes.
bodyText ||| Advertising inconsistent routing information by compro-
bodyText ||| mised nodes can disrupt the whole network topology. Hu et
bodyText ||| al. [19, 20] have proposed SEAD, a secure ad-hoc network
bodyText ||| routing protocol that uses efficient one-way hash functions
bodyText ||| to prevent any inside attackers from injecting inconsistent
bodyText ||| route updates. A few secure routing protocols [6, 27] in sen-
bodyText ||| sor networks have been proposed to detect and exclude the
bodyText ||| compromised nodes injecting inconsistent route updates.
bodyText ||| Compromised nodes also can silently drop legitimate re-
bodyText ||| ports (i.e. selective forwarding attacks [23]), instead of for-
bodyText ||| warding them to the next-hop toward the base station. Since
bodyText ||| data reports are delivered over multihop wireless paths to
bodyText ||| the base station, even a small number of strategically-placed
bodyText ||| packet-dropping nodes can deteriorate the network through-
bodyText ||| put significantly. In order to bypass such nodes, most work
bodyText ||| on secure routing and reliable delivery in sensor networks re-
bodyText ||| lies on multipath forwarding scheme [5, 6, 7, 10], or interleaved-
bodyText ||| mesh forwarding scheme [26, 29, 39, 42].
bodyText ||| Among the insider attacks described above, this paper fo-
bodyText ||| cuses on defense against compromised nodes’ dropping of le-
bodyText ||| gitimate reports and we present a resilient packet-forwarding
bodyText ||| scheme using Neighbor Watch System (NWS) against ma-
bodyText ||| liciously packet-dropping nodes in sensor networks. We in-
bodyText ||| vestigate the misbehavior of a maliciously packet-dropping
bodyText ||| node and show that an acknowledgement (ACK) that its
bodyText ||| packets were correctly received at the next-hop node does
bodyText ||| not guarantee reliable delivery from the security perspective.
bodyText ||| NWS is specifically designed for hop-by-hop reliable de-
bodyText ||| livery in face of malicious nodes that drop relaying packets,
bodyText ||| as well as faulty nodes that fail to relay packets. Unlike pre-
bodyText ||| vious work [10, 29, 42] with multipath data forwarding, our
bodyText ||| scheme basically employs single-path data forwarding, which
bodyText ||| consumes less power than multipath schemes. As the packet
bodyText ||| is forwarded along the single-path toward the base station,
bodyText ||| our scheme, however, converts into multipath data forward-
bodyText ||| ing at the location where NWS detects relaying nodes’ mis-
bodyText ||| behavior.
bodyText ||| NWS exploits the dense deployment of large-scale static
bodyText ||| sensor networks and the broadcast nature of communication
bodyText ||| pattern to overhear neighbors’ communication for free.
bodyText ||| The contribution of this paper is two-fold. First, we in-
bodyText ||| vestigate the misbehavior of a maliciously packet-dropping
bodyText ||| node and propose a resilient packet-forwarding scheme, which
bodyText ||| basically employs single-path data forwarding, in face of
bodyText ||| such nodes, as well as faulty nodes. Second, our scheme
bodyText ||| can work with any existing routing protocols. Since it is
bodyText ||| designed not for securing specific protocols but for universal
bodyText ||| protocols, it can be applied to any existing routing protocols
bodyText ||| as a security complement.
bodyText ||| The rest of paper is organized as follows. Background is
bodyText ||| given in Section 2. We present our resilient packet-forwarding
bodyText ||| scheme in Section 3. An evaluation of the scheme is given
bodyText ||| and discussed in Section 4. We present conclusions and fu-
bodyText ||| ture work in Section 5.
sectionHeader ||| 2. BACKGROUND
sectionHeader ||| 2.1 Network Model
bodyText ||| Sensor networks typically comprise one or multiple base
bodyText ||| stations and hundreds or thousands of inexpensive, small,
bodyText ||| static, and resource-constrained nodes scattered over a wide
bodyText ||| area. An inexpensive sensor node cannot afford tamper-
bodyText ||| resistant packaging. We assume that a large number of sen-
bodyText ||| sor nodes are deployed in high density over a vast field, such
bodyText ||| that the expected degree of a node is high; each sensor has
bodyText ||| multiple neighbors within its communication range. Sensing
bodyText ||| data or aggregated data are sent along the multihop route
bodyText ||| to the base station. We assume that each sensor node has
bodyText ||| a constant transmission range, and communication links are
bodyText ||| bidirectional.
bodyText ||| Our sensor network model employs a key-establishment
bodyText ||| scheme that extends the one in LEAP [46] where the im-
bodyText ||| pact of a node compromise is localized in the immediate
bodyText ||| neighborhood of the compromised node, and our scheme is
bodyText ||| based on it. To evolve from LEAP, we will describe it briefly
bodyText ||| in Section 2.4.
subsectionHeader ||| 2.2 Threat Model
bodyText ||| The attacks launched from outsiders hardly cause much
bodyText ||| damage to the network, since the rouge node, which does not
bodyText ||| possesses the legitimate credentials (e.g. the predistributed
bodyText ||| key ring from the key pool [13]), fails to participate in the
bodyText ||| network. On the other hand, there may be multiple attacks
bodyText ||| from insiders (e.g. dropping legitimate reports, injecting
bodyText ||| false sensing reports, advertising inconsistent route infor-
bodyText ||| mation, and eavesdropping in-network communication us-
bodyText ||| ing exposed keys, etc), and the combination of such attacks
bodyText ||| can lead to disruption of the whole network. Thus, proper
bodyText ||| security countermeasures (specifically designed to protect
bodyText ||| against each type of the attacks) should be provided.
bodyText ||| Among them, in this paper, we focus on defending against
bodyText ||| compromised nodes’ dropping of legitimate reports; Other
bodyText ||| attacks mentioned above are effectively dealt with by several
bodyText ||| proposed schemes as described in the previous section.
bodyText ||| We consider a packet-dropping node as not merely a faulty
bodyText ||| node, but also an arbitrarily malicious node. Some previous
bodyText ||| work [3, 29, 36] on reliable delivery uses an acknowledge-
bodyText ||| ment (ACK) that its packets were correctly received at the
bodyText ||| next-hop node, in order to find out unreliable links. How-
bodyText ||| ever, in the presence of maliciously packet-dropping nodes,
bodyText ||| simply receiving ACK from a next-hop node does not guar-
bodyText ||| antee that the packet will be really forwarded by the next-
bodyText ||| hop node. For example, node u forwards a packet to com-
bodyText ||| promised node v, and node u waits for ACK from node v.
bodyText ||| Node v sends back ACK to node u, and then node v silently
bodyText ||| drops the packet. This simple example shows that receiving
bodyText ||| ACK is not enough for reliable delivery in face of maliciously
bodyText ||| packet-dropping nodes.
page ||| 60
bodyText ||| For more reliability, we should check whether the next-
bodyText ||| hop node really forwards the relaying packet to its proper
bodyText ||| next-hop node. Fortunately, due to the broadcast nature of
bodyText ||| communication pattern in sensor networks, we can overhear
bodyText ||| neighbors’ communication for free (for now per-link encryp-
bodyText ||| tion is ignored). After forwarding a packet to next-hop node
bodyText ||| v and buffering recently-sent packets, by listening in on node
bodyText ||| v’s traffic, we can tell whether node v really transmits the
bodyText ||| packet. Watchdog [28] mechanism (extension to DSR [22]),
bodyText ||| implicit ACK in M2 RC [29], and local monitoring in DI-
bodyText ||| CAS [25] detect misbehaving nodes in this way. However,
bodyText ||| this kind of simple overhearing schemes does not guarantee
bodyText ||| reliable delivery, either.
bodyText ||| With arbitrarily malicious nodes, we should be assured
bodyText ||| that the node, to which the next-hop node forwards the
bodyText ||| relaying packet, is really a neighbor of the next-hop node.
bodyText ||| For example, node u forwards a packet to compromised node
bodyText ||| v, and node u listens in on node v’s traffic to compare each
bodyText ||| overheard packet with the packet in the buffer. Node v
bodyText ||| transmits the relaying packet whose intended next-hop id
bodyText ||| marked with any id in the network such as x that is not a
bodyText ||| neighbor of v. Then node u overhears this packet from node
bodyText ||| v, and considers it forwarded correctly despite the fact that
bodyText ||| none actually receives the packet. The packet is eventually
bodyText ||| dropped without being detected. We refer to this attack as
bodyText ||| blind letter attack.
bodyText ||| We consider packet-dropping attacks to be addressed in
bodyText ||| this paper as ones ranging from the naive case (e.g. a faulty
bodyText ||| node) to the most malicious one (e.g. a node launching
bodyText ||| blind letter attack). We focus on developing a solution to
bodyText ||| such attacks.
subsectionHeader ||| 2.3 Notation
bodyText ||| We use the following notation throughout the paper:
listItem ||| •	u, v are principals, such as communicating nodes.
listItem ||| •	R.. is a random number generated by u.
listItem ||| •	fK is a family of pseudo-random function [12].
listItem ||| •MAC(K, M1 |M2) denotes the message authentication
listItem ||| code (MAC) of message - concatenation of M1 and M2,
listItem ||| with MAC key K.
subsectionHeader ||| 2.4 Key-Establishment Scheme in LEAP
bodyText ||| LEAP supports the establishment of four types of keys for
bodyText ||| each sensor node - an individual key shared with the base
bodyText ||| station, a pairwise key shared with its neighbor, a cluster
bodyText ||| key shared with its surrounding neighbors, and a group key
bodyText ||| shared by all the nodes in the networks.
bodyText ||| It assumes that the time interval Test for a newly deployed
bodyText ||| sensor node to complete the neighbor discovery phase (e.g.
bodyText ||| tens of seconds) is smaller than the time interval T.i. that is
bodyText ||| necessary for the attacker to compromise a legitimate node
bodyText ||| (i.e. T�i. &gt; Test). Some existing work [1, 39] has made
bodyText ||| similar assumptions, which are believed to be reasonable.
bodyText ||| The four steps for a newly added node u to establish a
bodyText ||| pairwise key with each of its neighbors are as follows:
listItem ||| 1. KEY PRE-dIStRIbUtIOn. Each node u is loaded with
listItem ||| a common initial key KI, and derives its master key
listItem ||| K.. = fKI (u).
listItem ||| 2. NEIghbOR DISCOVERY. Once deployed, node u sets
listItem ||| up a timer to fire after time T�i., broadcasts its id,
listItem ||| and waits for each neighbor v’s ACK. The ACK from
listItem ||| v is authenticated using the master key K, of node v.
listItem ||| Since node u knows KI, it can derive K, = fKI (v).
listItem ||| u−→∗: u,R...
listItem ||| v−→u: v, MAC(K,, R.. |v).
listItem ||| 3. PAIRWISE KEY EStAblIShmEnt. Node u computes its
listItem ||| pairwise key with v, K..,, as K.., = fKv (u). Node v
listItem ||| also computes K.., in the same way. K.., serves as
listItem ||| their pairwise key.
listItem ||| 4. KEY ERASURE. When its timer expires, node u erases
listItem ||| KI and all the master keys of its neighbors. Every
listItem ||| node, however, keeps its own master key, in order to
listItem ||| establish pairwise keys with later-deployed nodes.
bodyText ||| Once erasing KI, a node will not be able to establish a
bodyText ||| pairwise key with any other nodes that have also erased KI.
bodyText ||| Without KI, a cloned node (by an attacker compromising a
bodyText ||| legitimate node after T.i.) fails to establish pairwise keys
bodyText ||| with any nodes except the neighbors of the compromised
bodyText ||| node. In such a way, LEAP localizes the security impact of
bodyText ||| a node compromise.
sectionHeader ||| 3. A RESILIENT PACKET-FORWARDING
sectionHeader ||| SCHEME USING NEIGHBOR WATCH SYS-
sectionHeader ||| TEM
bodyText ||| In this section, we present our resilient packet-forwarding
bodyText ||| scheme using Neighbor Watch System (NWS). NWS works
bodyText ||| with the information provided by Neighbor List Verification
bodyText ||| (NLV) to be described in Section 3.2.
subsectionHeader ||| 3.1 Neighbor Watch System
bodyText ||| Our scheme seeks to achieve hop-by-hop reliable delivery
bodyText ||| in face of maliciously packet-dropping nodes, basically em-
bodyText ||| ploying single-path forwarding. To the best of our knowl-
bodyText ||| edge, proposed works so far rely on multipath forwarding
bodyText ||| or diffusion-based forwarding, exploiting a large number of
bodyText ||| nodes in order to deliver a single packet. ACK-based tech-
bodyText ||| nique is not a proper solution at all as explained in the
bodyText ||| previous section.
bodyText ||| With NWS, we can check whether the next-hop node re-
bodyText ||| ally forwards the relaying packet to the actual neighbor of
bodyText ||| the next-hop node. The basic idea of our scheme is as fol-
bodyText ||| lows:
listItem ||| 1. Neighbor List Verification. After deployment, dur-
listItem ||| ing neighbor discovery phase, every node u gets to
listItem ||| know of not only its immediate neighbors, but also the
listItem ||| neighbors’ respective neighbor lists (i.e. u’s neighbors’
listItem ||| neighbor lists). The lists are verified using Neighbor
listItem ||| List Verification to be described in Section 3.2. Every
listItem ||| node stores its neighbors’ neighbor lists in the neighbor
listItem ||| table.
listItem ||| 2. Packet Forwarding to Next-hop. If node u has
listItem ||| a packet to be relayed, it buffers the packet and for-
listItem ||| wards the packet (encrypted with cluster key of node
listItem ||| u so that neighbors of node u can overhear it) to its
listItem ||| next-hop node v. As in LEAP, a cluster key is a key
listItem ||| shared by a node and all its neighbors, for passive par-
listItem ||| ticipation.
page ||| 61
figureCaption ||| Figure 1: Neighbor Watch System. Sub-watch
figureCaption ||| nodes w and y, as well as primary-watch node u lis-
figureCaption ||| ten in on v’s traffic.
listItem ||| 3. Designation of Watch Nodes. Overhearing the
listItem ||| packet from node u to node v, among neighbors of
listItem ||| node u, the nodes that are also neighbors of node v (in
listItem ||| Figure 1, nodes w and y) are designated as sub-watch
listItem ||| nodes and store the packet in the buffer. Other nodes
listItem ||| (that are not neighbors of node v) discard the packet.
listItem ||| Node u itself is a primary-watch node. A primary-
listItem ||| watch node knows which nodes are sub-watch nodes,
listItem ||| since every node has the knowledge of not only its
listItem ||| neighbors but also their respective neighbor lists.
listItem ||| 4. Neighbor Watch by Sub-Watch Node. Sub-watch
listItem ||| nodes w and y listen in on node v’s traffic to compare
listItem ||| each overheard packet with the packet in the buffer.
listItem ||| To defend against blind letter attack, each of them
listItem ||| also checks whether the packet’s intended next-hop is
listItem ||| a verified neighbor of node v, by looking up the neigh-
listItem ||| bor table. If all correct, the packet in the buffer is
listItem ||| removed and the role of the sub-watch node is over.
listItem ||| If the packet has remained in the buffer for longer
listItem ||| than a certain timeout, sub-watch nodes w and y for-
listItem ||| ward the packet (encrypted with their respective clus-
listItem ||| ter keys) to their respective next-hop nodes other than
listItem ||| node v. Then the role of a sub-watch node is over (each
listItem ||| of them is now designated as a primary-watch node for
listItem ||| the packet it has forwarded).
listItem ||| 5. Neighbor Watch by Primary-Watch Node. Primary-
listItem ||| watch node u does the same job as sub-watch nodes.
bodyText ||| The only difference, however, is that it listens in on
bodyText ||| not only node v’s traffic, but also sub-watch nodes w’s
bodyText ||| and y’s. If the packet is correctly forwarded on by at
bodyText ||| least one of them (nodes v, w, or y), primary-watch
bodyText ||| node u removes the packet in the buffer and the role
bodyText ||| of the primary-watch node is over.
bodyText ||| Otherwise, after a certain timeout, primary-watch node
bodyText ||| u forwards the packet (encrypted with its cluster key)
bodyText ||| to its next-hop other than node v.
bodyText ||| As the packet is forwarded on, this procedure (except for
bodyText ||| Neighbor List Verification) of NWS is performed at each
bodyText ||| hop so that hop-by-hop reliable delivery can be achieved
bodyText ||| with mainly depending on single-path forwarding. On the
bodyText ||| other hand, in the previous approaches [29, 39, 42], when
bodyText ||| forwarding a packet, a node broadcasts the packet with no
bodyText ||| designated next-hop, and all neighbors with smaller costs&apos;
bodyText ||| &apos;The cost at a node is the minimum energy overhead to
figureCaption ||| Figure 2: An example of our packet-forwarding
figureCaption ||| scheme. Only the nodes that relay the packet are
figureCaption ||| presented. With the help of sub-watch nodes (grey
figureCaption ||| ones), our scheme bypasses two packet-dropping
figureCaption ||| nodes en-route to the base station.
bodyText ||| or within a specific geographic region continue forwarding
bodyText ||| the packet anyway. For example, in Figure 1, if nodes v,
bodyText ||| w, and y have smaller costs than node u in the previous
bodyText ||| approaches, they all forward2 the packet from node u. In
bodyText ||| our scheme, however, sub-watch nodes w and y are just on
bodyText ||| watch in designated next-hop node v, instead of uncondi-
bodyText ||| tionally forwarding the packet. If no packet-dropping occurs
bodyText ||| en-route to the base station, the packet may be forwarded
bodyText ||| along single-path all the way through.
bodyText ||| However, a packet-dropping triggers the multipath for-
bodyText ||| warding for the dropped packet. If the designated next-hop
bodyText ||| node v in Figure 1 has not forwarded the relaying packet to
bodyText ||| its certified neighbor by a certain timeout, sub-watch nodes
bodyText ||| w and y forward the packet to their respective next-hop.
bodyText ||| At the point, the packet is sent over multiple paths. Since
bodyText ||| the location where the packet-dropping occurs is likely in
bodyText ||| an unreliable region, this prompt reaction of the conver-
bodyText ||| sion to multipath forwarding augments the robustness in our
bodyText ||| scheme. The degree of multipath depends on the number of
bodyText ||| the sub-watch nodes. Figure 2 shows an example of our
bodyText ||| packet-forwarding scheme, bypassing two packet-dropping
bodyText ||| nodes en-route to the base station. If a node utilizes a cache
bodyText ||| [16, 21] for recently-received packets, it can suppress the
bodyText ||| same copy of previously-received one within a certain time-
bodyText ||| out, as nodes u and v in Figure 2.
bodyText ||| Our scheme requires that a relaying packet should be en-
bodyText ||| crypted with a cluster key of a forwarding node, in order
bodyText ||| that all its neighbors can decrypt and overhear it. In fact,
bodyText ||| per-link encryption provides better robustness to a node
bodyText ||| compromise, since a compromised node can decrypt only
bodyText ||| the packets addressed to it. Thus, there exists a tradeoff
bodyText ||| between resiliency against packet-dropping and robustness
bodyText ||| to a node compromise. However, encryption with a cluster
bodyText ||| key provides an intermediate level of robustness to a node
bodyText ||| compromise [24] (a compromised node can overhear only
bodyText ||| its immediate neighborhood), and also supports local broad-
bodyText ||| cast (i.e. resiliency against packet-dropping), so that we can
bodyText ||| achieve graceful degradation in face of compromised nodes.
bodyText ||| forward a packet from this node to the base station.
footnote ||| 2It is the broadcast transmission with no designated next-
footnote ||| hop, and, if needed, the packet should be encrypted with a
footnote ||| cluster key in order for all neighbors to overhear it.
figure ||| u
figure ||| y
figure ||| v
figure ||| w
figure ||| Base
figure ||| Station
figure ||| v
figure ||| u
page ||| 62
bodyText ||| To make our scheme work (against blind letter attack), we
bodyText ||| must address the problem of how a node proves that it re-
bodyText ||| ally has the claimed neighbors. It is the identical problem of
bodyText ||| how a node verifies the existence of its neighbors’ neighbors.
bodyText ||| Apparently, a node has the knowledge of its direct neigh-
bodyText ||| bors by neighbor discovery and pairwise key establishment
bodyText ||| phases. However, in the case of two-hop away neighbors,
bodyText ||| as in Figure 1, malicious node v can inform its neighbor u
bodyText ||| that it also has neighbor node x (any possible id in the net-
bodyText ||| work) which in fact is not a neighbor of node v. Node u has
bodyText ||| to believe it, since node x is not a direct neighbor of node
bodyText ||| u, and only the node v itself knows its actual surrounding
bodyText ||| neighbors. Then, how do we verify the neighbors’ neigh-
bodyText ||| bors? The answer to this critical question is described in
bodyText ||| the next subsection.
subsectionHeader ||| 3.2 Neighbor List Verification
bodyText ||| To verify neighbors’ neighbors, we present Neighbor List
bodyText ||| Verification (NLV) which extends the pairwise key estab-
bodyText ||| lishment in LEAP. During neighbor discovery in LEAP, two
bodyText ||| messages are exchanged between neighbors to identify each
bodyText ||| other. On the other hand, NLV adopts three-way handshak-
bodyText ||| ing neighbor discovery, in order to identify not only com-
bodyText ||| municating parties but also their respective neighbors.
bodyText ||| NLV has two cases of neighbor discovery. One is that
bodyText ||| neighbor discovery between two nodes that are both still
bodyText ||| within the initial Tmin3 (referred as pure nodes). The other
bodyText ||| is that neighbor discovery between a newly-deployed node
bodyText ||| within the initial Tmin and an existing node over the initial
bodyText ||| Tmin (referred as an adult node).
bodyText ||| Neighbor Discovery between Pure Nodes. Neighbor
bodyText ||| list verification process between pure nodes is quite simple.
bodyText ||| If a pure node broadcasts its neighbor list before the elapse of
bodyText ||| its initial Tmin, we can accept the list as verifiable. Thus, the
bodyText ||| key point here is to keep track of each other’s Tmin, and to
bodyText ||| make sure that both broadcast their respective neighbor lists
bodyText ||| before their respective Tmin. The following shows the three-
bodyText ||| way handshaking neighbor discovery between pure node u
bodyText ||| and v:
figure ||| u----+*: u,Ru.
figure ||| v ----+u : �v, Tv, �Rv ,  MAC(Kv, Ru J Ku JMv).
figure ||| M„
figure ||| u----+v: u,Tu , MAC(Kuv, RvJMu).
figure ||| M.
bodyText ||| where Tv and Tu are the amount of time remaining until
bodyText ||| Tmin of v and Tmin of u, respectively. Once deployed, node
bodyText ||| u sets up a timer to fire after time Tmin. Then, it broadcasts
bodyText ||| its id, and waits for each neighbor v’s ACK. The ACK from
bodyText ||| every neighbor v is authenticated using the master key Kv of
bodyText ||| node v. Since node u knows KI4, it can derive Kv = fKI (v).
bodyText ||| The ACK from node v contains Tv, the amount of time
bodyText ||| remaining until Tmin of node v. If Tv is a non-zero value,
bodyText ||| node v claims to be a pure node. Ku in MAC proves node
bodyText ||| v to be a pure node, since pure node v should know KI
bodyText ||| and derive Ku = fKI (u). Node u records ˇTv (Tv added
footnote ||| 3Tmin is the time interval, necessary for the attacker to com-
footnote ||| promise a legitimate node as in LEAP [46].
footnote ||| 4Each node u is loaded with a common initial key KI, and
footnote ||| derives its master key Ku = fKI (u). After time Tmin, node
footnote ||| u erases KI and all the master keys of its neighbors.
figureCaption ||| Figure 3: Neighbor Discovery between Pure node x
figureCaption ||| and Adult node u. Grey and white nodes represent
figureCaption ||| adult and pure nodes, respectively.
bodyText ||| to the current time of node u) in the entry for node v in
bodyText ||| the neighbor table. Node u computes its pairwise key with
bodyText ||| v, Kuv = fK„ (u).5 Node u also generates MAC(Kv, v Ju)
bodyText ||| (which means that v certifies u as an immediate neighbor),
bodyText ||| and stores it as a certificate.
bodyText ||| The ACK from node u also contains Tu, the amount of
bodyText ||| time remaining until Tmin of u. This ACK is authenticated
bodyText ||| using their pairwise key Kuv, which proves node u a pure
bodyText ||| node and u’s identity. Node v then records ˇTu (Tu added
bodyText ||| to the current time of v) in the entry for u in the neighbor
bodyText ||| table. It also generates MAC(Ku, uJv) and stores it as a
bodyText ||| certificate. Then, the three-way handshaking is done.
bodyText ||| Every pure node u broadcasts its neighbor list just prior
bodyText ||| to Tmin of u. Each receiving neighbor v checks whether the
bodyText ||| receiving time at v is prior to ˇTu in the neighbor table. If
bodyText ||| yes, the neighbor list of u is now certified by each neighbor v.
bodyText ||| Neighbor Discovery between A Pure Node and An
bodyText ||| Adult node. After most nodes have completed bootstrap-
bodyText ||| ping phase, new nodes can be added in the network. Con-
bodyText ||| sider Figure 3. The issue here is how adult node u can as-
bodyText ||| sure its existing neighbors (v and w) of the existence of its
bodyText ||| newly-added neighbor x. This is a different situation from
bodyText ||| the above neighbor list verification case between two pure
bodyText ||| nodes. Thus, the messages exchanged during the three-way
bodyText ||| handshaking are somewhat different in this case. The fol-
bodyText ||| lowing shows the three-way handshaking neighbor discovery
bodyText ||| between pure node x and adult node u:
equation ||| x----+ * :	x, Rx.
equation ||| , MAC(Kxu, Ru JMx).
bodyText ||| Newly-added node x sets up a timer to fire after time Tmin.
bodyText ||| Then, it broadcasts its id, and waits for each neighbor u’s
footnote ||| 5Node v also computes Kuv in the same way. Kuv serves as
footnote ||| their pairwise key.
equation ||| r
equation ||| t
equation ||| z
equation ||| v
equation ||| w
equation ||| u
equation ||| x
equation ||| q
equation ||| certificate ��	�
equation ||| certificate ��	�
equation ||| u----+ x : u, Tu, Ru, v,	MAC(Kv, vJu), w, MAC(Kw, wJu)
equation ||| 	�	��	�
equation ||| M.
equation ||| , MAC(Ku, Rx JMu).
equation ||| x----+u:	certificate ��	�	one—time cert. �	one—time cert.
equation ||| 			^ �
equation ||| MAC(Kx, xJu), v, MAC(Kv, xJu), w, MAC(Kw, xJu)
equation ||| �	��	�
equation ||| Ms
equation ||| x, Tx,
page ||| 63
bodyText ||| ACK. The ACK from every neighbor u is authenticated us-
bodyText ||| ing the master key Ku of node u. Since node x knows KI,
bodyText ||| it can derive Ku = fKI (u). The ACK from node u contains
bodyText ||| Tu, the amount of time remaining until Tmin of u. If Tu is
bodyText ||| zero, node u is an adult node that may already have mul-
bodyText ||| tiple neighbors as in Figure 3. Node u reports its certified
bodyText ||| neighbor list (v and w) to x by including their respective
bodyText ||| certificates in the ACK. Node x verifies u’s neighbor list by
bodyText ||| examining each certificate, since x can generate any certifi-
bodyText ||| cate with KI. If all correct, x computes its pairwise key with
bodyText ||| u, Kxu = fKu (x). Node x also generates MAC(Ku, ujx) and
bodyText ||| stores it as a certificate.
bodyText ||| The ACK from x also contains Tx, the amount of time
bodyText ||| remaining until Tmin of x. This ACK is authenticated using
bodyText ||| their pairwise key Kxu, which proves node x a pure node
bodyText ||| and x’s identity. Node u then records ˇTx (Tx added to the
bodyText ||| current time of u) in the entry for x in the neighbor table.
bodyText ||| Since adult node u cannot generate MAC(Kx, xju) by itself,
bodyText ||| pure node x provides the certificate for u in the ACK. Node
bodyText ||| x also provides one-time certificates6 for each of u’s certified
bodyText ||| neighbors (v and w). Then, the three-way handshaking is
bodyText ||| done.
bodyText ||| After that, adult node u broadcasts one-time certificates
bodyText ||| (from newly-discovered pure node x), in order to assure u’s
bodyText ||| existing neighbors (v and w) of the discovery of new neighbor
bodyText ||| x. The packet containing one-time certificates is as follows:
equation ||| Mu
equation ||| , MAC(Kcu, Mu).
bodyText ||| where x is a new neighbor of u, KAu is a local broadcast au-
bodyText ||| thentication key in u’s one-way key chain, Kcu is the cluster
bodyText ||| key of u. Each receiving neighbor v of u verifies u’s new
bodyText ||| neighbor x by examining the one-time certificate designated
bodyText ||| for v, MAC(Kv, xju)6. If ok, node x is now certified by each
bodyText ||| neighbor v of u. Then, one-time certificates can be erased,
bodyText ||| since they are of no use any more.
bodyText ||| Broadcast authentication only with symmetric keys such
bodyText ||| as cluster key Kcu fails to prevent an impersonation attack,
bodyText ||| since every neighbor of u shares the cluster key of u. Thus,
bodyText ||| we employ the reverse disclosure of one-way key chain KAu
bodyText ||| as in LEAP.
bodyText ||| Just prior to Tmin of x, pure node x broadcasts its neigh-
bodyText ||| bor list. Each receiving neighbor u of x checks whether the
bodyText ||| receiving time at u is prior to ˇTx in the neighbor table. If
bodyText ||| yes, the neighbor list of x is now certified by each neighbor u.
bodyText ||| In summary, through the proposed three-way handshak-
bodyText ||| ing neighbor discovery process, pure node u identifies each
bodyText ||| immediate neighbor v and v’s certified neighbor list (if v is
bodyText ||| an adult node), and keeps track of Tmin of v. Just prior
bodyText ||| to Tmin of u, node u broadcasts its direct neighbor list so
bodyText ||| that every neighbor of u accepts the list as verifiable. Then,
bodyText ||| node u becomes an adult node. After that, if newly-added
bodyText ||| node x initiates neighbor discovery with adult node u, node
bodyText ||| u identifies pure node x, keeps track of Tmin of x, provides
bodyText ||| u’s certified neighbor list to x, and, in return, takes one-time
bodyText ||| certificates from x. Node u then broadcasts these one-time
footnote ||| 6One-time certificate, for instance MAC(Kv, xju), assures
bodyText ||| v that x is an immediate neighbor of u. It is generated by
bodyText ||| pure node x with master key of v.
tableCaption ||| Table 1: An example of the Neighbor Table of u.
table ||| Neighbor ID	Certificate	Verified Neighbor List
table ||| v	MAC(Kv, v ju)	u, w, t
table ||| w	MAC(Kw, wju)	u, v, z
table ||| x	MAC(Kx, xju)	u, r, q
bodyText ||| certificates, in order to assure u’s existing neighbors of the
bodyText ||| discovery of new neighbor x. Thus, every time adult node u
bodyText ||| discovers newly-added node x through three-way handshak-
bodyText ||| ing, node u informs (by broadcasting) its existing neighbors
bodyText ||| of the discovery of new neighbor x. Also, whenever receiv-
bodyText ||| ing neighbor list information from pure neighbor x, node u
bodyText ||| checks whether the receiving time at u is prior to ˇTx in the
bodyText ||| neighbor table. If yes, u now accepts the neighbor list of x
bodyText ||| as verifiable.
bodyText ||| Through the above neighbor list verification in the boot-
bodyText ||| strapping phase, every node gets the knowledge of its neigh-
bodyText ||| bors’ certified neighbors. Our Neighbor Watch System makes
bodyText ||| use of this information to prevent blind letter attack. With
bodyText ||| this knowledge, watch nodes are able to check whether the
bodyText ||| relaying packet’s intended next-hop is a verified neighbor of
bodyText ||| the forwarding node.
subsectionHeader ||| 3.3 Neighbor Table Maintenance
bodyText ||| The information obtained through neighbor list verifica-
bodyText ||| tion (e.g. its direct neighbors, corresponding certificates,
bodyText ||| neighbors’ neighbor lists, etc) is stored in the neighbor table
bodyText ||| of each node. Table 1 shows an example of the neighbor
bodyText ||| table of node u. In densely-deployed sensor networks, the
bodyText ||| expected degree of a node is high. However, in this example,
bodyText ||| for simplicity, node u has only three neighbors v, w, and x
bodyText ||| as in Figure 3.
bodyText ||| The entries in the neighbor table are accessed and main-
bodyText ||| tained with immediate neighbor IDs. For example, if node
bodyText ||| u overhears the packet sent from w to v, node u begins to
bodyText ||| listen in on v’s traffic as a sub-watch node (since the neigh-
bodyText ||| bor table of u has both v’s and w’s entries in it). Unless v
bodyText ||| forwards the packet to a node of the Verified Neighbor List
bodyText ||| in v’s entry by a certain timeout, sub-watch node u will for-
bodyText ||| ward the packet to its next-hop other than v; many existing
bodyText ||| routing protocols [5, 18, 21, 27, 37, 43] enable each node to
bodyText ||| maintain multiple potential next-hop. Once forwarding the
bodyText ||| packet, sub-watch node u becomes a primary-watch node
bodyText ||| and begins to listen in on its next-hop’s traffic as described
bodyText ||| above.
bodyText ||| If newly-added node y initiates the three-way handshaking
bodyText ||| with u, node u provides its neighbor list to y by sending
bodyText ||| certificates in the neighbor table. Node u, in return from
bodyText ||| node y, takes the certificate for y and one-time certificates
bodyText ||| for u’s existing neighbors. Then, node u stores the certificate
bodyText ||| in the new entry for y. However, node u does not store the
bodyText ||| one-time certificates but broadcasts them to its neighbors.
bodyText ||| If new neighbor y broadcasts its neighbor list within Tmin,
bodyText ||| node u stores the list in the entry for y.
bodyText ||| If node u is compromised, not only cryptographic key
bodyText ||| information but also certificates in the neighbor table are
bodyText ||| exposed. However, the attacker cannot misuse these cer-
bodyText ||| tificates for other purposes. Since a certificate only attests
bodyText ||| neighborship between two specific nodes, it cannot be ap-
bodyText ||| plied to any other nodes. In fact, it can be made even public.
bodyText ||| However, colluding nodes can deceive a pure node anyway,
bodyText ||| one—time cert.	one—time cert.
equation ||| � �	�
equation ||| MAC(Kv, xju), w, MAC(Kw, xju), KAu
equation ||| �	��	�
equation ||| u____+ * :	u, x, v,
equation ||| �
page ||| 64
bodyText ||| by fabricating a bogus certificate. We will describe this lim-
bodyText ||| itation in Section 4.4.
sectionHeader ||| 4. EVALUATION
bodyText ||| In this section, we evaluate the communication and stor-
bodyText ||| age cost, and analyze the security of our resilient forwarding
bodyText ||| scheme (Neighbor Watch System) as well as Neighbor List
bodyText ||| Verification. We then present the simulation results of our
bodyText ||| forwarding scheme.
subsectionHeader ||| 4.1 Communication Cost
bodyText ||| Unlike the previously proposed diffusion-based reliable-
bodyText ||| forwarding schemes [21, 29, 39, 42] that exploit a large num-
bodyText ||| ber of nodes to deliver a single packet, our scheme requires
bodyText ||| only the designated next-hop node to relay the packet, un-
bodyText ||| der the supervision of watch nodes. We note that, like over-
bodyText ||| hearing by watch nodes in our scheme, those diffusion-based
bodyText ||| schemes require each node to listen to all its neighbors, since
bodyText ||| they forward a packet by broadcasting with no designated
bodyText ||| next-hop. With a smaller number of relaying nodes, our
bodyText ||| scheme makes a report successfully reach the base station.
bodyText ||| Thus, the average communication cost of our forwarding
bodyText ||| scheme for delivery of a single packet is smaller than those
bodyText ||| of the previous schemes.
bodyText ||| Our neighbor list verification during the bootstrapping
bodyText ||| phase requires the three-way handshaking neighbor discov-
bodyText ||| ery. Unlike the neighbor discovery between two pure nodes,
bodyText ||| the size of the messages exchanged between a pure and an
bodyText ||| adult node varies with the degree of the adult node. A large
bodyText ||| number of certificates caused by the high degree can be over-
bodyText ||| burdensome to a single TinyOS packet which provides 29
bodyText ||| bytes for data. Considering 8-byte certificates and a 4-byte7
bodyText ||| message authentication code (MAC), the adult node is able
bodyText ||| to include at most two neighbors’ information in a single
bodyText ||| TinyOS packet. Thus, when the entire neighbor list cannot
bodyText ||| be accommodated within a single packet, the node should
bodyText ||| allot the list to several packets and send them serially. In a
bodyText ||| network of size N with the expected degree d of each node,
bodyText ||| the average number of packets invoked by a newly-added
bodyText ||| node per each node is nearly (d — 1)2/2(N — 1).
bodyText ||| Therefore, as node density d grows, the total number
bodyText ||| of packets transmitted from adult nodes to a newly-added
bodyText ||| node increases. However, neighbor discovery between a pure
bodyText ||| and an adult node occurs much less than between two pure
bodyText ||| nodes, since most neighbor discoveries throughout the net-
bodyText ||| work are between two pure nodes in the early stage of the
bodyText ||| network. Neighbor discovery between a pure and an adult
bodyText ||| node occurs generally when a new node is added to the net-
bodyText ||| work.
subsectionHeader ||| 4.2 Storage Overhead
bodyText ||| In LEAP, each node keeps four types of keys and a man-
bodyText ||| ageable length of hash chain, which is found to be scalable.
bodyText ||| In our scheme, each node needs to additionally store its di-
bodyText ||| rect neighbors’ certificates and their respective neighbor lists
bodyText ||| as in Table 1. Thus, for a network of the expected degree
bodyText ||| d and the byte size l of node ID, the additional storage re-
bodyText ||| quirement for each node is d • (8 + ld) bytes.
bodyText ||| Although our storage requirement for these neighbor lists
bodyText ||| is O(d 2), for a reasonable degree d, memory overhead does
footnote ||| 74-byte MAC is found to be not detrimental in sensor net-
footnote ||| works as in TinySec [24] which employs 4-byte MAC.
figureCaption ||| Figure 4: Examples of critical area C1 and C2.
bodyText ||| not exceed 1 KB (a Berkeley MICA2 Mote with 128 KB
bodyText ||| flash memory and 4 KB SRAM). For example, when d = 20
bodyText ||| and l = 2, a node needs 960 bytes of memory to store such
bodyText ||| information.
bodyText ||| If node density of a network is so high that the required
bodyText ||| space for those neighbor lists significantly increases and the
bodyText ||| storage utilization becomes an issue, we can employ a storage-
bodyText ||| reduction technique such as Bloom filter [2]. For example,
bodyText ||| when d = 30 and l = 2, a node requires 2,040 bytes of addi-
bodyText ||| tional space mainly for the neighbor lists. Instead of storing
bodyText ||| neighbors’ neighbor lists, applying each of the neighbor lists
bodyText ||| (480 bits) to a Bloom filter (of 5 hash functions mapping to
bodyText ||| a 256 bit vector), a node needs the reduced space of 1,200
bodyText ||| bytes for such information (with the false positive probabil-
bodyText ||| ity = 0.02).
subsectionHeader ||| 4.3 Resilience to Packet-Dropping Attacks
bodyText ||| In face of maliciously packet-dropping nodes, the higher
bodyText ||| degree of multipath we provide, the more resiliency our
bodyText ||| scheme achieves against such attacks. The average degree
bodyText ||| of multipath depends on the number of sub-watch nodes
bodyText ||| around a packet-dropping node. Sub-watch nodes should
bodyText ||| be located in the region within the communication range of
bodyText ||| both forwarding node u and designated next-hop v. We re-
bodyText ||| fer to such a region as critical area. As in Figure 4, if nodes
bodyText ||| u and v are located farther away, the size of critical area C2
bodyText ||| gets smaller than that of C1, and the probability (p.) that
bodyText ||| at least one sub-watch node exists in the critical area goes
bodyText ||| down. The probability (p.) is
equation ||| p. = 1 — (1 — c)d-1,
bodyText ||| where c is the ratio of the critical area size to the node’s com-
bodyText ||| munication range, and the expected degree d of the node.
bodyText ||| To determine the appropriate degree d, we set the smallest
bodyText ||| critical area C2 in Figure 4 as a lower bound case (c = 0.4).
bodyText ||| Figure 5 shows that, even in the lower bound critical area,
bodyText ||| with d = 6 and d = 10, probability p. is above 0.9 and above
bodyText ||| 0.99, respectively.
bodyText ||| Since, in a network of degree d, the probability that there
bodyText ||| exist m sub-watch nodes in the critical area of the ratio c is
equation ||| p(m) = �d — m J 1) cm(1 — c)d-m-1
bodyText ||| the expected number of sub-watch nodes, m, in the critical
bodyText ||| area is given by
equation ||| E[m] = (d — 1)c.
bodyText ||| Thus, in the lower bound (c = 0.4) critical area, when d =
bodyText ||| 10, 15, 20, the number of sub-watch nodes (i.e. the degree
bodyText ||| of multipath) is 3.6, 5.6, 7.6 on average, respectively. This
figure ||| u	v	?	u	v	?
figure ||| C1	C2
figure ||| ,
page ||| 65
figureCaption ||| Figure 5: Probability (p.) that at least one sub-
figureCaption ||| watch node exists in the lower bound (c = 0.4) criti-
figureCaption ||| cal area.
bodyText ||| shows that the higher degree of each node has, our scheme
bodyText ||| has the higher degree of multipath and resiliency against
bodyText ||| packet-dropping nodes.
subsectionHeader ||| 4.4 The Security of Neighbor List Verification
bodyText ||| Our Neighbor List Verification(NLV) keeps the nice prop-
bodyText ||| erties of LEAP. Adult nodes fail to establish pairwise keys
bodyText ||| with any adult nodes in arbitrary locations, so that the im-
bodyText ||| pact of a node compromise is localized. NLV performs the
bodyText ||| three-way handshaking neighbor discovery, instead of two-
bodyText ||| message exchange in LEAP. The three-way handshaking en-
bodyText ||| ables each node to verify not only its direct neighbors but
bodyText ||| also their respective neighbor lists.
bodyText ||| Moreover, this this three-way handshaking can be a po-
bodyText ||| tential solution to deal with irregularity of radio range [15,
bodyText ||| 37, 45]. In reality, due to the noise and some environmen-
bodyText ||| tal factors, radio range of each node is not exactly circu-
bodyText ||| lar. So, communication links among nodes are asymmetric;
bodyText ||| node u can hear node v which is unable to hear u. With
bodyText ||| two-message exchange, only the node initiating the neigh-
bodyText ||| bor discovery is assured of the link’s bidirectionality. By the
bodyText ||| three-way handshaking, both of neighbors can be assured of
bodyText ||| their symmetric connectivity.
bodyText ||| With NLV, only the verified lists are stored and utilized
bodyText ||| for our packet-forwarding scheme. NLV verifies the neighbor
bodyText ||| list of an adult node with certificates. These certificates
bodyText ||| merely attest neighborship between two specific nodes. Even
bodyText ||| if a node is compromised, the attacker fails to abuse the
bodyText ||| certificates of the captured node for other purpose.
bodyText ||| However, collusion among compromised nodes can fab-
bodyText ||| ricate bogus certificates in order to deceive a newly-added
bodyText ||| node. For example, consider two colluding nodes u and v at
bodyText ||| the different locations. When compromised node u discovers
bodyText ||| newly-added node x, node u provides x with u’s neighbor
bodyText ||| list (maliciously including v in it). Even though node v is
bodyText ||| not an actual neighbor of u, colluding node v can generate
bodyText ||| the bogus certificate for u, MAC(K,, v1u). Then, x falsely
bodyText ||| believes that v is a direct neighbor of u. This attack, how-
bodyText ||| ever, affects only the one newly-added node x. Thus, when
bodyText ||| compromised node u tries to launch the blind letter attack 8,
footnote ||| 8Compromised node u transmits the relaying packet with its
bodyText ||| other surrounding adult neighbors of u can still detect it
bodyText ||| anyway.
bodyText ||| The more serious case is that colluding nodes exploit a
bodyText ||| newly-added node to generate bogus one-time certificates.
bodyText ||| For example, consider two colluding nodes u and v that
bodyText ||| share all their secret information as well as all their certifi-
bodyText ||| cates. When newly-added node x initiates the three-way
bodyText ||| handshaking with u, compromised node u pretends to be
bodyText ||| v and provides x with v’ neighbor list. Then, x in return
bodyText ||| provides u with one-time certificates for each neighbor of
bodyText ||| v; these one-time certificates falsely attest that v has new
bodyText ||| neighbor x. Node u sends this information to v over the
bodyText ||| covert channel. Then, v broadcasts these one-time certifi-
bodyText ||| cates, and neighbors of v falsely believe that x is a direct
bodyText ||| neighbor of v.
bodyText ||| Unfortunately, we do not provide a proper countermea-
bodyText ||| sure to defend against this type of man-in-the-middle at-
bodyText ||| tacks. However, we point out that this type of attacks has
bodyText ||| to be launched in the passive manner. The adversary has
bodyText ||| to get the chance of discovery of a newly-added node. In
bodyText ||| other words, compromised nodes wait for the initiation of
bodyText ||| the three-way handshaking from a newly-added node. Since
bodyText ||| the attacker does not know where the new nodes will be
bodyText ||| added, it has to compromise a sufficient number of legiti-
bodyText ||| mate nodes in order to increase the probability of discovery
bodyText ||| of newly-added nodes.
bodyText ||| As an active defense against such man-in-the-middle at-
bodyText ||| tacks, we can apply a node replication detection mechanism
bodyText ||| such as Randomized or Line-Selected Multicast [31], which
bodyText ||| revokes the same ID node at the different location claims.
bodyText ||| To successfully launch such man-in-the-middle attacks, two
bodyText ||| colluding nodes should pretend to be each other so that each
bodyText ||| of them claims to be at two different locations with the same
bodyText ||| ID. Location-binding key-assignment scheme by Yang et al.
bodyText ||| [39] with a little modification also can be a good solution
bodyText ||| to such attacks. Since it binds secret keys with nodes’ geo-
bodyText ||| graphic locations, the key bound to the particular location
bodyText ||| cannot be used at any arbitrary locations. Adopting this,
bodyText ||| NLV can check whether the claimed neighbors are really lo-
bodyText ||| cated within geographically two hops away.
subsectionHeader ||| 4.5 Simulations
bodyText ||| To further evaluate the performance of our resilient for-
bodyText ||| warding scheme, we run simulations of our scheme in the
bodyText ||| presence of packet-dropping nodes on a network simulator,
bodyText ||| ns-2 [9].
subsubsectionHeader ||| 4.5.1 Simulation Model
bodyText ||| In our simulations, we deploy N sensor nodes uniformly at
bodyText ||| random within 500 x 500m2 target field, with N = 300 and
bodyText ||| 600. Each sensor node has a constant transmission range of
bodyText ||| 30m, so that the degree of each node is approximately 10
bodyText ||| (N = 300) and 20 (N = 600) on average. We position a base
bodyText ||| station and a source node in opposite corners of the field, at
bodyText ||| a fixed point (50, 50) and (450, 450), respectively. They are
bodyText ||| located approximately 18 hops away from each other.
bodyText ||| We distribute compromised nodes over an inner square
bodyText ||| area with 200m each side (from 150m to 350m of each side
bodyText ||| of the 500 x 500m2 target area). Thus, compromised nodes
bodyText ||| are strategically-placed in between the base station and the
bodyText ||| source node. In the simulations, those compromised nodes
bodyText ||| drop all the relaying packets.
bodyText ||| next-hop id as v, so that x considers it forwarded correctly.
figure ||| 1
figure ||| 0.9
figure ||| 0.8
figure ||| 0.7
figure ||| 0.6
figure ||| 0.5
figure ||| 0.4
figure ||| 0.3
figure ||| 0.2
figure ||| 0.1
figure ||| 0
figure ||| 1	5	10	15	20
figure ||| Degree of a node
figure ||| 66
figureCaption ||| Figure 6: Simulation Results (averaged over 100 runs).
figure ||| 0	5	10	15	20	25	30	35	40	45	50
figure ||| Number of Packet-dropping Nodes
figure ||| (a) Success ratio (N = 300, x = 0 — 50)
figure ||| 0	10	20	30	40	50	60	70	80	90	100
figure ||| Number of Packet-dropping Nodes
figure ||| (b) Success ratio (N = 600, x = 0 — 100)
figure ||| 100
figure ||| 100
figure ||| 10
figure ||| 10
figure ||| 0
figure ||| 0
figure ||| 90
figure ||| 90
figure ||| ( 300 nodes )
figure ||| 80
figure ||| 70
figure ||| 60
figure ||| 50
figure ||| 40
figure ||| 30
figure ||| 20
figure ||| 80
figure ||| 70
figure ||| 60
figure ||| 50
figure ||| 40
figure ||| 30
figure ||| 20
figure ||| ( 600 nodes )
figure ||| 0	5	10	15	20	25	30	35	40	45	50
figure ||| Number of Packet-Dropping Nodes
figure ||| 0	10	20	30	40	50	60	70	80	90	100
figure ||| Number of Packet-dropping Nodes
figure ||| (c) The number of relaying nodes with N = 300
figure ||| (d) The number of relaying nodes with N = 600
figure ||| ( 300 nodes )
figure ||| 0.6
figure ||| 0.5
figure ||| 0.4
figure ||| 1
figure ||| 0.9
figure ||| 0.8
figure ||| 0.7
figure ||| 0.3
figure ||| 0.2
figure ||| 0.1
figure ||| 0
figure ||| 1
figure ||| 0.9
figure ||| 0.8
figure ||| 0.7
figure ||| 0.6
figure ||| 0.5
figure ||| 0.4
figure ||| 0.3
figure ||| 0.2
figure ||| 0.1
figure ||| 0
figure ||| ( 600 nodes )
figure ||| Single Path Forwarding	with NWS
figure ||| Single Path Forwarding	with NWS
figure ||| Single Path Forwarding	with NWS
figure ||| Single Path Forwarding	with NWS
bodyText ||| We use the typical TinyOS beaconing [17] with a little
bodyText ||| modification as a base routing protocol in our simulations.
bodyText ||| We add a hop count value in a beacon message9. To have
bodyText ||| multiple potential next-hops, when receiving a beacon with
bodyText ||| the same or better hop count than the parent node’s, each
bodyText ||| node marks the node sending the beacon as a potential next-
bodyText ||| hop.
bodyText ||| Each simulation experiment is conducted using 100 differ-
bodyText ||| ent network topologies, and each result is averaged over 100
bodyText ||| runs of different network topologies.
subsubsectionHeader ||| 4.5.2 Simulation Results
bodyText ||| In the presence of compromised node dropping all the re-
bodyText ||| laying packets, we measure the success ratio (i.e. the per-
bodyText ||| centage of the packets that successfully reach the base sta-
bodyText ||| tion from the source) and the number of relaying nodes by
bodyText ||| the primitive single-path forwarding and with NWS in a
bodyText ||| network of size N, with N = 300 and 600.
footnote ||| 9The base station initiates the beacon-broadcasting, which
footnote ||| floods through the network, in order to set up a routing tree.
bodyText ||| Figure 6(a) shows the success ratio in face of x packet-
bodyText ||| dropping nodes (varying x=0 to 50) in a 300-sensor-node
bodyText ||| network with the approximate degree d = 10. Although
bodyText ||| the success ratio gently decreases with x, it keeps up above
bodyText ||| 0.8 even with x = 30, with the help of NWS. This ten-
bodyText ||| dency of decreasing success ratio can be attributed to the
bodyText ||| degree d = 10 (3.6 sub-watch nodes on average) as well as
bodyText ||| an increasing number of packet-dropping nodes. Due to the
bodyText ||| strategically-placement of compromised nodes in our sim-
bodyText ||| ulations, as x increases on, it is likely that a forwarding
bodyText ||| node’s all potential sub-watch nodes themselves are packet-
bodyText ||| dropping nodes. Figure 6(c) shows the number of nodes
bodyText ||| that relay the packet from the source to the base station
bodyText ||| in the same experiments. Since the source is located about
bodyText ||| 18 hops away from the base station, the number of relaying
bodyText ||| nodes only with the single-path forwarding remains at 18.
bodyText ||| With NWS, the number of relaying nodes increases with x,
bodyText ||| in order to bypass an increasing number of packet-dropping
bodyText ||| nodes. In face of such nodes, our scheme converts single-
bodyText ||| path forwarding into multipath data forwarding, with the
page ||| 67
bodyText ||| help of sub-watch nodes around such packet-dropping nodes.
bodyText ||| Utilizing a cache for recently-received packets can suppress
bodyText ||| the same copy within a certain timeout, which reduces the
bodyText ||| number of relaying nodes.
bodyText ||| Figure 6(b) shows the success ratio in a 600-sensor-node
bodyText ||| network with the approximate degree d = 20 with x packet-
bodyText ||| dropping nodes (varying x=0 to 100). Unlike that with N =
bodyText ||| 300, the success ratio stays constantly at around 0.99 even
bodyText ||| with x = 100, with the help of NWS. This tendency of high
bodyText ||| success ratio can be mainly attributed to the degree d = 20
bodyText ||| (7.6 sub-watch nodes on average in the lower bound case),
bodyText ||| which is found to be high enough to bypass a large number
bodyText ||| of packet-dropping nodes. Figure 6(d) shows the number
bodyText ||| of relaying nodes from the source to the base station in the
bodyText ||| same experiments. With NWS, the increase in the number
bodyText ||| of relaying nodes with x is more conspicuous than that with
bodyText ||| N = 300, since more than twice as many as sub-watch nodes
bodyText ||| help forward the packets so that it can bypass a large number
bodyText ||| of packet-dropping nodes anyway.
bodyText ||| In the simulation results, we note that our forwarding
bodyText ||| scheme dynamically adjusts its forwarding style, depending
bodyText ||| on the number of packet-dropping nodes en-route to the base
bodyText ||| station. As in Figures 6(c) and 6(d), while there exist none
bodyText ||| or a small number of packet-dropping nodes on the way, our
bodyText ||| scheme works almost like the single-path forwarding with
bodyText ||| the help of a few additional relaying nodes. On the other
bodyText ||| hand, when confronting a large number of packet-dropping
bodyText ||| nodes, our scheme makes full use of the help from additional
bodyText ||| relaying nodes, in order to successfully deliver the packet to
bodyText ||| the base station at any cost to the best efforts.
sectionHeader ||| 5. CONCLUSIONS AND FUTURE WORK
bodyText ||| In this paper we focus on defending against compromised
bodyText ||| nodes’ dropping of legitimate reports. We have presented
bodyText ||| a resilient packet-forwarding scheme using Neighbor Watch
bodyText ||| System (NWS) against maliciously packet-dropping nodes in
bodyText ||| sensor networks. In face of such nodes, NWS is specifically
bodyText ||| designed for hop-by-hop reliable delivery, and the prompt
bodyText ||| reaction of the conversion from single-path to multipath for-
bodyText ||| warding augments the robustness in our scheme so that the
bodyText ||| packet successfully reach the base station.
bodyText ||| In future work, we plan on further improving NLV to de-
bodyText ||| fend against the man-in-the-middle attacks, collusion among
bodyText ||| compromised nodes. Such attacks can be prevented by using
bodyText ||| a master key derived with not only a node ID but also its
bodyText ||| geographic information. We will also seek to address O(d 2)
bodyText ||| storage requirement for the neighbors’ neighbor lists. Fi-
bodyText ||| nally, we would like to perform an intensive experimental
bodyText ||| evaluation to compare our scheme with other reliable deliv-
bodyText ||| ery protocols [10, 29, 42].
sectionHeader ||| 6. ACKNOWLEDGMENTS
bodyText ||| This work was supported by grant No.R01-2006-000-10073-
bodyText ||| 0 from the Basic Research Program of the Korea Science and
bodyText ||| Engineering Foundation.
sectionHeader ||| 7. REFERENCES
reference ||| [1] R. Anderson, H. Chan, and A. Perrig, Key Infection:
reference ||| Smart Trust for Smart Dust, IEEE ICNP 2004
reference ||| [2] Burton H. Bloom, Space/Time Trade-offs in Hash
reference ||| Coding with Allowable Errors, Communication of the
reference ||| ACM, vol. 13, 422-426, 1970
reference ||| [3] B. Carbunar, I. Ioannidis, and C. Nita-Rotaru,
reference ||| JANUS: Towards Robust and Malicious Resilient
reference ||| Routing in Hybrid Wireless Networks, ACM workshop
reference ||| on Wireless security (WiSe’04), Oct. 2004
reference ||| [4] H. Chan, A. Perrig, and D. Song, Random Key
reference ||| Predistribution Schemes for Sensor Networks, IEEE
reference ||| Symposium on Security and Privacy, pp. 197-213, May
reference ||| 2003.
reference ||| [5] B. Deb, S. Bhatnagar, and B. Nath, ReInForM:
reference ||| Reliable Information Forwarding Using Multiple Paths
reference ||| in Sensor Networks, IEEE Local Computer Networks
reference ||| (LCN 2003), pp. 406-415, Oct. 2003.
reference ||| [6] J. Deng, R. Han, and S. Mishra, A Performance
reference ||| Evaluation of Intrusion- Tolerant Routing in Wireless
reference ||| Sensor Networks, 2nd International Workshop on
reference ||| Information Processing in Sensor Networks (IPSN 03),
reference ||| pp. 349-364, Apr. 2003.
reference ||| [7] J. Deng, R. Han, and S. Mishra, Intrusion Tolerance
reference ||| and Anti-Traffic Analysis Strategies for Wireless
reference ||| Sensor Networks, IEEE International Conference on
reference ||| Dependable Systems and Networks (DSN), pp.
reference ||| 594-603, 2004.
reference ||| [8] J. Deng, R. Han, and S. Mishra, Defending against
reference ||| Path-based DoS Attacks in Wireless Sensor Networks,
reference ||| ACM Workshop on Security of Ad-Hoc and Sensor
reference ||| Networks (SASN’05) , Nov, 2005.
reference ||| [9] K. Fall and K. Varadhan (editors), NS notes and
reference ||| documentation, The VINT project, LBL, Feb 2000,
reference ||| http://www.isi.edu/nsnam/ns/
reference ||| [10] D. Ganesan, R. Govindan, S. Shenker, and D. Estrin,
reference ||| Highly Resilient, Energy-Efficient Multipath Routing
reference ||| in Wireless Sensor Networks, Computing and
reference ||| Communications Review (MC2R) Vol 1., pp. 11-25,
reference ||| 2002.
reference ||| [11] V. D. Gligor, Security of Emergent Properties in
reference ||| Ad-Hoc Networks, International Workshop on Security
reference ||| Protocols, Apr. 2004.
reference ||| [12] O. Goldreich, S. Goldwasser, and S. Micali, How to
reference ||| Construct Random Functions, Journal of the ACM,
reference ||| Vol. 33, No. 4, 210-217, 1986
reference ||| [13] L. Eschenauer and V. D. Gligor, A Key-Management
reference ||| Scheme for Distributed Sensor Networks, 9th ACM
reference ||| Conference on Computer and Communication
reference ||| Security (CCS), pp. 41-47, Nov. 2002.
reference ||| [14] C. Hartung, J. Balasalle, and R. Han, Node
reference ||| Compromise in Sensor Networks: The Need for Secure
reference ||| Systems, Technical Report CU-CS-990-05,
reference ||| Department of Computer Science University of
reference ||| Colorado at Boulder, Jan. 2005
reference ||| [15] T. He, S. Krishnamurthy, J. A. Stankovic, T. F.
reference ||| Abdelzaher, L. Luo, R. Stoleru, T. Yan, L. Gu, J. Hui,
reference ||| and B. Krogh, An Energy-Efficient Surveillance
reference ||| System Using Wireless Sensor Networks, ACM
reference ||| MobiSys’04, June, 2004
reference ||| [16] W.R. Heinzelman, J. Kulik, H. Balakrishnan, Adaptive
reference ||| Protocols for Information Dissemination in Wireless
reference ||| Sensor Networks, ACM MobiCom99, pp. 174.185,
reference ||| 1999.
reference ||| [17] J. Hill, R. Szewczyk, A. Woo, S. Hollar, D. Culler, and
reference ||| K. Pister, System Architecture Directions for
reference ||| Networked Sensors, ACU ASPLOS IX, November
reference ||| 2000.
page ||| 68
reference ||| [18] X. Hong, M. Gerla, W. Hanbiao, and L. Clare, Load
reference ||| Balanced, Energy-Aware Communications for Mars
reference ||| Sensor Networks, IEEE Aerospace Conference, vol.3,
reference ||| 1109-1115, 2002.
reference ||| [19] Y.-C. Hu, D. B. Johnson, and A. Perrig, SEAD:
reference ||| Secure Efficient Distance Vector Routing for Mobile
reference ||| Wireless Ad Hoc Networks, IEEE Workshop on Mobile
reference ||| Computing Systems and Applications, pp. 3-13, Jun.
reference ||| 2002.
reference ||| [20] Y.-C. Hu, A. Perrig, and D. B. Johnson, Efficient
reference ||| Security Mechanisms for Routing Protocols, NDSS
reference ||| 2003, pp. 57-73, Feb. 2003.
reference ||| [21] C. Intanagonwiwat, R. Govindan and D. Estrin,
reference ||| Directed Diffusion: A Scalable and Robust
reference ||| Communication Paradigm for Sensor Networks,
reference ||| MobiCom’00, Aug. 2000.
reference ||| [22] D. Johnson, D.A. Maltz, and J. Broch, The Dynamic
reference ||| Source Routing Protocol for Mobile Ad Hoc Networks
reference ||| (Internet-Draft), Mobile Ad-hoc Network (MANET)
reference ||| Working Group, IETF, Oct. 1999.
reference ||| [23] C. Karlof and D. Wagner, Secure Routing in Wireless
reference ||| Sensor Networks: Attacks and Countermeasures, The
reference ||| First IEEE International Workshop on Sensor Network
reference ||| Protocols and Applications, pp. 113-127, May 2003
reference ||| [24] C. Karlof, N. Sastry, and D. Wagner, TinySec: A Link
reference ||| Layer Security Architecture for Wireless Sensor
reference ||| Networks, ACM SensSys’04, pp. 162-175, Nov. 2004.
reference ||| [25] I. Khalil, S. Bagchi, and C. Nina-Rotaru, DICAS:
reference ||| Detection, Diagnosis and Isolation of Control Attacks
reference ||| in Sensor Networks, IEEE SecureComm 2005, pp. 89 -
reference ||| 100, Sep. 2005
reference ||| [26] Y. Liu and W. K.G. Seah, A Priority-Based
reference ||| Multi-Path Routing Protocol for Sensor Networks,
reference ||| 15th IEEE International Symposium on Volume 1, 216
reference ||| -220, 2004
reference ||| [27] S.-B. Lee and Y.-H. Choi, A Secure Alternate Path
reference ||| Routing in Sensor Networks, Computer
reference ||| Communications (2006),
reference ||| doi:10.1016 /j . comcom.2006.08.006.
reference ||| [28] S. Marti, T.J. Giuli, K. Lai, and M. Baker, Mitigating
reference ||| Routing Misbehavior in Mobile Ad Hoc Networks,
reference ||| ACM/IEEE International Conference on Mobile
reference ||| Computing and Networking, pp. 255-265, 2000
reference ||| [29] H. Morcos, I. Matta, and A. Bestavros, M2 RC:
reference ||| Multiplicative-Increase/Additive-Decrease Multipath
reference ||| Routing Control for Wireless Sensor Networks, ACM
reference ||| SIGBED Review, Vol. 2, Jan 2005.
reference ||| [30] J. Newsome, E. Shi, D. Song, and A. Perrig, The Sybil
reference ||| Attack in Sensor Networks: Analysis and Defenses,
reference ||| IEEE IPSN’04, pp. 259-268, Apr. 2004.
reference ||| [31] B. Parno, A. Perrig, and V. D. Gligor, Distributed
reference ||| Detection of Node Replication Attacks in Sensor
reference ||| Networks, the 2005 IEEE Symposium on Security and
reference ||| Privacy, pp. 49-63, May 2005.
reference ||| [32] A. Perrig, R. Szewczyk, V. Wen, D. Culler, and
reference ||| J. Tygar, SPINS: Security Protocols for Sensor
reference ||| Networks, ACM MobiCom’01, pp. 189-199, 2001.
reference ||| [33] A. Perrig, J. Stankovic, and D. Wagner, Security in
reference ||| Wireless Sensor Networks, Communications of the
reference ||| ACM, 47(6), Special Issue on Wireless sensor
reference ||| networks, pp.53- 57, Jun. 2004
reference ||| [34] B. Przydatek, D. Song, and A. Perrig, SIA: Secure
reference ||| Information Aggregation in Sensor Networks, 1st
reference ||| International Conference on Embedded Networked
reference ||| Sensor Systems, 255-256, 2003
reference ||| [35] E. Shi and A. Perrig, Designing Secure Sensor
reference ||| Networks, Wireless Communications, IEEE Volume
reference ||| 11, Issue 6, pp. 38-43, Dec. 2004.
reference ||| [36] D. Tian and N.D. Georganas, Energy Efficient
reference ||| Routing with Guaranteed Delivery in Wireless Sensor
reference ||| Networks, IEEE Wireless Communications and
reference ||| Networking (WCNC 2003), IEEE Volume 3, 1923 -
reference ||| 1929, March 2003
reference ||| [37] A. Woo, T. Tong, and D. Culler, Taming the
reference ||| Underlying Challenges of Reliable Multhop Routing in
reference ||| Sensor Networks, ACM SenSys03, Nov, 2003
reference ||| [38] A. Wood and J. Stankovic, Denial of Service in Sensor
reference ||| Networks, IEEE Computer, Vol.35, 54-62, Oct. 2002
reference ||| [39] H.Yang, F. Ye, Y. Yuan, S. Lu and W. Arbough,
reference ||| Toward Resilient Security in Wireless Sensor
reference ||| Networks, ACM MobiHoc’05, 34-45, May 2005
reference ||| [40] Y. Yang, X. Wang, S. Zhu, and G. Cao SDAP: A
reference ||| Secure Hop-by-Hop Data Aggregation Protocol for
reference ||| Sensor Networks, ACM MobiHoc’06 May 2006
reference ||| [41] F. Ye, H. Luo, S. Lu and L. Zhang, Statictial En-route
reference ||| Filtering of Injected False Data in Sensor Networks,
reference ||| IEEE INFOCOM, 2004
reference ||| [42] F. Ye, G. Zhong, S. Lu and L. Zhang, GRAdient
reference ||| Broadcast: A Robust Data Delivery Protocol for Large
reference ||| Scale Sensor Networks, ACM Wireless Networks
reference ||| (WINET), March 2005
reference ||| [43] Y. Yu, R. Govindan, and D. Estrin, Geographical and
reference ||| Energy Aware Routing: a recursive data dissemination
reference ||| protocol for wireless sensor networks, UCLA
reference ||| Computer Science Department Technical Report
reference ||| UCLA/CSD-TR-01-0023, May 2001.
reference ||| [44] W. Zhang and G. Cao, Group Rekeying for Filtering
reference ||| False Data in Sensor Networks: A Predistribution and
reference ||| Local Collaboration-Based Approach, IEEE
reference ||| INFOCOM’05. Vol. 1, 503-514, March 2005
reference ||| [45] G. Zhou, T. He, S. Krishnamurthy, and J. A.
reference ||| Stankovic, Impact of radio irregularity on wireless
reference ||| sensor networks, the 2nd International Conference on
reference ||| Mobile Systems, Applications, and Services
reference ||| (MobiSys04), June, 2004
reference ||| [46] S. Zhu, S. Setia, and S. Jajodia, LEAP: Efficient
reference ||| Security Mechanisms for Large-Scale Distributed
reference ||| Sensor Networks, The 10th ACM Conference on
reference ||| Computer and Communications Security (CCS ’03),
reference ||| 62-72, 2003
reference ||| [47] S.Zhu, S. Setia, S. Jajodia, and P. Ning, An
reference ||| Interleaved Hop-by-Hop Authentication Scheme for
reference ||| Filtering False Data in Sensor Networks, IEEE
reference ||| Symposium on Security and Privacy, 2004
page ||| 69
