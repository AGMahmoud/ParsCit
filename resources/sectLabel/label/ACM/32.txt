title ||| An expressive aspect language for system applications
title ||| with Arachne
author ||| R´emi Douence, Thomas Fritz, Nicolas Loriant,
author ||| Jean-Marc Menaud, Marc S´egura-Devillechaise, Mario S¨udholt
affiliation ||| OBASCO project
affiliation ||| ´Ecole des Mines de Nantes/INRIA
address ||| 4 rue Alfred Kastler
address ||| 44307 Nantes Cedex 3, France
email ||| {douence,tfritz,nloriant,jmenaud,msegura,sudholt}@emn.fr
sectionHeader ||| ABSTRACT
bodyText ||| C applications, in particular those using operating system
bodyText ||| level services, frequently comprise multiple crosscutting con-
bodyText ||| cerns: network protocols and security are typical examples
bodyText ||| of such concerns. While these concerns can partially be ad-
bodyText ||| dressed during design and implementation of an application,
bodyText ||| they frequently become an issue at runtime, e.g., to avoid
bodyText ||| server downtime. A deployed network protocol might not be
bodyText ||| efficient enough and may thus need to be replaced. Buffer
bodyText ||| overflows might be discovered that imply critical breaches in
bodyText ||| the security model of an application. A prefetching strategy
bodyText ||| may be required to enhance performance.
bodyText ||| While aspect-oriented programming seems attractive in
bodyText ||| this context, none of the current aspect systems is expres-
bodyText ||| sive and efficient enough to address such concerns. This
bodyText ||| paper presents a new aspect system to provide a solution to
bodyText ||| this problem. While efficiency considerations have played
bodyText ||| an important part in the design of the aspect language, the
bodyText ||| language allows aspects to be expressed more concisely than
bodyText ||| previous approaches. In particular, it allows aspect pro-
bodyText ||| grammers to quantify over sequences of execution points as
bodyText ||| well as over accesses through variable aliases. We show how
bodyText ||| the former can be used to modularize the replacement of net-
bodyText ||| work protocols and the latter to prevent buffer overflows.
bodyText ||| We also present an implementation of the language as an
bodyText ||| extension of Arachne, a dynamic weaver for C applications.
bodyText ||| Finally, we present performance evaluations supporting that
bodyText ||| Arachne is fast enough to extend high performance applica-
bodyText ||| tions, such as the Squid web cache.
sectionHeader ||| Keywords
keyword ||| aspect language, sequence pointcut, dynamic weaving, sys-
keyword ||| tem applications
copyright ||| Permission to make digital or hard copies of all or part of this work for
copyright ||| personal or classroom use is granted without fee provided that copies are
copyright ||| not made or distributed for profit or commercial advantage and that copies
copyright ||| bear this notice and the full citation on the first page. To copy otherwise, to
copyright ||| republish, to post on servers or to redistribute to lists, requires prior specific
copyright ||| permission and/or a fee.
note ||| AOSD 05 Chicago Illinois USA
copyright ||| Copyright 2005 ACM 1-59593-042-6/05/03 ...$ 5.00.
sectionHeader ||| 1. INTRODUCTION
bodyText ||| Real-world applications typically comprise multiple cross-
bodyText ||| cutting concerns. This applies, in particular, to C applica-
bodyText ||| tions using operating system level services. We have exam-
bodyText ||| ined three concerns which are typical for this domain in the
bodyText ||| context of a large application, the open source web cache
bodyText ||| Squid [36]. More concretely, we have considered translation
bodyText ||| of network protocols (which may be necessary for efficiency
bodyText ||| reasons), insertion of checks for buffer overflows (which are
bodyText ||| at the heart of many of today’s security issues), and in-
bodyText ||| troduction of prefetching strategies within the cache (which
bodyText ||| can be used to enhance efficiency of the web cache). We
bodyText ||| have found that all these concerns are scattered over large
bodyText ||| portions of the code of Squid.
bodyText ||| Hence, the three concerns are crosscutting in the sense
bodyText ||| of Aspect-Oriented Programming (AOP) [24] and aspects
bodyText ||| should therefore be a means of choice for their modular-
bodyText ||| ization. The concerns have three important characteristics.
bodyText ||| First, they must frequently be applied at runtime, e.g., in
bodyText ||| order to rapidly fix a buffer overflow and thus prevent secu-
bodyText ||| rity breaches without incurring server downtime. A dynamic
bodyText ||| aspect weaver is therefore needed. Second, they expose in-
bodyText ||| tricate relationships between execution points, e.g., network
bodyText ||| protocols are most concisely expressed in terms of sequences
bodyText ||| of execution points, not individual ones. The aspect system
bodyText ||| must therefore support expressive means for the definition of
bodyText ||| aspects, in particular pointcuts. Third, efficiency is crucial
bodyText ||| in the application domain we consider.
bodyText ||| To our knowledge, none of the current aspect systems for
bodyText ||| C meet these three requirements and is suitable for the mod-
bodyText ||| ularization of such concerns. Moreover, requirements for
bodyText ||| dynamic weaving and efficiency often trade off with expres-
bodyText ||| sivity. Squid should be as efficient as possible and therefore
bodyText ||| exploit any suitable operating system and hardware partic-
bodyText ||| ularity. Its code base is therefore difficult to understand and
bodyText ||| manipulate, thus hindering in particular modularization ef-
bodyText ||| forts. It is therefore highly questionable that the considered
bodyText ||| modularization problems can be solved without aspects.
bodyText ||| In this paper we propose a solution to the aspectization of
bodyText ||| such concerns of C applications. More concretely, we provide
bodyText ||| three main contributions. First, we provide a new expressive
bodyText ||| aspect language featuring a construct for quantification over
bodyText ||| sequences of execution points as well as over accesses to lo-
bodyText ||| cal aliases of global variables. We show how this aspect lan-
page ||| 27
bodyText ||| guage permits concise expression of the considered concerns
bodyText ||| as aspects. Second, we present how the aspect language can
bodyText ||| be implemented efficiently through runtime weaving into bi-
bodyText ||| nary code. Concretely, this is done by integrating the aspect
bodyText ||| language into our tool Arachne, a dynamic weaver for C ap-
bodyText ||| plications. Furthermore, we present how Arachne improves
bodyText ||| on our previous work µDyner [32]. Finally, we give evidence
bodyText ||| that our approach meets strong efficiency requirements by
bodyText ||| showing performance evaluations in the context of Squid.
bodyText ||| The paper is structured as follows. Section 2 presents the
bodyText ||| motivating concerns we identified within Squid. Section 3
bodyText ||| shows how to modularize these concerns as aspects and de-
bodyText ||| fines our aspect language. Section 4 describes its implemen-
bodyText ||| tation within Arachne. Section 5 assesses the performance
bodyText ||| of our implementation. Section 6 describes related work.
bodyText ||| Section 7 concludes and suggests futures work.
sectionHeader ||| 2. MOTIVATIONS
bodyText ||| Legacy C applications involve multiple crosscutting con-
bodyText ||| cerns. Many of them remain challenging, both in terms
bodyText ||| of expressiveness required to handle them properly in an
bodyText ||| aspect-oriented language and in terms of constraints posed
bodyText ||| on the weaver. This section describes three such concerns
bodyText ||| in C applications: switching the network protocol, buffer
bodyText ||| overflows and prefetching. The network protocol concern is
bodyText ||| typically scattered through the entire application. It is an
bodyText ||| issue when administrators discover at runtime that the re-
bodyText ||| tained protocol is not efficient enough. Likewise the security
bodyText ||| threats posed by buffer overflows is a real concrete problem
bodyText ||| for administrators. While guarding all buffers against over-
bodyText ||| flows might decrease performance considerably, administra-
bodyText ||| tors are left with no other option than accepting the trade-
bodyText ||| off between security and performance chosen at application’s
bodyText ||| design time. Prefetching is another well-known crosscutting
bodyText ||| concern [12]. Since prefetching aims at increasing perfor-
bodyText ||| mance, prefetching aspects make only sense with an efficient
bodyText ||| weaver. Yet, it is still difficult to modularize these three con-
bodyText ||| cerns in today’s aspect-oriented language. In this section,
bodyText ||| we first describe the context in which the concerns arise be-
bodyText ||| fore showing their crosscutting nature and finally explaining
bodyText ||| the lack in current aspect-oriented languages to handle them
bodyText ||| properly.
subsectionHeader ||| 2.1 TCP to UDP protocol
bodyText ||| HTTP was essentially designed as a file transfer proto-
bodyText ||| col running on top of TCP, a connection-oriented protocol
bodyText ||| ensuring communication reliability. While the average Web
bodyText ||| page size does not exceed 8 KB [4], the cost of retrieving
bodyText ||| a Web page is often dominated by data exchanged for con-
bodyText ||| trol purposes of TCP rather than by the page content itself.
bodyText ||| This is not a new problem, many researches have already
bodyText ||| pointed out that TCP is not suitable for short-lived connec-
bodyText ||| tions. While HTTP 1.1 has introduced persistent connec-
bodyText ||| tions allowing a client to retrieve multiple pages from the
bodyText ||| same server through the same TCP connection, the number
bodyText ||| of simultaneous TCP connections is limited by operating
bodyText ||| systems. Servers have a strong incentive to close HTTP
bodyText ||| connections as soon as possible. Hence, despite the per-
bodyText ||| sistent connection mechanism, many studies conclude that
bodyText ||| TCP should be replaced by UDP to retrieve short pages [10,
bodyText ||| 29, 7]. In spite of its performance improvements, the number
bodyText ||| of legacy Web applications has prevented a wide adoption
bodyText ||| of this solution. Typical legacy Web applications have to be
figureCaption ||| Figure 1: Typical usage of the TCP and UDP APIs.
bodyText ||| stopped to switch the protocol. The traditional approach
bodyText ||| to avoid depriving a subnetwork from Internet connectivity
bodyText ||| while stopping the cache is to swap the application between
bodyText ||| different machines. This approach is not only expensive in
bodyText ||| terms of hardware, it complicates the administrative task of
bodyText ||| the Web cache administrator and poses the problem of con-
bodyText ||| sistently transferring the runtime state of the application
bodyText ||| before restarting it. Stopping an e-commerce Web server
bodyText ||| means a loss of money and many small companies can not
bodyText ||| afford the cost of redundant servers. For a wide acceptance,
bodyText ||| a HTTP dialect using UDP as transport protocol should
bodyText ||| thus be deployable on demand at runtime.
bodyText ||| In addition, replacing TCP by UDP in an application is
bodyText ||| relatively difficult. The choice of a transport protocol is
bodyText ||| usually based on standards believed to be ever-lasting and
bodyText ||| made at an early design stage. Hence no particular effort is
bodyText ||| made to localize this design decision in a single piece of code.
bodyText ||| For example, despite a modularization effort, the TCP API
bodyText ||| provided by the operating system is used directly in 7 of the
bodyText ||| 104 ” . c” source files of the Squid Web cache.
bodyText ||| As shown in Fig. 1, the TCP API is built around a set of
bodyText ||| C functions to be invoked sequentially by the application. In
bodyText ||| a properly written program, TCP functions are first used to
bodyText ||| establish the connection (typically with socket, connect,
bodyText ||| bind and listen), exchange data through the connection
bodyText ||| (typically with read and write) and then close it (typically
bodyText ||| close). UDP uses similar but less functions. UDP applica-
bodyText ||| tions first direct the operating system to dedicate the appro-
bodyText ||| priate resources to exchange data (typically with socket and
bodyText ||| bind), then exchange data through these resources (typically
bodyText ||| with sendto and recvfrom) before releasing them (typically
bodyText ||| with close). Hence, the problem is not only difficult be-
bodyText ||| cause TCP-related function invocations are scattered but
bodyText ||| because the relative order of each invocation is important in
bodyText ||| order to map it onto the appropriate UDP function.
bodyText ||| This example is typical of protocol based APIs. When
bodyText ||| such an API is used in an undisciplined way, it becomes
bodyText ||| quickly impossible to replace it by another one. Today,
bodyText ||| aspect-oriented systems lack an appropriate sequencing con-
bodyText ||| struct in their language. Moreover, many do not provide the
bodyText ||| ability to weave aspects dynamically.
subsectionHeader ||| 2.2 Buffer overflows
bodyText ||| In C, the size of an array is fixed at allocation time. Ac-
bodyText ||| cording to ISO and ANSI standards [2], an invalid array
bodyText ||| access does not result in an immediate error but leads to
bodyText ||| an implementation-dependent behavior. Such behavior is
bodyText ||| increasingly exploited by hackers to circumvent security re-
figure ||| TCP Protocol	Time	UDP Protocol
figure ||| Server Network Client	Server Network Client
figure ||| bind
figure ||| listen
figure ||| accept
figure ||| read
figure ||| write
figure ||| close
figure ||| socket
figure ||| connect
figure ||| write
figure ||| read
figure ||| close
figure ||| socket
figure ||| socket
figure ||| bind
figure ||| recvfrom
figure ||| sendto
figure ||| close
figure ||| socket
figure ||| recvfrom
figure ||| close
figure ||| sendto
page ||| 28
bodyText ||| strictions [37]. It is therefore crucial for C programmers to
bodyText ||| ensure every access to an array to be valid. On the other
bodyText ||| hand, bound checking code is error prone: it is easy to for-
bodyText ||| get to check an access and even when the access is checked,
bodyText ||| it is easy to compare the index locating the access with an
bodyText ||| inappropriate bound. Therefore, researchers have proposed
bodyText ||| to make compilers responsible for enforcing proper array ac-
bodyText ||| cess [22, 31]. The problem is that even the most efficient
bodyText ||| system (CRED [31]) slows down an application up to 130%.
bodyText ||| Moreover, most frequently used compilers like gcc do not
bodyText ||| support bound checking.
bodyText ||| Today, administrators discovering a buffer overflow in pro-
bodyText ||| duction software are left with no other option than stopping
bodyText ||| the application and restarting a bug free version. This was
bodyText ||| the solution chosen when a buffer overflow was discovered
bodyText ||| in Squid in [6]. While widely used, this solution suffers from
bodyText ||| three major drawbacks. First, it does not enforce continuous
bodyText ||| servicing since the service delivered by the application is not
bodyText ||| available during the update. Second, this solution entails an
bodyText ||| important information loss: an administrator has no means
bodyText ||| to learn whether the buffer overflow has been exploited by
bodyText ||| a hacker or not. Third, it misunderstands the performance
bodyText ||| trade-off, i.e. it is not necessary to check every array access,
bodyText ||| it is only necessary to perform enough checking to discour-
bodyText ||| age hackers. Therefore, bound checking code should only
bodyText ||| run when an environment becomes hostile [23].
bodyText ||| Bound checking code tends to crosscut the entire applica-
bodyText ||| tion. For example, properly written C functions accepting
bodyText ||| an array argument commonly take a second argument hold-
bodyText ||| ing the array size: the first one allows the function to access
bodyText ||| the array while the second is used to ensure correctness of
bodyText ||| accesses. In Squid, bound checking code can be found in
bodyText ||| any of the 104 ” . c” files of its source code. On the 57635
bodyText ||| lines composing these ” . c” files, at least 485 check bounds.
bodyText ||| This problem fails to be handled properly in current as-
bodyText ||| pect languages as they lack the ability to trigger advices
bodyText ||| upon access made through the alias of a variable. Again,
bodyText ||| many aspect-oriented systems offer only static weaving ca-
bodyText ||| pabilities preventing the administrator to choose the trade-
bodyText ||| off security/performance suiting his needs.
subsectionHeader ||| 2.3 From fetching to prefetching
bodyText ||| Operations like retrieving a file on a local disk or over the
bodyText ||| Web can be sped up if the underlying software anticipates
bodyText ||| user requests and start to fetch documents beforehand. Such
bodyText ||| prefetching schemes distinguish themselves from each other
bodyText ||| in the way they predict future user requests. These ”ora-
bodyText ||| cles” actually prevent a clean encapsulation of prefetching
bodyText ||| in a single module communicating with the rest of the appli-
bodyText ||| cation through well-defined interfaces since predictions are
bodyText ||| based on information meant to be private to other modules.
bodyText ||| In addition, it is very likely that there is no universal per-
bodyText ||| fect oracle [19]. A statically linked prefetching module is
bodyText ||| therefore inappropriate, but prefetching modules along with
bodyText ||| the necessary oracles should be loaded and unloaded on the
bodyText ||| fly. Due to their crosscutting nature, prefetching modules
bodyText ||| including such oracles are better written with aspects [32].
bodyText ||| Coady et al. have already pointed out the crosscutting
bodyText ||| nature of prefetching in the FreeBSD OS [12]. In our pre-
bodyText ||| vious work considering the Squid Web cache, we reached a
bodyText ||| similar conclusion [32]. We have previously shown that this
bodyText ||| concern can be addressed with cflow-like constructs.
bodyText ||| Despite potential performance improvements, prefetching
bodyText ||| also increases resource consumption (e.g. network prefetch-
bodyText ||| ing consumes local storage and bandwidth). When the pres-
bodyText ||| sure on resources is too high, prefetching computation com-
bodyText ||| petes for them against regular user requests, and slows down
bodyText ||| their treatment instead of speeding it up. In such cases,
bodyText ||| prefetching should therefore be, temporarily, disabled. Squid
bodyText ||| essentially manages file descriptors, a resource only available
bodyText ||| in a limited quantity. A file descriptor is used between the
bodyText ||| underlying operating system and applications to describe a
bodyText ||| network connection or a file on the disk. Squid’s file descrip-
bodyText ||| tor management is based on a global variable that tracks the
bodyText ||| number of file descriptors currently in use. By comparing
bodyText ||| its value with the maximum number of file descriptors al-
bodyText ||| lowed by the operating system, it is possible to estimate that
bodyText ||| prefetching should be disabled or resumed.
bodyText ||| For this problem of file descriptor consumption, the cur-
bodyText ||| rent practice of checking if prefetching should be disabled or
bodyText ||| not within the advice, is a bad practice that impedes both
bodyText ||| readability and maintainability. A mechanism is needed
bodyText ||| within the aspect language to restraint the advice execu-
bodyText ||| tion at times where the pressure on resources is too high.
bodyText ||| This problem were not addressed in our previous work.
sectionHeader ||| 3. AN EXPRESSIVE ASPECT LANGUAGE
sectionHeader ||| FOR SYSTEM PROGRAMMING IN C
bodyText ||| While AOP seems to be the obvious choice to tackle the
bodyText ||| crosscutting concerns introduced above, none of the existing
bodyText ||| AO systems provides explicit support for some of their es-
bodyText ||| sential elements, in particular, join point sequences for pro-
bodyText ||| tocols, and references to aliases which are local to a function.
bodyText ||| In this section we introduce a new aspect language for
bodyText ||| system programming in C that allows such crosscutting con-
bodyText ||| cerns to be expressed concisely. In order to make this point,
bodyText ||| we first revisit the examples by concisely aspectizing them
bodyText ||| using our language. (Note that our aspect language is ex-
bodyText ||| pressive in the sense of enabling the concise definition of cer-
bodyText ||| tain types of aspects, especially compared to other tools for
bodyText ||| system-level manipulations, but not necessarily more expres-
bodyText ||| sive than existing approaches in a language-theoretic sense.)
bodyText ||| We then define the join point model underlying our language
bodyText ||| precisely, followed by the definition of its syntax and infor-
bodyText ||| mal semantics. Finally, we illustrate how its semantics can
bodyText ||| be formally defined in terms of a small-step operational se-
bodyText ||| mantics using the framework introduced in [14].
subsectionHeader ||| 3.1 Example crosscutting concerns revisited
bodyText ||| We now revisit the concerns discussed in section 2 in order
bodyText ||| to show our language in action and give evidence that it
bodyText ||| allows such concerns to be concisely modularized.
bodyText ||| The aspect shown in Fig. 2 translates transport protocols
bodyText ||| from TCP to UDP. A protocol defines a sequence of func-
bodyText ||| tion calls, so the top-level operator of this aspect is seq.
bodyText ||| The sequence aspect syntactically consists of a list of pairs
bodyText ||| of pointcut and advice (separated by then). In the exam-
bodyText ||| ple, the TCP protocol starts with a call to socket() with
bodyText ||| three constant arguments: AF INET, SOCK STREAM and
bodyText ||| 0. When such a call is matched, the second parameter is
bodyText ||| replaced by SOCK DGRAM as required by the UDP proto-
bodyText ||| col. The result of this transformed call, the file descriptor,
bodyText ||| is bound to fd by return(fd). Then the next call to con-
bodyText ||| nect() with the same file descriptor fd as its first parameter
bodyText ||| is matched. In this case the values of the other parameters
page ||| 29
figure ||| seq( call(int socket(int, int, int)) &amp;&amp; args(AF INET, SOCK STREAM, 0) &amp;&amp; return(fd)
figure ||| then socket(AF INET, SOCK DGRAM, 0);
figure ||| call(int connect(int, struct socketaddr*, socklen t)) &amp;&amp; args(fd, address, length)
figure ||| then returnZero(); // where int returnZero() { return 0; }
figure ||| ( call(size t read(int, void*, size t)) &amp;&amp; args(fd, readBuffer, readLength)
figure ||| then recvfrom(fd, readBuffer, readLength, 0, address, length);
figure ||| 11call(size t write(int, void*, size t)) &amp;&amp; args(fd, writeBuffer, writeLength)
figure ||| then sendto(fd, writeBuffer, writeLength, 0, address, length);) *
figure ||| call(int close(int)) &amp;&amp; args(fd) ; )
figure ||| Figure 2: An Aspect for Switching Transport Protocols, from TCP to UDP
figure ||| seq( call(void * malloc(size t))
figure ||| &amp;&amp; args(allocatedSize) &amp;&amp; return(buffer) ;
figure ||| write(buffer) &amp;&amp; size(writtenSize)
figure ||| &amp;&amp; if(writtenSize &gt; allocatedSize)
figure ||| then reportOverflow(); *
figure ||| call(void free(void*)) )
figureCaption ||| Figure 3: An Aspect for Detecting Buffer Overflow
bodyText ||| are bound to arguments address and length, and the original
bodyText ||| call is replaced by returnZero(). Indeed, there is no connect
bodyText ||| step in the UDP protocol. After that, calls to read() and
bodyText ||| write() (using the ‘or’ on aspects: 11) on the same file de-
bodyText ||| scriptor fd are translated to UDP recvfrom() and sendto(),
bodyText ||| respectively. Note that sequences of such access are poten-
bodyText ||| tially translated (due to use of the repetition operator *).
bodyText ||| Finally, a call to close() on fd terminates the TCP protocol
bodyText ||| as well as the UDP protocol and thus is not modified (i.e.,
bodyText ||| there is no then clause). This last step is required to free
bodyText ||| the variables used in the sequence (here, fd, address and
bodyText ||| length). Indeed, this aspect can use numerous (instances of
bodyText ||| these) variables when it deals with interleaved sequences, as
bodyText ||| each call to socket() creates a new instance of the sequence.
bodyText ||| The aspect shown in Fig. 3 detects buffer overflows. The
bodyText ||| corresponding sequence starts when the function malloc()
bodyText ||| returns the buffer address which is then bound to buffer.
bodyText ||| Then, each time this address is accessed (through a global
bodyText ||| variable or a local alias) the size of the data to be written is
bodyText ||| compared with the size of the initially allocated memory. If
bodyText ||| the former exceeds the latter, an overflow is indicated. The
bodyText ||| sequence ends when the memory is deallocated using free().
bodyText ||| The aspect in Fig. 4 introduces prefetching in a web cache.
bodyText ||| The first controlf low phrase initializes prefetching when
bodyText ||| an HTTP response is built (clientBuildReply()) within the
bodyText ||| control flow of a client request (clientSendMoreData()). The
bodyText ||| until clause stops prefetching when the number of connec-
bodyText ||| tion becomes too large, a situation where prefetching would
bodyText ||| effectively degrade performance. The second controlf low
bodyText ||| phrase analyzes hyperlinks in a page being transmitted (i.e.,
bodyText ||| when comm write mbuf() is called within the control flow
bodyText ||| of clientSendMoreData()). Finally, the last call phrase pre-
bodyText ||| fetches hyperlinks analyzed by the second aspect. It does so
bodyText ||| by replacing the method call to clientWriteComplete() with
bodyText ||| retrieveHyperlinks(). Finally, note that the two require
bodyText ||| clauses at the top of the aspect declare the types of the
bodyText ||| global variables of the base program used in the aspects.
subsectionHeader ||| 3.2 Join points
bodyText ||| A join point model defines the points in the execution
bodyText ||| of the base program to which pointcuts may refer. In our
figure ||| JP::= callJP(valfunId( −→val))
figure ||| readGlobalJP(varId,val)
figure ||| readJP(@, val)
figure ||| writeGlobalJP(varId, val, size)
figure ||| writeJP(@, val, size)
figure ||| controlflowJP(−−−−→
figure ||| funId, cfEnd)
figure ||| controlflowstarJP(−−−−→
figure ||| funId, cfEnd)
figure ||| cfEnd::= callJP(val funId(−→val))
figure ||| 1readGlobalJP(varId,val)
figure ||| 1writeGlobalJP(varId, val, size)
figure ||| val::= 011121...	//int
figure ||| 1@0 1 @1 1 @2 1 ... // int*
figure ||| 1... // values of other C types
figureCaption ||| Figure 5: Join point model
bodyText ||| case, join points are defined by JP in the grammar shown
bodyText ||| in Fig. 5. A join point is either:
listItem ||| •	A call of a function callJP(v1 funId(−→v2)) with function
listItem ||| name funId, return value vi and a vector of arguments →−v2.
listItem ||| •	A read access which comes in two variants:
listItem ||| readGlobalJP(varId,v) denotes reading a global vari-
listItem ||| able with name varId holding the value v; readJP(@, v)
listItem ||| denotes reading a global variable or a local alias with
listItem ||| address @ holding the value v.
listItem ||| •	Write access which also comes in two variants:
listItem ||| writeGlobalJP(varId, v, size) denotes assignment to a global
listItem ||| variable with name varId of the value v of size size.
listItem ||| writeJP(@, v, size) denotes assignment to a global variable
listItem ||| or a local alias with address @ of the value v of size size.
listItem ||| •	A cflow expression controlflowJP( f Inu d, c), where
listItem ||| f Inu d = [funId1, .., funIda] is a stack of function names, and
listItem ||| c (either a function call or an access to a global variable) oc-
bodyText ||| curs within the body of function funId�. Such a join point
bodyText ||| requires a call to funId�+1 within the body of funId�.
listItem ||| •	A cflow expression controlflowstarJP( f unId, c), where
listItem ||| −−−−→
bodyText ||| f Inu d = [funId1, .., funIda] is a partial stack of function
bodyText ||| names, and c (either a function call or an access to a global
bodyText ||| variable) occurs within the control flow of function funId�.
bodyText ||| Such a join point requires a call to funId�+1 within the
bodyText ||| control flow of (i.e., not necessarily in the body of) funId�.
bodyText ||| Two features of this join point model may be surprising
bodyText ||| at first sight: distinction of accesses to aliases from those to
bodyText ||| global variables and explicit representation of control flow
page ||| 30
figure ||| require Number Of Fd as int*;
figure ||| require Squid MaxFd as int*;
figure ||| controlflow(call(void clientSendMoreData(void*, char*, size t)),
figure ||| call(HttpReply * clientBuildReply(clientHttpRequest*, char*, size t))
figure ||| &amp;&amp; args( request, buffer, buffer Size ))
figure ||| then startPrefetching(request, buffer, bufferSize);
figure ||| &amp;&amp; until(writeGlobal(int * Number Of Fd) &amp;&amp; if((*Number Of Fd) * 100/(*Squid MaxFd) ≥ 75) ; )
figure ||| controlflow( call(void clientSendMoreData(void*, char*, size t)),
figure ||| call(void comm write mbuf(int, MemBuf, void*, void*))
figure ||| &amp;&amp; args(fd, mb, handler, handlerData) &amp;&amp; if (! isPre f etch(handler)) )
figure ||| then parseHyperlinks(fd, mb, handler, handlerData);
figure ||| call(void clientWriteComplete(int, char*, size t, int, void*))
figure ||| &amp;&amp; args(fd, buf, size, error, data) &amp;&amp; if(! isPre f etch(handler))
figure ||| then retrieveHyperlinks(fd, buf, size, error, data);
figureCaption ||| Figure 4: An Aspect for Prefetching
bodyText ||| expressions. Both are motivated by our quest for efficiency
bodyText ||| and are grounded in strong implementation constraints in
bodyText ||| the context of dynamic weaving of binary C code: an access
bodyText ||| to a local alias is several magnitudes slower than that to a
bodyText ||| global variable and matching of control flow join points can
bodyText ||| be done using an atomic test on the implementation level.
subsectionHeader ||| 3.3 Pointcuts
bodyText ||| We now present a pointcut language (see Fig. 6) that pro-
bodyText ||| vides constructs to match individual join points.
bodyText ||| Primitive pointcuts are defined by PPrim and comprise
bodyText ||| three basic pointcuts matching calls, global variable accesses,
bodyText ||| and control flow join points. Primitive pointcuts can also be
bodyText ||| combined using a logical “or” noted I I.
bodyText ||| A call pointcut PCall selects all function call join points
bodyText ||| −→
bodyText ||| callJP(val funId(val)), i.e., all calls to a function matching
bodyText ||| the signature type funId(t pe), where the arguments of the
bodyText ||| function can be bound to pointcut variables using argument
bodyText ||| binder args( −−−−−→
bodyText ||| pattern ) and the return value can be bound to
bodyText ||| a pointcut variable using a return clause return( pattern ).
bodyText ||| The two constructs args( −−−−−→
bodyText ||| pattern ) and return( pattern )
bodyText ||| can also provide pattern matching by using values (or al-
bodyText ||| ready bound pointcut variables) in pattern. Pointcuts can
bodyText ||| also depend on a boolean condition using the if-constructor.
bodyText ||| A global access pointcut PAccGlobal selects either all read
bodyText ||| join points readGlobalJP(varId, val) or all write join points
bodyText ||| writ eGlobalJP(varId, val, size) on the global base program
bodyText ||| variable varId. In these cases, the read or written value can
bodyText ||| be bound to a variable using value(pattern); in addition, the
bodyText ||| size of the written value can be bound with size(varName).
bodyText ||| Pattern matching can also be used for variable access.
bodyText ||| A control flow pointcut PCf of the form controlflow(
bodyText ||| PCallSig1,..., PCallSign, PCfEnd) matches all join points
bodyText ||| of the form controlflowJP(funId1, ..., funIdn, cfEnd), where
bodyText ||| the function identifier in PCallSigi is funIdi. Similarly, a
bodyText ||| control flow pointcut may match a global variable access
bodyText ||| for a given stack configuration. The pointcuts of the form
bodyText ||| controlflowstar(... ) select calls or global variable accesses
bodyText ||| in a stack context allowing for calls that are not directly
bodyText ||| nested within one another.
bodyText ||| Finally, PAcc, an access pointcut for a global variable or
bodyText ||| all of its local aliases, matches all join points of the form
bodyText ||| readJP or writeJP.
figure ||| Asp::= AspPrim [ &amp;&amp; until( AspPrim) ]
figure ||| IAspSeq [ &amp;&amp; until( AspPrim ) ]
figure ||| AspPrim::= PPrim Advice
figure ||| AspSeq::= seq( AspPrim
figure ||| AspSeqElts
figure ||| AspSeqElt )
figure ||| AspSeqElts ::_ [AspSeqElts] AspSeqElt [ * ]
figure ||| AspSeqElt::= AspPrim
figure ||| IPAcc Advice
figure ||| I(AspSeqElt II AspSeqElt)
figure ||| Advice::= [ then funId(pat�) ] ;
figureCaption ||| Figure 7: Aspect language
subsectionHeader ||| 3.4 Aspect Language
bodyText ||| The aspect language we propose is defined in Fig. 7. As-
bodyText ||| pects Asp are either primitive AspPrim, or sequences of
bodyText ||| primitive aspects AspSeq.
bodyText ||| A primitive aspect AspPrim combines a primitive point-
bodyText ||| cut with an advice that will be applied to all join points
bodyText ||| selected by the pointcut. If the primitive pointcut has the
bodyText ||| form p1 II p2, then all variables used in the advice have to
bodyText ||| be bound in both, p1 and p2.
bodyText ||| An advice (Advice) is a C function call that replaces a join
bodyText ||| point in the base program execution (similarly to around in
bodyText ||| AspectJ). It must have the same return type as the join
bodyText ||| point it replaces: the type of the global variable in case of a
bodyText ||| read access, void for a write access and the return type of
bodyText ||| the function for a call. When the advice is empty (no then
bodyText ||| clause), the original join point is executed. The original join
bodyText ||| point can be skipped by calling an empty C function.
bodyText ||| A sequence aspect is composed of a sequence of primitive
bodyText ||| aspects. A sequence starts when the first primitive aspect
bodyText ||| matches. Then the second primitive aspect becomes active
bodyText ||| instead of the first one. When it matches, the third aspect
bodyText ||| becomes active instead of the second one. And so on, until
bodyText ||| the last primitive aspect in the sequence. All but the first
bodyText ||| and last primitive aspects can be repeated zero or multiple
bodyText ||| times by using *: in this case, the primitive aspect is ac-
page ||| 31
figure ||| PPrim	
figure ||| PCall	
figure ||| PCallSig	
figure ||| PIf	
figure ||| PAccGlobal	
figure ||| PCf	::=
figure ||| 1controlflowstar( PCallSigList, PCfEnd )
figure ||| PCallSigList ::= PCallSig [ , PCallSigList]
figure ||| PCall 1 PAccGlobal
figure ||| PCall
figure ||| 1PAccGlobal
figure ||| 1PCf
figure ||| 1PPrim11 PPrim
figure ||| ::=
figure ||| PCallSig [ &amp;&amp; args(−−−−−→
figure ||| pattern) ] [ &amp;&amp; return( pattern) ] [ &amp;&amp; PIf ]
figure ||| call( type funId(t pe) )
figure ||| if( expr ) [ &amp;&amp; PIf ]
figure ||| readGlobal( type varId) [ &amp;&amp; value( pattern) ] [ &amp;&amp; PIf ]
figure ||| 1writeGlobal( type varId) [ &amp;&amp; value( pattern) ] [ &amp;&amp; size( pattern) ] [ &amp;&amp; PIf ]
figure ||| ::=
figure ||| ::=
figure ||| ::=
figure ||| ::=
figure ||| controlflow( PCallSigList, PCfEnd )
figure ||| PCf End	::=
figure ||| PAcc	
figure ||| pattern	::=
figure ||| var 1 val
figure ||| read( var ) [ &amp;&amp; value(pattern ) ] [ &amp;&amp; PIf ]
figure ||| 1write( var ) [ &amp;&amp; value( pattern ) ] [ &amp;&amp; size( pattern) ] [ &amp;&amp; PIf ]
figure ||| ::=
figureCaption ||| Figure 6: Pointcut language
figure ||| A::= A&apos;
figure ||| 1A 11 A	; parallelism
figure ||| A&apos;::= µa.A&apos;	; recursive definition (a E Rec)
figure ||| 1C D I; A	; prefixing
figure ||| 1C D I; a	; end of sequence (a E Rec)
figure ||| 1C D I; STOP ; halting aspect
figure ||| 1A&apos; ❑ A&apos;	; choice
figureCaption ||| Figure 8: Tiny aspect language
bodyText ||| tive as long as the following one in the sequence does not
bodyText ||| match. Branching, i.e., a logical ‘or’ between two primitive
bodyText ||| aspects, can be introduced in a sequence by the operator 11.
bodyText ||| An element of the sequence can also match a global vari-
bodyText ||| able of the base program and accesses to its local aliases, as
bodyText ||| soon as its address is known (i.e., a previous primitive point-
bodyText ||| cut has already bound its address to a pointcut variable).
bodyText ||| Hence, an aspect matching accesses cannot start a sequence.
bodyText ||| Every join point matching the first primitive pointcut of a
bodyText ||| sequence starts a new instance of the sequence. The different
bodyText ||| instances are matched in parallel.
bodyText ||| A primitive or a sequence aspect a can be used in combi-
bodyText ||| nation with an expression until (a1 ), to restrict its scope. In
bodyText ||| this case, once a join point has been matched by a, the execu-
bodyText ||| tion of a proceeds as previously described until a1 matches.
bodyText ||| To conclude the presentation of our language, note that it
bodyText ||| does not include some features, such as named pointcuts as
bodyText ||| arguments to controlf lows and conjunctive terms, which
bodyText ||| are not necessary for the examples we considered but which
bodyText ||| could easily be added. (As an aside, note that such exten-
bodyText ||| sions of the pointcut language may affect the computability
bodyText ||| of advanced algorithmic problems, such as whether a point-
bodyText ||| cut matches some part of any base program [25].)
subsectionHeader ||| 3.5 Towards a formal semantics for expressive
subsectionHeader ||| aspects
bodyText ||| In the previous sections, we have given an informal se-
bodyText ||| mantics of our aspect language. We now illustrate how the
bodyText ||| aspect language could be formally defined by translating one
bodyText ||| of the example aspects into formal aspect language by ex-
bodyText ||| tension of that used in the formal framework of [14].
bodyText ||| The original formal language must be extended in order to
bodyText ||| deal with halting aspects, an unbounded number of sequen-
bodyText ||| tial aspects and arbitrary join point predicates. The gram-
bodyText ||| mar of the extension, our tiny aspect language, is defined in
bodyText ||| Figure 8. In this language, aspect expressions A consists of
bodyText ||| parallel combinations of aspects, C is a join point predicate
bodyText ||| (similar to our pointcut language) expressed as a conjunc-
bodyText ||| tion of a term pattern and possibly an expression from the
bodyText ||| constraint logic programming language CLP(R) [20].
bodyText ||| An aspect A&apos; is either:
listItem ||| •	A recursive definition.
listItem ||| •	A sequence formed using the prefix operation C D I; X,
listItem ||| where X is an aspect or a recursion variable and I a piece
listItem ||| of code (i.e., an advice).
listItem ||| •	A choice construction A1 ❑ A2 which chooses the first
listItem ||| aspect that matches a join point (the other is thrown away).
listItem ||| If both match the same join point, A1 is chosen.
listItem ||| •	A parallel composition of two aspects A1 11 A2 that
listItem ||| cannot occur in choice construction.
listItem ||| •	A halting aspect STOP.
bodyText ||| The semantics of the protocol translation aspect (from
bodyText ||| TCP to UDP) is given in Fig. 9. A sequence can have sev-
bodyText ||| eral instances. This is translated into the language A by the
bodyText ||| expression a1 11 ... which starts a new sequence a1 once
bodyText ||| the first join point has been matched and continue to match
bodyText ||| the rest of the sequence in progress. The repetition oper-
bodyText ||| ator ∗ is translated into recursion on variable the a2. The
bodyText ||| branching operator 11 is translated into the choice operator
page ||| 32
figure ||| µa1. callJP(fd socket(AF INET,  SOCK  STREAM, 0)) D socket(AF INET, SOCK DGRAM, 0);
figure ||| a1 ( callJP(a connect(fd, address, length)) D returnZero();
figure ||| µa2. callJP(b close(fd)) D skip; STOP 
figure ||| ❑	callJP(c read(fd, readBuffer, readLength)) D recvfrom(fd, readBuffer, readLength, 0, address, length); a2
figure ||| ❑	callJP(d write(fd, writeBuffer, writeLength)) D recvfrom(fd, writeBuffer, writeLength, 0, address, length); a2
figureCaption ||| Figure 9: Definition of the protocol translation using the tiny aspect language
bodyText ||| ❑. Finally, the last primitive aspect of the sequence occurs
bodyText ||| as the first aspect of a choice to get priority over the join
bodyText ||| points read and write because of the *. Note that we use
bodyText ||| pattern matching in A and that an overbar marks the first
bodyText ||| occurrence of a variable (i.e., its definition not a use).
bodyText ||| Note that formal definitions such as that of the protocol
bodyText ||| translation aspect precisely define several important issues,
bodyText ||| in particular, when new instances of the sequence aspect are
bodyText ||| created, and disambiguate of potentially non-deterministic
bodyText ||| situations, e.g., when two pointcuts of consecutive primitive
bodyText ||| aspects in the sequence match at the same time.
sectionHeader ||| 4. DYNAMIC WEAVING WITH ARACHNE
bodyText ||| Arachne is built around two tools, an aspect compiler and
bodyText ||| a runtime weaver. The aspect compiler translates the aspect
bodyText ||| source code into a compiled library that, at weaving time, di-
bodyText ||| rects the weaver to place the hooks in the base program. The
bodyText ||| hooking mechanisms used in Arachne are based on improved
bodyText ||| techniques originally developed for µDyner [32]. These tech-
bodyText ||| niques allow to rewrite the binary code of executable files
bodyText ||| on the fly i.e.without pausing the base program, as long
bodyText ||| as these files conform to the mapping defined by the Unix
bodyText ||| standard [35] between the C language and x86 assembly lan-
bodyText ||| guage. Arachne’s implementation is structured as an open
bodyText ||| framework that allows to experiment with new kinds of join
bodyText ||| points and pointcut constructs. Another important differ-
bodyText ||| ence between Arachne and µDyner is, that µDyner requires
bodyText ||| a compile time preparation of the base program, whereas
bodyText ||| Arachne does not. Hence Arachne is totally transparent for
bodyText ||| the base program while µDyner is not.
subsectionHeader ||| 4.1 The Arachne Open Architecture
bodyText ||| The Arachne open architecture is structured around three
bodyText ||| main entities: the aspect compiler, the instrumentation ker-
bodyText ||| nel, and the different rewriting strategies. The aspect com-
bodyText ||| piler translates the aspect source code into C before com-
bodyText ||| piling it. Weaving is accomplished through a command line
bodyText ||| tool weave that acts as a front end for the instrumentation
bodyText ||| kernel. weave relays weaving requests to the instrumen-
bodyText ||| tation kernel loaded in the address space of the program
bodyText ||| through Unix sockets. Upon reception of a weaving request,
bodyText ||| the instrumentation kernel selects the appropriate rewriting
bodyText ||| strategies referred by the aspects to be woven and instru-
bodyText ||| ments the base program accordingly. The rewriting strat-
bodyText ||| egy consults the pointcut analysis performed by the aspect
bodyText ||| compiler to locate the places where the binary code of the
bodyText ||| base program needs to be rewritten. It finally modifies the
bodyText ||| binary code to actually tie the aspects to the base program.
bodyText ||| With this approach, the Arachne core is independent of
bodyText ||| a particular aspect, of the aspect language, of the particu-
bodyText ||| lar processor architecture, and of a particular base program.
bodyText ||| In fact, all dependencies to aspect language implementation
bodyText ||| are limited to the aspect compiler. All dependencies to the
bodyText ||| operating system are localized in the instrumentation ker-
bodyText ||| nel and finally all dependencies to the underlying hardware
bodyText ||| architecture are modularized in the rewriting strategies.
subsubsectionHeader ||| 4.1.1 The Arachne aspect compilation process
bodyText ||| The aspect compilation scheme is relatively straightfor-
bodyText ||| ward: it transforms advices into regular C functions. Point-
bodyText ||| cuts are rewritten as C code driving hook insertions into
bodyText ||| the base program at weaving time. There are however cases
bodyText ||| where the sole introduction of hooks is insufficient to deter-
bodyText ||| mine whether an advice should be executed. In this case,
bodyText ||| the aspect compiler generates functions that complement
bodyText ||| the hooks with dynamic tests on the state of the base pro-
bodyText ||| gram. These dynamic tests are called residues in AspectJ
bodyText ||| and the rewritten instructions within the base program the
bodyText ||| shadow [16]. Once the aspects have been translated into C,
bodyText ||| the Arachne compiler uses a legacy C compiler to generate a
bodyText ||| dynamically linked library (DLL) for the compiled aspects.
subsubsectionHeader ||| 4.1.2 The Arachne weaving process
bodyText ||| From a user viewpoint, the Arachne weave and deweave
bodyText ||| command line programs the same syntax than µDyner’s ver-
bodyText ||| sion. They both take two arguments. The first identifies the
bodyText ||| process to weave aspects in or deweave aspects from, and
bodyText ||| the second indicates the aspect DLL. However, Arachne can
bodyText ||| target potentially any C application running on the machine
bodyText ||| while µDyner was limited to applications compiled with it
bodyText ||| running on the machine. When Arachne’s weave receives a
bodyText ||| request to weave an aspect in a process that does not con-
bodyText ||| tain the Arachne instrumentation kernel, it loads the kernel
bodyText ||| in the process address space using standard techniques [11].
bodyText ||| The instrumentation kernel is transparent for the base
bodyText ||| program as the latter cannot access the resources (mem-
bodyText ||| ory and sockets essentially) used by the former. Once in-
bodyText ||| jected, the kernel creates a thread with the Linux system
bodyText ||| call: clone. This thread handles the different weaving re-
bodyText ||| quests. Compared to the POSIX pthread create function,
bodyText ||| the usage of clone allows the instrumentation thread to pre-
bodyText ||| vent the base program to access its sockets. The instrumen-
bodyText ||| tation kernel allocates memory by using side effect free allo-
bodyText ||| cation routines (through the Linux mmap API). Because the
bodyText ||| allocation routines are side effect free, Arachne’s memory is
bodyText ||| totally invisible to the base program. It is up to the aspect
bodyText ||| to use Arachne’s memory allocation routines or base pro-
bodyText ||| gram specific allocation functions. This transparency turns
bodyText ||| out to be crucial in our experiments. Legacy applications
bodyText ||| such as Squid use dedicated resource management routines
bodyText ||| and expect any piece of code they run to use these routines.
bodyText ||| Failures will result in an application crash.
bodyText ||| After loading an aspect, the instrumentation kernel rewrites
bodyText ||| the binary code of the base program. These rewriting strate-
bodyText ||| gies are not included in the kernel and must be fetched on
bodyText ||| demand by each loaded aspect.
subsectionHeader ||| 4.2 Rewriting strategies
bodyText ||| Rewriting strategies are responsible for transforming the
bodyText ||| binary code of the base program to effectively tie aspects to
page ||| 33
figureCaption ||| Figure 10: Generic hook operations.
bodyText ||| the base program at weaving time. These strategies localize
bodyText ||| Arachne’s main dependencies to the underlying hardware
bodyText ||| architecture. In general, rewriting strategies need to col-
bodyText ||| lect information about the base program. These information
bodyText ||| typically consist of the addresses of the different shadows,
bodyText ||| their size, the symbol (i.e.function or global variable name)
bodyText ||| they manipulate, their length etc. In order to keep compiled
bodyText ||| aspects independent from the base program, this informa-
bodyText ||| tion is gathered on demand at runtime. The mapping be-
bodyText ||| tween a symbol name in the base program source code and
bodyText ||| its address in memory is inferred from linking information
bodyText ||| contained in the base program executable. However because
bodyText ||| these information can be costly to retrieve, Arachne collects
bodyText ||| and stores it into meta-information DLLs. these DLLs be-
bodyText ||| have as a kind of cache and lessen the problem of collecting
bodyText ||| the information required to instrument the base program.
bodyText ||| To implement our aspect language, Arachne provides a set
bodyText ||| of eight rewriting strategies that might eventually use each
bodyText ||| other.
subsubsectionHeader ||| 4.2.1 Strategiesfor call, readGlobal and writeGlobal
bodyText ||| In Arachne, call, readGlobal and writeGlobal allow an
bodyText ||| advice to be triggered upon a function call, a read on a
bodyText ||| global variable or a write respectively. While the implemen-
bodyText ||| tation of readGlobal and writeGlobal in Arachne is close
bodyText ||| to the one in µDyner, Arachne implements the strategy for
bodyText ||| call by rewriting function invocations found in the base
bodyText ||| program. µDyner instead rewrites the function body of the
bodyText ||| callee. On the Intel architecture, function calls benefit from
bodyText ||| the direct mapping to the x86 call assembly instruction
bodyText ||| that is used by almost, if not all, compilers. Write and read
bodyText ||| accesses to global variables are translated into instructions
bodyText ||| using immediate, hard coded addresses within the binary
bodyText ||| code of the base program. By comparing these addresses
bodyText ||| with linking information contained in the base program ex-
bodyText ||| ecutable, Arachne can determine where the global variable
bodyText ||| is being accessed. Therefore those primitive pointcuts do
bodyText ||| not involve any dynamic tests. The sole rewriting of the
bodyText ||| binary base program code is enough to trigger advice and
bodyText ||| residue1 executions at all appropriate points.
bodyText ||| The size of the x86 call instruction and the size of an x86
bodyText ||| jump (jmp) instruction are the same. Since the instruction
bodyText ||| performing an access to a global variable involves a hard
bodyText ||| coded address, x86 instructions that read or write a global
footnote ||| 1Residues (i.e. dynamic tests on the base program state) are
footnote ||| required when these primitive pointcuts are combined with
footnote ||| conditional pointcuts or when pattern matching is involved.
bodyText ||| variable have at least the size of a x86 jmp instruction. Hence
bodyText ||| at weaving time, Arachne rewrites them as a jmp instruction
bodyText ||| to a hook. Hooks are generated on the fly on freshly allo-
bodyText ||| cated memory. As shown in figure 10, hooks contain a few
bodyText ||| assembly instructions that save and restore the appropriate
bodyText ||| registers before and after an advice (or shadow) execution.
bodyText ||| A generic approach is to have hooks save the whole set of
bodyText ||| registers, then execute the appropriate residue and/or ad-
bodyText ||| vice code before restoring the whole set of registers; finally
bodyText ||| the instructions found at the join point shadow are executed
bodyText ||| to perform the appropriate side effects on the processor reg-
bodyText ||| isters. This is accomplished by relocating the instructions
bodyText ||| found at the join point shadow. Relocating the instructions
bodyText ||| makes the rewriting strategies handling read and write ac-
bodyText ||| cess to global variable independent from the instruction gen-
bodyText ||| erated by the compiler to perform the access 2. The limited
bodyText ||| number of x86 instructions used to invoke a function allows
bodyText ||| Arachne’s rewriting strategy to exploit more efficient, relo-
bodyText ||| cation free, hooks.
subsubsectionHeader ||| 4.2.2 Strategiesfor controlf low and controlflowstar
bodyText ||| Every time a C function is called, the Linux runtime
bodyText ||| creates an activation record on the call stack [35]. Like
bodyText ||| µDyner, Arachne’s implementation of the rewriting strat-
bodyText ||| egy for controlf low uses the most deeply nested function
bodyText ||| call (or global read or write access) in the control flow point-
bodyText ||| cut as shadow. This shadow triggers a residue. This residue
bodyText ||| uses the activation record’s chaining to check whether the
bodyText ||| remaining function calls of the control flow, are on the call
bodyText ||| stack maintained by the Linux runtime. An appropriate
bodyText ||| usage of hashtables that store the linking information con-
bodyText ||| tained in the base program executables can thereby de-
bodyText ||| crease the cost of determining if a specific function is the
bodyText ||| caller of another to a pointer comparison. Therefore, the
bodyText ||| residue for a controlf low with n directly nested functions
bodyText ||| implies exactly n pointer comparisons. However, the residue
bodyText ||| worst case runtime for the indirect control flow operator
bodyText ||| controlflowstar that allows for not directly nested func-
bodyText ||| tions, is proportional to the base program stack depth.
subsubsectionHeader ||| 4.2.3 Strategiesfor read and write
bodyText ||| read and write are new join points not included in µDyner
bodyText ||| that have been added to the latest version of Arachne. Their
bodyText ||| implementation relays on a page memory protection as al-
bodyText ||| lowed by the Linux operating system interface (i.e. mprotect)
bodyText ||| and the Intel processor specifications [18]. A read or write
bodyText ||| pointcut triggers a residue to relocate the bound variable
bodyText ||| into a memory page that the base program is not allowed
bodyText ||| to access and adds a dedicated signal handler. Any attempt
bodyText ||| made by the base program to access the bound variable iden-
bodyText ||| tified will then trigger the execution of the previously added
bodyText ||| signal handler. This handler will then inspect the binary
bodyText ||| instruction trying to access the protected page to determine
bodyText ||| whether it was a read or a write access before eventually
bodyText ||| executing the appropriate advice.
subsubsectionHeader ||| 4.2.4 Strategiesfor seq
bodyText ||| Like read and write, seq is a new language feature of
bodyText ||| Arachne. µDyner offers no equivalent construct. Arachne’s
bodyText ||| rewriting strategy of this operator associates a linked list to
footnote ||| 2About 250 x86 instruction mnemonics can directly manip-
footnote ||| ulate a global variable. This corresponds to more than one
footnote ||| thousand opcodes.
figure ||| execution flow
figure ||| Legacy base program
figure ||| shadow: rewriting
figure ||| site replaced by a
figure ||| jump
figure ||| B���piled baof sethe
figure ||| program
figure ||| x86 instruction
figure ||| x86 instruction
figure ||| x86 instruction
figure ||| x86 instruction
figure ||| Relocated tailored
figure ||| ���tructio��
figure ||| up���ng re���ters
figure ||| Hooks generated at weavingAspect DLL
figure ||| time	generated at aspect compile time
figure ||| Entry hook
figure ||| save registers
figure ||| Return hook
figure ||| Restore registers
figure ||| Residue (dynamic tests)
figure ||| and/or advices
page ||| 34
bodyText ||| every stage inside the sequence except the last one. Each
bodyText ||| stage in a sequence triggers a residue that updates these
bodyText ||| linked lists to reflect state transitions of currently match-
bodyText ||| ing execution flows. Upon matching of the first pointcut
bodyText ||| of the first primitive aspect in the seq, a node is allocated
bodyText ||| and added to the associated linked list. This node con-
bodyText ||| tains a structure holding variables shared among the dif-
bodyText ||| ferent pointcuts within the sequence. Once a join point
bodyText ||| matches a pointcut of an primitive aspect denoting a stage
bodyText ||| in the sequence, Arachne consults every node in the linked
bodyText ||| list associated with the previous stage and executes the cor-
bodyText ||| responding advice 3. Arachne eventually updates the node
bodyText ||| and in the absence of a * moves it to the list associated
bodyText ||| with the currently matched pointcut.If the matching point-
bodyText ||| cut corresponds to the end of the sequence, structures are
bodyText ||| not moved into another list but freed. Our aspect compiler
bodyText ||| includes an optimization where structures are allocated from
bodyText ||| a resizable pool and upon a sequence termination, structures
bodyText ||| are not freed but returned to the pool.
subsectionHeader ||| 4.3 Arachne limitations
bodyText ||| Aggressive optimizations of the base program might pre-
bodyText ||| vent Arachne to seamlessly weave aspects. Two optimiza-
bodyText ||| tions are not yet supported by Arachne. First if the compiler
bodyText ||| inlines a function in another one within the binary code of
bodyText ||| the base program, the Arachne weaver will fail to properly
bodyText ||| handle pointcuts referring to that function. Second, con-
bodyText ||| trol flow pointcuts are based on the chaining of activation
bodyText ||| records. On the x86 architecture, in leaf functions, opti-
bodyText ||| mizing compilers sometimes do not maintain this chaining
bodyText ||| to free one register for the rest of the computation. This
bodyText ||| however has not been a problem during our experiments
bodyText ||| as we used the open source C compiler gcc. Arachne sup-
bodyText ||| ports two of the three optimization levels proposed by gcc.
bodyText ||| Stripping that removes linking information and aggressive
bodyText ||| optimizations that break the interoperability between com-
bodyText ||| pilers and/or debuggers are incompatible with Arachne. In
bodyText ||| practice, Arachne can be used on applications compiled like
bodyText ||| squid with two of the three gcc optimization level.
sectionHeader ||| 5. PERFORMANCE EVALUATION
bodyText ||| Aspect-oriented solutions will be used if the aspect sys-
bodyText ||| tem’s language is expressive enough and if the aspect system
bodyText ||| overhead is low enough, for the task at hand. The purpose
bodyText ||| of this section is to study Arachne’s performance. We first
bodyText ||| present the speed of each Arachne language construct and
bodyText ||| compare it to similar C language constructs. We then study
bodyText ||| the overhead of extending Squid with a prefetching policy.
bodyText ||| This case study shows that even if the cost of some Arachne
bodyText ||| aspect language constructs might be high compared to C
bodyText ||| language constructs, this overhead is largely amortized in
bodyText ||| real applications.
subsectionHeader ||| 5.1 Evaluation of the language constructs
subsectionHeader ||| This performance evaluation focuses on studying the cost
subsectionHeader ||| of each construct of our aspect language. To estimate the
subsectionHeader ||| cost for each construct of our aspect language, we wrote an
subsectionHeader ||| aspect using this construct that behaves as an interpreter of
footnote ||| 3In case the previous stage pointcut was used with a star
footnote ||| *, Arachne examines nodes from linked list associated with
footnote ||| the last two previous stages, and so on, until a not starred
footnote ||| primitive aspect in the sequence is reached.
table ||| Execution times (cycles)
table ||| call	Arachne	Native	Ratio
table ||| 	28±2.3%	21±1.9%	1.3
table ||| seq	201±0.5%	63±1.7%	3.2
table ||| cflow	228±1.6%	42±1.8%	5.4
table ||| readGlobal	2762±4.3%	1±0.2%	2762
table ||| read	9729±4.9%	1±0.6%	9729
tableCaption ||| Table 1: Speed of each language construct used to
tableCaption ||| interpret the base program compared to a native
tableCaption ||| execution.
bodyText ||| the base program. For example, to study the performance
bodyText ||| of readGlobal, we wrote an aspect whose action returns the
bodyText ||| value of the global variable referred in the pointcut, i.e., we
bodyText ||| wrote aspects behaving like the base program. For each of
bodyText ||| these aspects, we compare the time required to perform the
bodyText ||| operation matching the pointcut, in case the operation is
bodyText ||| interpreted by the woven aspect with the time required to
bodyText ||| carry out the operation natively (without the woven aspect).
bodyText ||| For example, to study the performance of readGlobal, we
bodyText ||| first evaluate the time needed to retrieve the global variable
bodyText ||| value through the code generated by the C compiler gcc
bodyText ||| without any aspect woven and compare this value to the
bodyText ||| time needed to retrieve the global variable value through
bodyText ||| the aspect once it has been woven in the base program.
bodyText ||| We express our measurements as a ratio between these two
bodyText ||| durations to abstract from the experimentation platform.
bodyText ||| This approach requires the ability to measure short peri-
bodyText ||| ods of time. For instance, a global variable value is usually
bodyText ||| retrieved (readGlobal in our aspect language) in a single
bodyText ||| clock tick. Since standard time measurement APIs were
bodyText ||| not precise enough, our benchmarking infrastructure relies
bodyText ||| on the rdtsc assembly instruction [18]. This instruction re-
bodyText ||| turns the number of clock cycles elapsed since power up. The
bodyText ||| Pentium 4 processor has the ability to dynamically reorder
bodyText ||| the instructions it executes. To ensure the validity of our
bodyText ||| measurement, we thus insert mfence instructions in the gen-
bodyText ||| erated code whose execution speed is being measured. An
bodyText ||| mfence forces the preceding instructions to be fully executed
bodyText ||| before going on. The pipeline mechanism in the Pentium 4
bodyText ||| processor entails that the speed of a piece of assembly code
bodyText ||| depends from the preceding instructions. To avoid such hid-
bodyText ||| den dependencies, we place the operation whose execution
bodyText ||| time is being measured in a loop. We use gcc to unroll the
bodyText ||| loop at compile time and we measure the time to execute
bodyText ||| the complete loop. This measure divided by the number of
bodyText ||| loop repetitions yields an estimation of the time required
bodyText ||| to execute the operation. The number of times the loop is
bodyText ||| executed is chosen after the relative variations of the mea-
bodyText ||| sures ,i.e., we increased the number of repetitions until ten
bodyText ||| runs yields an average relative variation not exceeding 5%.
bodyText ||| To check the correctness of our experimental protocol, we
bodyText ||| measured the time needed to execute a nop assembly in-
bodyText ||| struction, that requires one processor cycle according to the
bodyText ||| Intel specification. The measures of nop presented a relative
bodyText ||| variation of 1.6%.
bodyText ||| Table 1 summarizes our experimental results. Using the
bodyText ||| aspect language to replace a function that returns immedi-
bodyText ||| ately is only 1.3 times slower than a direct, aspect-less, call
bodyText ||| to that empty function. Since the aspect compiler packages
bodyText ||| advices as regular C functions, and because a call pointcut
bodyText ||| involves no residue, this good result is not surprising. When
page ||| 35
figureCaption ||| Figure 11: controlflow, seq, and read performances
bodyText ||| an access to a global variable is replaced by an advice exe-
bodyText ||| cution, the hooks generated by the rewriting strategy need
bodyText ||| to prepare the processor to call the advice function. This
bodyText ||| increases the time spent in the hooks. In addition, while
bodyText ||| an access to a global variable is often performed by a sin-
bodyText ||| gle x86 instruction, an empty function is often composed
bodyText ||| of four instructions. Hence the relative cost of an aspect
bodyText ||| triggered upon a global variable access and a direct, aspect-
bodyText ||| less, access to a global variable is slightly higher than the
bodyText ||| corresponding ratio for functions. A seq of three invoca-
bodyText ||| tions of empty functions is only 3.2 time slower than the
bodyText ||| direct, aspect-less, three successive functions calls. Com-
bodyText ||| pared to the pointcuts used to delimit the different stages,
bodyText ||| the seq overhead is limited to a few pointer exchanges be-
bodyText ||| tween the linked lists holding the bound variable. On Intel
bodyText ||| x86, global variable accesses benefit from excellent hardware
bodyText ||| support. In the absence of aspects, a direct global variable
bodyText ||| read is usually carried out in a single unique cycle. To trig-
bodyText ||| ger the advice execution, the Arachne runtime has to save
bodyText ||| and restore the processor state to ensure the execution co-
bodyText ||| herency, as advices are packaged as regular C functions (see
bodyText ||| also 4.2.1). It is therefore not surprising that a global vari-
bodyText ||| able readGlobal appears as being 2762 times slower than
bodyText ||| a direct, aspect-less global variable read. read performance
bodyText ||| can be accounted in the same way: in the absence of aspect,
bodyText ||| local variables are accessed in a single unique cycle. The
bodyText ||| signal mechanism used in the read requires that the oper-
bodyText ||| ating system detects the base program attempt to read into
bodyText ||| a protected memory page before locating and triggering the
bodyText ||| signal handler set up by Arachne, as shown in 4.2.3. Such
bodyText ||| switches to and from kernel space remain slow. Using read
bodyText ||| to read a local variable is 9729 times slower than retrieving
bodyText ||| the local variable value directly, without aspects.
bodyText ||| seq and controlf low can refer to several points in the exe-
bodyText ||| cution of the base program (i.e. different stages for seq and
bodyText ||| different function invocations for the controlflow). The
bodyText ||| runtime of these pointcuts grows linearly with the number
bodyText ||| of execution points they refer to and with the number of
bodyText ||| matching instances. Figure 11 summarizes a few experimen-
bodyText ||| tal results for controlf low and seq proving these points.
subsectionHeader ||| 5.2 Case Study on a real application
bodyText ||| Since, depending on the aspect construct used, interpret-
bodyText ||| ing the base program with aspects can slow it down by a fac-
bodyText ||| tor ranging between 1.3 and 9729, we studied Arachne’s per-
bodyText ||| formance on a real world application, the Web cache Squid.
table ||| 	Arachne	Manual	Diff
table ||| 			(%)
table ||| 	Top1	Top1	
table ||| 	Top2	Top2	
table ||| Throughput	5.59	5.59	
table ||| (request/s)	5.58	5.59	
table ||| Response Time (ms)	1131.42	1146.07	1.2–-1
table ||| 	1085.31	1074.55	
table ||| Miss response time (ms)	2533.50	2539.52	0.2– 1.8
table ||| 	2528.35	2525.34	
table ||| Hit response time (ms)	28.96	28.76	-0.6 – 3.8
table ||| 	30.62	31.84	
table ||| Hit ratio	59.76	59.35	-0.6 – 0.7
table ||| 	61.77	62.22	
table ||| Errors	0.51	0.50	-1.9–0
table ||| 	0.34	0.34	
tableCaption ||| Table 2: Performances comparison between manual
tableCaption ||| modification and Arachne, for prefechting policy in-
tableCaption ||| tegration in Squid
bodyText ||| We extended Squid with a prefetching policy [9]. As de-
bodyText ||| scribed in section 3.1, we implemented this policy as a set
bodyText ||| of aspects and made a second implementation of this policy
bodyText ||| by editing the Squid source code and recompiling it. This
bodyText ||| section compares the performance of these two implemen-
bodyText ||| tations using standard Web cache performance indicators:
bodyText ||| throughput, response time and hit ratio.
bodyText ||| Obtaining access traces adequate to study a Web cache
bodyText ||| performance is difficult. The trace must be long enough to
bodyText ||| fill the cache. Due to privacy issues, traces are usually not
bodyText ||| publicly available. Since traces do not include the content of
bodyText ||| the accessed pages, these pages must be downloaded again.
bodyText ||| In the meantime the page contents may have changed and
bodyText ||| even the URLs may have disappeared.
bodyText ||| Instead of traces, we based our evaluation on Web Poly-
bodyText ||| graph [30]. Polygraph is a benchmarking tool developed by
bodyText ||| the Squid team and featuring a realistic HTTP and SSL
bodyText ||| traffic generator and a flexible content simulator.
bodyText ||| We filled up the cache and simulated a one day workload
bodyText ||| with its two request rate peaks observed in real life environ-
bodyText ||| ments [30]. Table 2 shows results of our simulation. Mea-
bodyText ||| sures have been made during the two request peaks. The
bodyText ||| hit time and the miss time, time needed to deliver a docu-
bodyText ||| ment present, respectively not present, in the cache are very
bodyText ||| similar. It shows that differences are imperceptible between
bodyText ||| the version of Squid extended by Arachne and the one ex-
bodyText ||| tended manually (less than 1%). Hence, even if the cost
bodyText ||| of Arachne’s aspect language constructs might seem high,
bodyText ||| they are largely amortized in real applications. To give a
bodyText ||| typical example observed on our experimental platform: in
bodyText ||| case of a cache hit, a 3.8 MB page was retrieved in a single
bodyText ||| second, the time spent in prefetching advices amounted to
bodyText ||| 1801 µsec, and the time spent within Arachne to execute the
bodyText ||| hooks and dynamic tests to 0.45 µsec. In a miss case, on
bodyText ||| the average, a client retrieved the same page in 1.3 seconds,
bodyText ||| 16679 µsec were spent in the advices and 0.67 µsec within
bodyText ||| Arachne itself.
sectionHeader ||| 6. RELATED WORK
bodyText ||| Our work is directly related to other aspect weavers for
bodyText ||| C, approaches for expressive aspect languages, and dynamic
bodyText ||| weaving, in particular for C. In this section, we consider
bodyText ||| related work in each of these fields in turn.
bodyText ||| Apart from µDyner and Arachne, there are few aspect
figure ||| Sequence
figure ||| 1	2	3	4	5
figure ||| 1	2	3	4	5
figure ||| Number of imbricated calls	Number of matching instances
figure ||| Controlflow
figure ||| 10
figure ||| 3000
figure ||| 2000
figure ||| 30
figure ||| 20
figure ||| 5
figure ||| 1000
figure ||| 10
page ||| 36
bodyText ||| weavers for C (or even C like languages); some notewor-
bodyText ||| thy exceptions are AspectC [12] (no available implementa-
bodyText ||| tion), AspectC++ and [33]. All of these rely on source-code
bodyText ||| transformation and thus cannot apply aspects to running
bodyText ||| C applications as required by the applications we consider.
bodyText ||| Furthermore, none of these systems provides explicit sup-
bodyText ||| port for aspects over join point sequences.
bodyText ||| There is quite a large body of work now on the notion of
bodyText ||| expressive aspect languages where “more expressive” typi-
bodyText ||| cally compares to w.r.t. AspectJ’s pointcut and advice mod-
bodyText ||| els. Our work has been inspired by Event-based AOP [15],
bodyText ||| which aims at the definition of pointcuts in terms of arbi-
bodyText ||| trary relations between events. Nevertheless, many other
bodyText ||| approaches to expressive aspect languages exist: e.g., data-
bodyText ||| flow relations [26], logic programming [13], process algebras
bodyText ||| [3], graphs [5], and temporal logics [1], have all been pro-
bodyText ||| posed as a basis for the definition of expressive aspect lan-
bodyText ||| guages. However, few of these encompass dynamic weaving
bodyText ||| and only the latter has been applied to C code under effi-
bodyText ||| ciency considerations similar to our setting.
bodyText ||| Dynamic weaving is commonly realized in Java through
bodyText ||| preprocessing at load-time like [8] or through the JVM De-
bodyText ||| bugging Interface [28]. These tools rely on bytecode rewrit-
bodyText ||| ing techniques, have typically limited expressivity (some do
bodyText ||| not support field accesses) and incur a huge performance
bodyText ||| overhead. Dynamic weaving through modification at run-
bodyText ||| time is found infrequently for compiled languages. An ex-
bodyText ||| ception for Java is JasCo [21] whose most recent version (0.7)
bodyText ||| supports dynamic weaving through the new instrumentation
bodyText ||| API of Java 5.
bodyText ||| Many instrumentation techniques have been proposed to
bodyText ||| rewrite binary code on the fly. In these approaches, dif-
bodyText ||| ficulty issues range from the complexity to rewrite binary
bodyText ||| code to the lack of a well-defined relationship between source
bodyText ||| code and the compiler generated binary code. Hence many
bodyText ||| approaches work on an intermediate representation of the
bodyText ||| binary code and source language [34]. Producing this repre-
bodyText ||| sentation first and then regenerating the appropriate binary
bodyText ||| executable code has proven to be costly both in terms of
bodyText ||| memory consumption and in CPU time.
bodyText ||| A few other approaches have considered a direct rewrit-
bodyText ||| ing of the binary code at runtime. Dyninst [17] and dynamic
bodyText ||| probes [27] allow programmers to modify any binary instruc-
bodyText ||| tion belonging to an executable. Dyninst however relies on
bodyText ||| the Unix debugging API: ptrace. ptrace allows a third
bodyText ||| party process to read and write the base program memory.
bodyText ||| It is however highly inefficient: before using ptrace, the
bodyText ||| third party process has to suspend the execution of the base
bodyText ||| program and resume its execution afterwards. In compari-
bodyText ||| son, Arachne uses ptrace at most once, to inject its kernel
bodyText ||| DLL into the base program process. In addition, Dyninst
bodyText ||| does not free the programmer from dealing with low level
bodyText ||| details. For example, it seems difficult to trigger an advice
bodyText ||| execution upon a variable access with Dyninst: the transla-
bodyText ||| tion from the variable identifier to an effective address is left
bodyText ||| to the user. Worse, Dyninst does not grant that the manip-
bodyText ||| ulation of the binary instructions it performs will succeed.
bodyText ||| Dyninst uses an instrumentation strategy where several ad-
bodyText ||| jacent instructions are relocated. This is unsafe as one of
bodyText ||| the relocated instructions can be the target of branching
bodyText ||| instructions. In comparison, Arachne join point model has
bodyText ||| been carefully chosen to avoid these kind of issues; if an as-
bodyText ||| pect can be compiled with Arachne, it can always be woven.
bodyText ||| 7. CONCLUSION AND FUTURE WORK
bodyText ||| In this paper we have discussed three different crosscut-
bodyText ||| ting concerns which are typical for C applications using OS-
bodyText ||| level services and which frequently need to be applied at
bodyText ||| runtime. We have motivated that such concerns can be ex-
bodyText ||| pressed as aspects and have defined a suitable aspect lan-
bodyText ||| guage. This language is more expressive than those used in
bodyText ||| other aspect weavers for C in that it provides support for
bodyText ||| aspects defined over sequences of execution points as well as
bodyText ||| for variable aliases. We have presented an integration of this
bodyText ||| language into Arachne, a weaver for runtime weaving of as-
bodyText ||| pects in C applications. Finally, we have provided evidence
bodyText ||| that the integration is efficient enough to apply such aspects
bodyText ||| dynamically to high-performance applications, in particular
bodyText ||| the web cache “squid.”
bodyText ||| As future work, we intend to investigate the suitability of
bodyText ||| the proposed aspect language for other C-applications. We
bodyText ||| also intend to investigate Arachne extension to the C++
bodyText ||| language. Indeed, object-oriented programming heavily uses
bodyText ||| protocol-based interfaces collaboration (hence sequence as-
bodyText ||| pects). Along with its open architecture, extending Arachne
bodyText ||| to support C++, will pave the way to a relatively language
bodyText ||| independent aspect and weaving infrastructure. Finally,
bodyText ||| Arachne’s toolbox should be extended with support for as-
bodyText ||| pect interactions (e.g., analyses and composition operators).
sectionHeader ||| 8. REFERENCES
reference ||| [1] R. A. ºAberg, J. L. Lawall, M. SÄudholt, G. Muller, and
reference ||| A.-F. L. Meur. On the automatic evolution of an os
reference ||| kernel using temporal logic and AOP. In Proceedings
reference ||| of Automated Software Engineering (ASE’03), pages
reference ||| 196{204. IEEE, 2003.
reference ||| [2] American National Standards Institute.
reference ||| ANSI/ISO/IEC 9899-1999: Programming Languages
reference ||| — C. American National Standards Institute, 1430
reference ||| Broadway, New York, NY 10018, USA, 1999.
reference ||| [3] J. H. Andrews. Process-algebraic foundations of
reference ||| aspect-oriented programming. In Proceedings of the
reference ||| 3rd International Conference on Metalevel
reference ||| Architectures and Separation of Crosscutting
reference ||| Concerns, volume 2192 of LNCS. Springer Verlag,
reference ||| Sept. 2001.
reference ||| [4] M. Arlitt and T. Jin. A workload characterization
reference ||| study of the 1998 world cup web site. IEEE Network,
reference ||| 14(3):30{37, May 2000.
reference ||| [5] U. ABmann and A. Ludwig. Aspect weaving by graph
reference ||| rewriting. In U. W. Eisenecker and K. Czarnecki,
reference ||| editors, Generative Component-based Software
reference ||| Engineering (GCSE), Erfurt, Oct. 1999.
reference ||| [6] CERT - Carnegie Mellon University. Vulnerability
reference ||| note vu#613459, Feb. 2002. published on line:
reference ||| http://www.kb.cert.org/vuls/id/613459.
reference ||| [7] H. Chen and P. Mohapatra. Catp: A context-aware
reference ||| transportation protocol for http. In International
reference ||| Workshop on New Advances in Web Servers and
reference ||| Proxy Technologies Held with ICDCS, 2003.
reference ||| [8] S. Chiba and K. Nakagawa. Josh: An open
reference ||| AspectJ-like language. In Proceedings of the third
page ||| 37
reference ||| international conference on Aspect-oriented software
reference ||| development, pages 102–111. ACM Press, Mar. 2004.
reference ||| [9] K.-I. Chinen and S. Yamaguchi. An interactive
reference ||| prefetching proxy server for improvement of WWW
reference ||| latency. In Seventh Annual Conference of the Internet
reference ||| Society (INET’97), Kuala Lumpur, June 1997.
reference ||| [10] I. Cidon, A. Gupta, R. Rom, and C. Schuba. Hybrid
reference ||| tcp-udp transport for web traffic. In Proceedings of the
reference ||| 18th IEEE International Performance, Computing,
reference ||| and Communications Conference (IPCCC’99), pages
reference ||| 177–184, Feb. 1990.
reference ||| [11] S. Clowes. Injectso: Modifying and spying on running
reference ||| processes under linux. In Black hat briefings, 2001.
reference ||| [12] Y. Coady, G. Kiczales, M. Feeley, and G. Smolyn.
reference ||| Using AspectC to improve the modularity of
reference ||| Path-Specific customization in operating system code.
reference ||| In V. Gruhn, editor, Proc. of the Joint 8th European
reference ||| Software Engeneering Conference and 9th ACM
reference ||| SIGSOFT Symposium on the Foundation of Software
reference ||| Engeneering (ESEC/FSE-01), volume 26, 5 of
reference ||| SOFTWARE ENGINEERING NOTES, pages 88–98,
reference ||| New York, Sept. 10–14 2001. ACM Press.
reference ||| [13] K. de Volder. Aspect-oriented logic meta
reference ||| programming. In P. Cointe, editor, Meta-Level
reference ||| Architectures and Reflection, 2nd International
reference ||| Conference on Reflection, volume 1616 of LNCS,
reference ||| pages 250–272. Springer Verlag, 1999.
reference ||| [14] R. Douence, P. Fradet, and M. SÄudholt. A framework
reference ||| for the detection and resolution of aspect interactions.
reference ||| In Proceedings of the ACM SIGPLAN/SIGSOFT
reference ||| Conference on Generative Programming and
reference ||| Component Engineering (GPCE’02), volume 2487 of
reference ||| LLNCS, pages 173–188. Springer-Verlag, Oct. 2002.
reference ||| [15] R. Douence, O. Motelet, and M. SÄudholt. A formal
reference ||| definition of crosscuts. In Proceedings of the 3rd
reference ||| International Conference on Metalevel Architectures
reference ||| and Separation of Crosscutting Concerns, volume 2192
reference ||| of LNCS, pages 170–186. Springer Verlag, Sept. 2001.
reference ||| [16] E. Hilsdale and J. Hugunin. Advice weaving in
reference ||| aspectj. In Proceedings of the 3rd international
reference ||| conference on Aspect-oriented software development,
reference ||| pages 26–35. ACM Press, 2004.
reference ||| [17] J. K. Hollingsworth, B. P. Miller, M. J. R. Goncalves,
reference ||| O. Naim, Z. Xu, and L. Zheng. MDL: A language and
reference ||| compiler for dynamic program instrumentation. In
reference ||| IEEE Conference on Parallel Architectures and
reference ||| Compilation Techniques (PACT), pages 201–213, Nov.
reference ||| 1997.
reference ||| [18] Intel Corportation. IA-32 Intel Architecture Software
reference ||| Developer’s Manual. Intel Corportation, 2001.
reference ||| [19] V. Issarny, M. Ban^atre, B. Charpiot, and J.-M.
reference ||| Menaud. Quality of service and electronic newspaper:
reference ||| The Etel solution. Lecture Notes in Computer Science,
reference ||| 1752:472–496, 2000.
reference ||| [20] J. Jaffar, S. Michaylov, P. J. Stuckey, and R. H. C.
reference ||| Yap. The clp( r ) language and system. ACM Trans.
reference ||| Program. Lang. Syst., 14(3):339–395, 1992.
reference ||| [21] JasCo home page. http://ssel.vub.ac.be/jasco/.
reference ||| [22] R. Jones and P. Kelly. Backwards-compatible bounds
reference ||| checking for arrays and pointers in c programs. In
reference ||| M. Kamkar, editor, Proceedings of the Third
reference ||| International Workshop on Automatic Debugging,
reference ||| volume 2, pages 13–26, May 1997.
reference ||| [23] A. D. Keromytis. ”Patch on Demand” Saves Even
reference ||| More Time? IEEE Computer, 37(8):94–96, 2004.
reference ||| [24] G. Kiczales, J. Lamping, A. Menhdhekar, C. Maeda,
reference ||| C. Lopes, J.-M. Loingtier, and J. Irwin.
reference ||| Aspect-oriented programming. In M. Ak»sit and
reference ||| S. Matsuoka, editors, Proceedings European
reference ||| Conference on Object-Oriented Programming, volume
reference ||| 1241, pages 220–242. JyvÄaskylÄa, Finland, June 1997.
reference ||| [25] K. J. Lieberherr, J. Palm, and R. Sundaram.
reference ||| Expressiveness and complexity of crosscut languages.
reference ||| Technical Report NU-CCIS-04-10, Northeastern
reference ||| University, Sept. 2004.
reference ||| [26] H. Masuhara and K. Kawauchi. Dataflow pointcut in
reference ||| aspect-oriented programming. In First Asian
reference ||| Symposium on Programming Languages and Systems
reference ||| (APLAS’03), 2003.
reference ||| [27] R. J. Moore. Dynamic probes and generalised kernel
reference ||| hooks interface for Linux. In USENIX, editor,
reference ||| Proceedings of the 4th Annual Linux Showcase and
reference ||| Conference, Atlanta, October 10–14, 2000, Atlanta,
reference ||| Georgia, USA, Berkeley, CA, USA, 2000. USENIX.
reference ||| [28] A. Popovici, G. Alonso, and T. Gross. Just-in-time
reference ||| aspects: efficient dynamic weaving for Java. In
reference ||| Proceedings of the 2nd international conference on
reference ||| Aspect-oriented software development, pages 100–109,
reference ||| Boston, Massachusetts, Mar. 2003. ACM Press.
reference ||| [29] M. Rabinovich and H. Wang. DHTTP: An efficient
reference ||| and cache-friendly transfer protocol for web traffic. In
reference ||| INFOCOM, pages 1597–1606, 2001.
reference ||| [30] A. Rousskov and D. Wessels. High-performance
reference ||| benchmarking with Web Polygraph. Software Practice
reference ||| and Experience, 34(2):187–211, Feb. 2004.
reference ||| [31] O. Ruwase and M. S. Lam. A practical dynamic buffer
reference ||| overflow detector. In Proceedings of the 11th Annual
reference ||| Network and Distributed System Security Symposium.
reference ||| Internet Society, Feb. 2004.
reference ||| [32] M. S¶egura-Devillechaise, J.-M. Menaud, G. Muller,
reference ||| and J. Lawall. Web cache prefetching as an aspect:
reference ||| Towards a dynamic-weaving based solution. In
reference ||| Proceedings of the 2nd international conference on
reference ||| Aspect-oriented software development, pages 110–119,
reference ||| Boston, MA, USA, Mar. 2003. ACM Press.
reference ||| [33] O. Spinczyk, A. Gal, and W. Schroeder-Preikschat.
reference ||| AspectC++: an aspect-oriented extension to the C++
reference ||| programming language. In Proceedings of the Fortieth
reference ||| International Conference on Tools Pacific, pages
reference ||| 53–60. Australian Computer Society, Inc., 2002.
reference ||| [34] A. Srivastava and A. Edwards. Vulcan: Binary
reference ||| transformation in a distributed environment. Microsoft
reference ||| Research Tech. Rpt. MSR-TR-2001-50, 2001.
reference ||| [35] U. S. L. System Unix. System V Application Binary
reference ||| Interface Intel 386 Architecture Processor Supplement.
reference ||| Prentice Hall Trade, 1994.
reference ||| [36] D. Wessels. Squid: The Definitive Guide. O’Reilly and
reference ||| Associates, Jan. 2004.
reference ||| [37] J. Wilander and M. Kamkar. A comparison of publicly
reference ||| available tools for dynamic buffer overflow prevention.
reference ||| In Proceedings of the 10th Network and Distributed
reference ||| System Security Symposium, pages 149–162, San
reference ||| Diego, California, February 2003.
page ||| 38
