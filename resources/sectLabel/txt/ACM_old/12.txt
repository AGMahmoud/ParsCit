A Geometric Constraint Library for
3D Graphical Applications
Hiroshi Hosobe
National Institute of Informatics
2-1-2 Hitotsubashi, Chiyoda-ku, Tokyo 101-8430, Japan
hosobe@nii.ac.jp
ABSTRACT
Recent computer technologies have enabled fast high-quality +L+ 3D graphics on personal computers, and also have made +L+ the development of 3D graphical applications easier. How- +L+ ever, most of such technologies do not sufficiently support +L+ layout and behavior aspects of 3D graphics. Geometric con- +L+ straints are, in general, a powerful tool for specifying layouts +L+ and behaviors of graphical objects, and have been applied +L+ to 2D graphical user interfaces and specialized 3D graph- +L+ ics packages. In this paper, we present Chorus3D, a geo- +L+ metric constraint library for 3D graphical applications. It +L+ enables programmers to use geometric constraints for vari- +L+ ous purposes such as geometric layout, constrained dragging, +L+ and inverse kinematics. Its novel feature is to handle scene +L+ graphs by processing coordinate transformations in geomet- +L+ ric constraint satisfaction. We demonstrate the usefulness of +L+ Chorus3D by presenting sample constraint-based 3D graph- +L+ ical applications.
Keywords
geometric constraints, constraint satisfaction, geometric lay- +L+ out, 3D graphics, scene graphs
1. INTRODUCTION
Recent advances in commodity hardware have enabled fast +L+ high-quality 3D graphics on personal computers. Also, soft- +L+ ware technologies such as VRML and Java 3D have made the +L+ development of 3D graphical applications easier. However, +L+ most of such technologies mainly focus on rendering aspects +L+ of 3D graphics, and do not sufficiently support layout and +L+ behavior aspects.
Constraints are, in general, a powerful tool for specifying +L+ layouts and behaviors of graphical objects. It is widely +L+ recognized that constraints facilitate describing geometric +L+ layouts and behaviors of diagrams in 2D graphical user in- +L+ terfaces such as drawing editors, and therefore constraint +L+ solvers for this purpose have been extensively studied [3, 7,
Permission to make digital or hard copies of all or part of this work for +L+ personal or classroom use is granted without fee provided that copies are +L+ not made or distributed for profit or commercial advantage and that copies +L+ bear this notice and the full citation on the first page. To copy otherwise, to +L+ republish, to post on servers or to distribute to lists, requires prior specific +L+ permission and/or fee.
Int. Symp. on Smart Graphics, June 11-13, 2002, Hawthorne, NY, USA. +L+ Copyright 2002 ACM 1-58113-555-6/02/0600...$5.00
8, 9, 11, 12, 13, 17, 18]. Also, many specialized 3D graph- +L+ ics packages enable the specification of object layouts and +L+ behaviors by using constraints or similar functions.
It is natural to consider that various 3D graphical applica- +L+ tions can also be enhanced by incorporating constraints. It +L+ might seem sufficient for this purpose to modify existing 2D +L+ geometric constraint solvers to support 3D geometry. It is, +L+ however, insufficient in reality because of the essential dif- +L+ ference between the ways of specifying 2D and 3D graphics; +L+ typical 2D graphics handles only simple coordinate systems, +L+ whereas most 3D graphics requires multiple coordinate sys- +L+ tems with complex relations such as rotations to treat scene +L+ graphs. It means that we need to additionally support coor- +L+ dinate transformations in 3D geometric constraint solvers.
In this paper, we present Chorus3D, a geometric constraint +L+ library for 3D graphical applications. The novel feature of +L+ Chorus3D is to handle scene graphs by processing coordi- +L+ nate transformations in geometric constraint satisfaction. +L+ We have realized Chorus3D by adding this feature to our +L+ previous 2D geometric constraint library Chorus [13].
Another important point of Chorus3D is that it inherits from +L+ Chorus the capability to handle “soft” constraints with hier- +L+ archical strengths or preferences (i.e., constraint hierarchies +L+ [7]), which are useful for specifying default layouts and be- +L+ haviors of graphical objects. It determines solutions so that +L+ they satisfy as many strong constraints as possible, leaving +L+ weaker inconsistent constraints unsatisfied.
Chorus3D also inherits from Chorus a module mechanism +L+ which allows user-defined kinds of geometric constraints. +L+ This feature enables programmers to use geometric con- +L+ straints for various purposes including the following:
Geometric layout: A typical use of Chorus3D is to lay +L+ out graphical objects. For example, it allows putting +L+ objects parallel or perpendicular to others without re- +L+ quiring predetermined positioning parameters. Also, it +L+ provides constraint-based general graph layout based +L+ on the spring model [14].
Constrained dragging: Chorus3D enables dragging ob- +L+ jects with positioning constraints. For example, it +L+ can constrain a dragged object to be on the surface +L+ of a sphere. Constrained dragging is important for 3D +L+ graphics because it provides a sophisticated way to ac-
94
Translation: A translation transformation is characterized +L+ with three variables tx, tr, and tz, and specifies the +L+ translation of vector (tx,tr, tz).
Rotation: A rotation transformation is parameterized with +L+ four variables rx, rr, rz, and rw, and specifies the ro- +L+ tation of angle rw about the axis (rx, rr, rz).
Scale: A scale transformation is represented with three +L+ variables sx, sr, and sz, and specifies the axis-wise +L+ scale (sx, sr, sz) about the origin.
We can express many practically useful transformations by +L+ using such elemental ones. In fact, any transformations rep- +L+ resented with Transform nodes in VRML can be realized by +L+ combining these kinds of transformations [4].
3. CONSTRAINT FRAMEWORK
In this section, we briefly describe our framework for han- +L+ dling constraints. We base it on the framework for the 2D +L+ version of the Chorus constraint solver. See [13] for further +L+ detail.
3.1 Problem Formulation
We first present the mathematical formulation for modeling +L+ constraints and constraint systems. In the following, we +L+ write x to represent a variable vector (x1, x2, ... , xn) of +L+ n variables, and also v to indicate a variable value vector +L+ (v1, v2, ... , vn) of n real numbers (vi expresses the value of +L+ xi).
To support various geometric constraints in a uniform man- +L+ ner, we adopt error functions as a means of expressing con- +L+ straints. An error function e(x) is typically associated with +L+ a single arithmetic constraint, and is defined as a func- +L+ tion from variable value vectors to errors expressed as non- +L+ negative real numbers; that is, e(v) gives the error of the +L+ associated constraint for v. An error function returns a zero +L+ if and only if the constraint is exactly satisfied. For example, +L+ e(x) = (xi — xj)2 can be used for the constraint xi = xj. +L+ We assume that, for each e(x), its gradient is known:
De(x) =	�ae(x) ae(x) ae(x) ax1,ax2 ,...,axn )
In the same way as constraint hierarchies [7], constraint sys- +L+ tems in our framework can be divided into levels consisting +L+ of constraints with equal strengths. Constraints with the +L+ strongest preference are said to be required (or hard), and +L+ are guaranteed to be always satisfied (if it is impossible, +L+ there will be no solution). By contrast, constraints with +L+ weaker preferences are said to be preferential (or soft), and +L+ may be relaxed if they conflict with stronger constraints.
Solutions to constraint systems are defined as follows: let +L+ ei,j(x) be the error function of the j-th constraint (1 &lt; j &lt; +L+ mi) at strength level i (0 &lt; i &lt; l); then solutions v are +L+ determined with the optimization problem
minimize	E(v) subject to e0,j (v) = 0 (1 &lt; j &lt; m0)
v	
commodate ordinary mouse dragging to 3D spaces.
Inverse kinematics: Chorus3D is applicable to inverse +L+ kinematics, which is a problem of finding desired con- +L+ figurations of “articulated” objects [1, 20]. It allows +L+ the specification of articulated objects by using coor- +L+ dinate transformations, and can automatically calcu- +L+ late the parameters of the transformations that satisfy +L+ constraints. This method is also applicable to camera +L+ control by aiming at a possibly moving target object.
In this paper, we demonstrate the usefulness of Chorus3D +L+ by presenting sample constraint-based 3D graphical appli- +L+ cations.
This paper is organized as follows: We first present our ap- +L+ proach to the use of constraints for 3D graphics. Second, +L+ we describe our basic framework of constraints. Next, we +L+ present a method for processing coordinate transformations +L+ in our framework. We then provide the implementation of +L+ Chorus3D, and demonstrate examples of using constraints +L+ in 3D graphics. After giving related work and discussion, we +L+ mention the conclusions and future work of this research.
2. OUR APPROACH
In this research, we integrate geometric constraints with 3D +L+ graphics. Basically, we realize this by extending our previ- +L+ ous 2D geometric constraint solver Chorus [13] to support +L+ 3D geometry. However, as already mentioned, it is not a +L+ straightforward task because 3D graphics typically requires +L+ handling scene graphs with hierarchical structures of coor- +L+ dinate systems, which is not covered by the 2D version of +L+ the Chorus constraint solver.
To support hierarchies of coordinate systems, we introduce +L+ the following new model of constraints:
Point variables: Each point variable (which consists of +L+ three real-valued constrainable variables) is associated +L+ with one coordinate system, and its value is expressed +L+ as local coordinates.
Geometric constraints: Geometric constraints on point +L+ variables are evaluated by using the world coordinates +L+ of the point variables (they can also refer to 1D vari- +L+ ables for, e.g., distances and angles by using their val- +L+ ues directly). A single constraint can refer to point +L+ variables belonging to different coordinate systems.
Coordinate transformations: Parameters of coordinate +L+ transformations are provided as constrainable vari- +L+ ables, and the solver is allowed to change the param- +L+ eters of transformations to appropriately satisfy given +L+ constraints.
With this model, we can gain the benefit of the easy mainte- +L+ nance of geometric relations by using constraints, as well as +L+ the convenience of modeling geometric objects by employing +L+ scene graphs.
In our actual implementation, we provide the following three +L+ elemental kinds of coordinate transformations:
95
where E is an objective function defined as
wiei,j (x)
in which wi indicates the weight associated with strength i, +L+ and the relation w1 » w2 » . . . » wl holds. In this formu- +L+ lation, level 0 corresponds to required constraints, and the +L+ others to preferential ones. Intuitively, more weighted (or +L+ stronger) preferential constraints should be more satisfied.
Our framework simulates constraint hierarchies. Particu- +L+ larly, if the squares of constraint violations are used to com- +L+ pute error functions, a system in our framework will obtain +L+ approximate solutions to the similar hierarchy solved with +L+ the criterion least-squares-better [3, 17]. The largest differ- +L+ ence is that a system in our framework slightly considers a +L+ weak constraint inconsistent with a stronger satisfiable one +L+ in computing its solutions, while the similar hierarchy would +L+ discard such a weak one.
Our actual implementation of the Chorus3D constraint +L+ solver provides four external strengths required, strong, +L+ medium, and weak as well as two internal strengths very +L+ strong (used to approximately handle required nonlinear +L+ or inequality constraints) and very weak (exploited to make +L+ new solutions as close to previous ones as possible). It typ- +L+ ically assigns weights 324, 323, 322, 321, and 1 to strengths +L+ very strong, strong, medium, weak, and very weak respec- +L+ tively. These weights were determined according to the pre- +L+ cision of the actual numerical algorithm (described in the +L+ next subsection). To know how much these weights affect +L+ solutions, suppose a system of strong constraint x = 0 and +L+ medium one x = 100. Then the unique solution will be ob- +L+ tained as x = 3.0303 . . . (= 100/33). Thus the difference of +L+ strengths is obvious. According to our actual experience, +L+ this precision allows us to discriminate constraint strengths +L+ in most graphical applications.
3.2 Algorithm
To actually find solutions to constraint systems presented +L+ above, we need to solve their corresponding optimization +L+ problems. For this purpose, we designed a constraint sat- +L+ isfaction algorithm by combining a numerical optimization +L+ technique with a genetic algorithm. It uses numerical op- +L+ timization to find local solutions, while it adopts a genetic +L+ algorithm to search for global solutions.
For numerical optimization, we mainly use the quasi-Newton +L+ method based on Broyden-Fletcher-Goldfarb-Sahnno updat- +L+ ing formula [2, 6], which is a fast iterative technique that +L+ exhibits superlinear convergence. Since it excludes fruit- +L+ less searches by utilizing its history, it is usually faster than +L+ straightforward Newton’s method.
We introduced a genetic algorithm to alleviate the problem +L+ that some kinds of geometric constraints suffer from local op- +L+ timal but global non-optimal solutions [11, 16]. Generally, +L+ a genetic algorithm is a stochastic search method that re- +L+ peatedly transforms a population of potential solutions into +L+ another next-generation population [10, 15]. We typically +L+ necessitate it only for computing initial solutions; in other +L+ words, we can usually re-solve modified constraint systems
without the genetic algorithm, only by applying numerical +L+ optimization to previous solutions.
4. PROCESSING COORDINATE +L+ TRANSFORMATIONS
In this section, we propose a method for integrating coordi- +L+ nate transformations with our constraint framework.
As already mentioned, we use world coordinates of points +L+ to evaluate 3D geometric constraints. A naive method for +L+ this is to duplicate point variables in all ancestor coordinate +L+ systems, and then to impose required constraints that rep- +L+ resent coordinate transformations between the point vari- +L+ ables. However, this method requires an optimization rou- +L+ tine supporting required nonlinear constraints, which lim- +L+ its the availability of actual techniques (in fact, we cannot +L+ use the quasi-Newton method for this purpose). Also, this +L+ method tends to yield many variables and constraints, and +L+ therefore requires an extra amount of memory.
Below we propose a more widely applicable method for han- +L+ dling coordinate transformations. Its characteristic is to +L+ hide transformations from optimization routines, which is +L+ realized by embedding transformations in error functions.
4.1 Model
To begin with, we introduce another variable vector x&apos; = +L+ (x&apos;1, x&apos;2, ... ,x&apos; n), which is created by replacing variables for +L+ local coordinates of 3D points in x with the corresponding +L+ ones for world coordinates (1D variables remain the same). +L+ We can mathematically model this process as follows: Con- +L+ sider the sequence of the s transformations
t0	t1	s 2	ts 1
y0 (= x)� y1 �... t y3-1 —� y3 (= x&apos;)
where y0 and y3 are equal to x and x&apos; respectively, each +L+ yk (1 &lt; k &lt; s — 1) is an “intermediate” vector, and each tk +L+ (0 &lt; k &lt; s — 1) is a function that transforms yk into yk+1. +L+ Intuitively, tk corresponds to a coordinate transformation, +L+ and transforms related point variables from its source co- +L+ ordinate system into its destination system. It should be +L+ noted that, although transformations are, in general, hier- +L+ archical (or tree-structured), we can always find such a linear +L+ sequence by “serializing” them in an appropriate order.
By using such transformations, we can compute x&apos; as fol- +L+ lows:
x&apos; = t3-1(t3-2(...(t1(t0(x))) ... )) = t(x)
where t is defined as the composition of all the elemental +L+ transformations. In the following description, we write yk,i +L+ to denote the i-th element of yk, and also tk,i to represent +L+ the i-th element of tk; that is,
yk+1 = (yk+1,1 , yk+1,2, ... , yk+1,n)
= (tk,1(yk),tk,2(yk), ..., tk,n(yk)) = tk(yk).
4.2 Method
Geometric constraints are evaluated by using world coordi- +L+ nates of points, which means that their error functions are
Mi
E
j=1
E(x) =
�l +L+ i=1
96
defined as e(x&apos;). Using the composed transformations, we	parameter of the coordinate transformation), we have
can evaluate them as	yk,i = xi, which means that we have atk,j(yk)/axi.
e(x&apos;) = e(t(x)).	Therefore, we can compute ae(x&apos;)/axi immediately.
Importantly, we can efficiently realize this computation by +L+ applying only necessary transformations to actually used +L+ variables.
We also need to compute the gradient of e(t(x)), i.e.,
�ae(t(x)) ae(t(x)) ae(t(x))  +L+ ax1 , ax2 , ..., axn ) .
Basically, we can decompose each partial derivative +L+ ae(t(x))/axi into primitive expressions by repeatedly us- +L+ ing the chain rule. However, we should avoid the simple +L+ application of the chain rule since it would result in a large +L+ number of expressions.
Instead, we perform a controlled way of decomposing such +L+ partial derivatives; it appropriately arranges the chain rule +L+ to restrict the computation to only necessary components. +L+ First, we decompose ae(t(x))/axi as follows:
ats-1,j,(ys-1)
axi
ae(x&apos;)	ats-1,j,(ys-1)ats-2,js_1(ys-2)
axj,Eays-1,js_1	axi
js_1
ats-2,js_1(ys-2)
axi
ae(x&apos;) ats-2,js_1(ys-2)
ays-1,js_1	axi	.
Note that each ae(x&apos;)/ax&apos;j, is given by the defini- +L+ tion of the geometric constraint, and also that each
ats-1,j,(ys-1)/ays-1,js_1 is a partial derivative in the gra-
dient of a single coordinate transformation ts-1. Thus we
can obtain each ae(x&apos;)/ays-1 ,js_1. Also, by repeating this
process, we can compute, for each k,
atk-1,jk (yk-1)
and finally achieve
ae(t(x))
axi
where each at0,j1(x)/axi is a component of the gradient of
t0. Therefore, ae(t(x))/axi is now determined.
Furthermore, we can considerably reduce the number of the +L+ computations of ae(x&apos;)/ayk,jk in practice. We can make the +L+ following observations about the above computation:
9 For each variable xj,, ae(x&apos;)/ax&apos;j, can be non-zero only +L+ if xj,is actually needed to evaluate the designated con- +L+ straint.
9 If xi is originated in the coordinate system associated +L+ with tk (that is, xi is either a local coordinate or a
These observations reveal that we need to transfer a partial +L+ derivative ae(x&apos;)/ayk,j to the next step only when xj rep- +L+ resents a really necessary coordinate that has not reached +L+ its local coordinate system. Also, since we can handle each +L+ necessary point independently, we can implement this pro- +L+ cess with a linear recursive function that hands over only +L+ three derivatives ae(x&apos;)/ayk,j at each recursive call.
5. IMPLEMENTATION
We implemented the proposed method by developing a con- +L+ straint solver called Chorus3D, which is a 3D extension to +L+ our previous 2D geometric constraint solver Chorus [13]. We +L+ constructed Chorus3D as a C++ class library, and also de- +L+ veloped a native method interface to make it available to +L+ Java programs.
Chorus3D allows programmers to add a new kind of arith- +L+ metic constraints (e.g., Euclidean geometric constraints) by +L+ constructing a new constraint class with a method that eval- +L+ uates their error functions. Also, programmers can intro- +L+ duce a new kind of non-arithmetic (or pseudo) constraints +L+ (for, e.g., general graph layout) by developing a new evalua- +L+ tion module which computes an “aggregate” error function +L+ for a given set of constraints.
Chorus3D currently provides linear equality, linear inequal- +L+ ity, edit (update a variable value), stay (fix a variable value), +L+ Euclidean geometric constraints (for, e.g., parallelism, per- +L+ pendicularity, and distance equality), and graph layout con- +L+ straints based on the spring model [14]. Linear equality/ +L+ inequality constraints can refer to only 1D variables (includ- +L+ ing elements of 3D point variables), while edit and stay con- +L+ straints can be associated with 1D and 3D point variables. +L+ Euclidean geometric constraints typically refer to point vari- +L+ ables although they sometimes require 1D variables for an- +L+ gles and distances. Each graph layout constraint represents +L+ a graph edge, and refers to two point variables as its asso- +L+ ciated graph nodes. As stated earlier, constraints on such +L+ point variables are evaluated by using world coordinates of +L+ the points. Also, a single constraint can refer to point vari- +L+ ables belonging to different coordinate systems.
The application programming interface of Chorus3D is a +L+ natural extension to that of Chorus, which provides a certain +L+ compatibility with a recent linear solver called Cassowary +L+ [3]; in a similar way to Cassowary and Chorus, Chorus3D +L+ allows programmers to process constraint systems by cre- +L+ ating variables and constraints as objects, and by adding/ +L+ removing constraint objects to/from the solver object. In +L+ addition, Chorus3D handles coordinate transformations as +L+ objects, and presents an interface for arranging them hier- +L+ archically.
6. EXAMPLES
In this section, we present three examples to demonstrate +L+ how to incorporate geometric constraints into 3D graphics +L+ by using the Chorus3D constraint solver. All the examples +L+ are implemented in Java by using Java 3D as a graphics
De(t(x)) =
ae(t(x))
axi
=E
j,
ae(x&apos;)
ax&apos;j,
=E
j,
= E
js_1
= E
js_1
I
ats1,j, (ys-1)
ae(x&apos;)
E
ays-1,js_1
j,
ax&apos;j,
I
ae(t(x))
axi
=E	ae(x&apos;)
jk	
	ayk,jk
=E	ae(x&apos;)
j1	
	ay1,j1
axi
at0,j1(x)
axi
97
Figure 1: A 3D geometric layout of a general graph +L+ structure.
Figure 2: Dragging an object constrained to be on +L+ a sphere.
programming interface as well as the native method interface +L+ with Chorus3D. We also provide computation times taken +L+ for constraint satisfaction in these examples.
6.1 Graph Layout
The first example is an application which lays out a set +L+ of points with a general graph structure in a 3D space as +L+ shown in Figure 1. This application also allows a user to
drag graph nodes with a mouse.&apos; The used graph layout
technique is based on a 3D extension to the spring model +L+ [14]. This kind of 3D graph layout is practically useful to +L+ information visualization, and has actually been adopted in +L+ a certain system [19].
The constraint system of this graph layout consists of 26 +L+ point variables (i.e., 78 real-valued variables), 31 graph lay- +L+ out constraints, and three linear equality constraints for fix- +L+ ing one of the point variables at the origin. When executed +L+ on an 866 MHz Pentium III processor running Linux 2.2.16, +L+ Chorus3D obtained an initial solution in 456 milliseconds. It +L+ performed constraint satisfaction typically within 250 mil- +L+ liseconds to reflect the user’s dragging a graph node.
6.2 Constrained Dragging
The second example is an application which allows a user +L+ to drag an object constrained to be on another spherical +L+ object. Figure 2 depicts this application, where the smaller +L+ solid spherical object is constrained to be on the surface of +L+ the larger wireframe one. The application declares a strong +L+ Euclidean geometric constraint which specifies a constant +L+ distance between the centers of these objects. When the +L+ user tries to drag the smaller object with a mouse, the appli- +L+ cation imposes another medium Euclidean constraint which +L+ collinearly locates the viewpoint, the 3D position of the +L+ mouse cursor (which is considered to be on the screen), and
&apos;Unlike constrained dragging in the next example, this
mouse operation is simply implemented with Java 3D’s +L+ PickMouseBehavior classes.
Sphere
Figure 3: Implementation of constrained dragging.
the center of the dragged object as shown in Figure 3. This +L+ collinearity constraint reflects the motion of the mouse in +L+ the position of the dragged object. Since the collinearity +L+ constraint is weaker than the first Euclidean constraint, the +L+ user cannot drag the smaller object to the outside of the +L+ larger sphere.
The application initially declares one Euclidean geometric +L+ constraint on two point variables, and solved it in 1 mil- +L+ lisecond on the same computer as the first example. When +L+ the user tries to drag the smaller object, it adds another +L+ Euclidean constraint as well as two edit constraints for the +L+ viewpoint and mouse position. The solver maintained this +L+ constraint system usually within 2 milliseconds.
6.3 Inverse Kinematics
The final example applies inverse kinematics to a virtual +L+ robot arm by using constraints. Unlike the previous ex- +L+ amples, it takes advantage of coordinate transformations to +L+ express its constraint system.
Mouse cursor which +L+ is on the screen
Viewpoint
Distance +L+ constraint
Collinearity +L+ constraint
Object which is on +L+ the sphere surface
Screen
98
(a)	(b)	(c)
Figure 4: A robot arm application which performs inverse kinematics.
(d)	(e)	(f)
As illustrated in Figure 4(a), the robot arm consists of four +L+ parts called a base, a shoulder, an upper arm, and a forearm. +L+ Constraint satisfaction for inverse kinematics is performed +L+ to position its hand (the end of the forearm) at the target +L+ object if possible, or otherwise to make it maximally close +L+ to the target. Figures 4(b)–(f) show the movement of the +L+ robot arm. In Figures 4(b)–(e), its hand is positioned at +L+ the exact location of the target by using appropriate angles +L+ of its joints. By contrast, in Figure 4(f), the hand cannot +L+ reach the target, and therefore the arm is extended toward +L+ the target instead.
Figure 5 describes the constraint program used in the robot +L+ arm application. After constructing a constraint solver +L+ s, it creates six coordinate transformations shldrTTfm, +L+ shldrRTfm, uarmTTfm, uarmRTfm, farmTTfm, and farmRTfm. +L+ Here the rotation angle parameters of the rotation trans- +L+ formations shldrRTfm, uarmRTfm, and farmRTfm will actu- +L+ ally work as variables that can be altered by the solver. +L+ Next, it generates a point variable handPos to represent +L+ the position of the hand, and then suggests the target po- +L+ sition to the hand by using a preferential edit constraint +L+ editHandPos. Finally, executing the solver, it obtains the +L+ desired angles shldrAngle, uarmAngle, and farmAngle of
the rotation transformations. These angles will be passed +L+ to the Java 3D library to render the properly configured +L+ robot arm.
This program generates a constraint system which contains +L+ three translation and three rotation transformations, one ex- +L+ plicit point variable as well as six point variables and three +L+ 1D variables for coordinate transformations, and one edit +L+ constraint. The solver found an initial solution to this sys- +L+ tem in 18 milliseconds, and obtained each new solution for +L+ a frame update typically within 10 milliseconds.
7. RELATED WORK AND DISCUSSION
There has been work on integrating constraints or similar +L+ functions with 3D graphics languages to facilitate the spec- +L+ ification of graphical objects. For example, we can view the +L+ event routing mechanism in VRML [4] as a limited form of +L+ one-way propagation constraints. Also, there is an attempt +L+ to extend VRML by introducing one-way propagation and +L+ finite-domain combinatorial constraints [5]. However, they +L+ cannot handle more powerful simultaneous nonlinear con- +L+ straints such as Euclidean geometric constraints.
Although many constraint solvers have been developed in
99
// constraint solver
s = new C3Solver();
// translation transformation for the shoulder: fixed to (0, .1, 0)
shldrTTfm = new C3TranslateTransform(new C3Domain3D(0, .1, 0)); +L+ s.add(shldrTTfm); // shldrTTfm is parented by the world coordinate system
// rotation transformation for the shoulder: axis fixed to (0, 1, 0); angle ranging over [-10000, 10000]
shldrRTfm = new C3RotateTransform(new C3Domain3D(0, 1, 0), new C3Domain(-10000, 10000)); +L+ s.add(shldrRTfm, shldrTTfm); // shldrRTfm is parented by shldrTTfm
// translation transformation for the upper arm: fixed to (0, .1, 0)
uarmTTfm = new C3TranslateTransform(new C3Domain3D(0, .1, 0)); +L+ s.add(uarmTTfm, shldrRTfm); // uarmTTfm is parented by shldrRTfm
// rotation transformation for the upper arm: axis fixed to (0, 0, 1); angle ranging over [-1.57,1.57]
uarmRTfm = new C3RotateTransform(new C3Domain3D(0, 0, 1), new C3Domain(-1.57, 1.57)); +L+ s.add(uarmRTfm, uarmTTfm); // uarmRTfm is parented by uarmTTfm
// translation transformation for the forearm: fixed to (0, .5, 0)
farmTTfm = new C3TranslateTransform(new C3Domain3D(0, .5, 0)); +L+ s.add(farmTTfm, uarmRTfm); // farmTTfm is parented by uarmRTfm
// rotation transformation for the forearm: axis fixed to (0, 0, 1); angle ranging over [-3.14, 0]
farmRTfm = new C3RotateTransform(new C3Domain3D(0, 0, 1), new C3Domain(-3.14, 0)); +L+ s.add(farmRTfm, farmTTfm); // farmRTfm is parented by farmTTfm
// variable for the hand’s position, associated with farmRTfm and fixed to (0, .5, 0)
handPos = new C3Variable3D(farmRTfm, new C3Domain3D(0, .5, 0));
// medium-strength edit constraint for the hand’s position
editHandPos = new C3EditConstraint(handPos, C3.MEDIUM); +L+ s.add(editHandPos);
// suggest the hand being located at the target’s position
editHandPos.set(getTargetWorldCoordinates() );
// solve the constraint system
s.solve();
// get solutions
double shldrAngle = shldrRTfm.rotationAngle().value() ; +L+ double uarmAngle = uarmRTfm.rotationAngle().value(); +L+ double farmAngle = farmRTfm.rotationAngle().value();
Figure 5: Constraint program for the robot arm application.
the field of graphical user interfaces [3, 7, 11, 12, 13, 17, 18], +L+ most of them do not provide special treatment for 3D graph- +L+ ics. In general, the role of nonlinear geometric constraints +L+ is more important in 3D applications than in 2D interfaces. +L+ Most importantly, 3D graphics usually requires rotations of +L+ objects which are rarely used in 2D interfaces. The main +L+ reason is that we often equally treat all “horizontal” direc- +L+ tions in a 3D space even if we may clearly distinguish them +L+ from “vertical” directions. Therefore, nonlinear constraint +L+ solvers are appropriate for 3D applications. In addition, co- +L+ ordinate transformations should be supported since they are +L+ typically used to handle rotations of objects.
Gleicher proposed the differential approach [8, 9], which sup- +L+ ports 3D geometric constraints and coordinate transforma- +L+ tions. In a sense, it shares a motivation with Chorus3D; in +L+ addition to support for 3D graphics, it allows user-defined +L+ kinds of geometric constraints. However, it is based on a dif- +L+ ferent solution method from Chorus3D; it realizes constraint +L+ satisfaction by running virtual dynamic simulations. This +L+ difference results in a quite different behavior of solutions as +L+ well as an interface for controlling solutions. By contrast, +L+ Chorus3D provides a much more compatible interface with +L+ recent successful solvers such as Cassowary [3].
Much research on inverse kinematics has been conducted in +L+ the fields of computer graphics and robotics [1, 20]. How- +L+ ever, inverse kinematics is typically implemented as special- +L+ ized software which only provides limited kinds of geometric
constraints.
Chorus3D has two limitations in its algorithm: one is on the +L+ precision of solutions determined by preferential constraints; +L+ the other is on the speed of the satisfaction of large con- +L+ straint systems. These limitations are mainly caused by the +L+ treatment of multi-level preferences of constraints in addi- +L+ tion to required constraints (i.e., constraint hierarchies). Al- +L+ though many numerical optimization techniques have been +L+ proposed and implemented in the field of mathematical pro- +L+ gramming [2, 6], most of them do not handle preferential +L+ constraints. To alleviate the limitations of Chorus3D, we +L+ are pursuing a more sophisticated method for processing +L+ multi-level preferential constraints.
We implemented Chorus3D as a class library which can +L+ be exploited in C++ and Java programs. However, more +L+ high-level authoring tools will also be useful for declarative +L+ approaches to 3D design. One possible direction is to ex- +L+ tend VRML [4] to support geometric constraints. Standard +L+ VRML requires scripts in Java or JavaScript to realize com- +L+ plex layouts and behaviors. By contrast, constraint-enabled +L+ VRML will cover a wider range of applications without such +L+ additional scripts.
8. CONCLUSIONS AND FUTURE WORK
In this paper, we presented Chorus3D, a geometric con- +L+ straint library for 3D graphical applications. It enables pro- +L+ grammers to use geometric constraints for various purposes
100
such as geometric layout, constrained dragging, and inverse +L+ kinematics. Its novel feature is to handle scene graphs +L+ by processing coordinate transformations in geometric con- +L+ straint satisfaction.
Our future work includes the development of other kinds of +L+ geometric constraints to further prove the usefulness of our +L+ approach. In particular, we are planning to implement non- +L+ overlapping constraints [13] in Chorus3D so that we can use +L+ it for the collision resolution of graphical objects. Another +L+ future direction is to improve Chorus3D in the scalability +L+ and accuracy of constraint satisfaction.
9. REFERENCES
[1] Badler, N. I., Phillips, C. B., and Webber, B. L. +L+ Simulating Humans: Computer Graphics, Animation, +L+ and Control. Oxford University Press, Oxford, 1993.
[2] Bertsekas, D. P. Nonlinear Programming, 2nd ed. +L+ Athena Scientific, 1999.
[3] Borning, A., Marriott, K., Stuckey, P., and Xiao, Y. +L+ Solving linear arithmetic constraints for user interface +L+ applications. In Proc. ACM UIST, 1997, 87–96.
[4] Carey, R., Bell, G., and Marrin, C. The Virtual +L+ Reality Modeling Language (VRML97). ISO/IEC +L+ 14772-1:1997, The VRML Consortium Inc., 1997.
[5] Diehl, S., and Keller, J. VRML with constraints. In +L+ Proc. Web3D-VRML, ACM, 2000, 81–86.
[6] Fletcher, R. Practical Methods of Optimization, +L+ 2nd ed. John Wiley &amp; Sons, 1987.
[7] Freeman-Benson, B. N., Maloney, J., and Borning, A. +L+ An incremental constraint solver. Commun. ACM 33, +L+ 1 (1990), 54–63.
[8] Gleicher, M. A graphical toolkit based on differential +L+ constraints. In Proc. ACM UIST, 1993, 109–120.
[9] Gleicher, M. A differential approach to graphical +L+ manipulation (Ph.D. thesis). Tech. Rep. +L+ CMU-CS-94-217, Sch. Comput. Sci. Carnegie Mellon +L+ Univ., 1994.
[10] Herrera, F., Lozano, M., and Verdegay, J. L. Tackling +L+ real-coded genetic algorithms: Operators and tools for +L+ behavioural analysis. Artif. Intell. Rev. 12, 4 (1998), +L+ 265–319.
[11] Heydon, A., and Nelson, G. The Juno-2 +L+ constraint-based drawing editor. Research Report +L+ 131a, Digital Systems Research Center, 1994.
[12] Hosobe, H. A scalable linear constraint solver for user +L+ interface construction. In Principles and Practice of +L+ Constraint Programming—CP2000, vol. 1894 of +L+ LNCS, Springer, 2000, 218–232.
[13] Hosobe, H. A modular geometric constraint solver for +L+ user interface applications. In Proc. ACM UIST, 2001, +L+ 91–100.
[14] Kamada, T., and Kawai, S. An algorithm for drawing +L+ general undirected graphs. Inf. Process. Lett. 31, 1 +L+ (1989), 7–15.
[15] Kitano, H., Ed. Genetic Algorithms. Sangyo-Tosho, +L+ 1993. In Japanese.
[16] Kramer, G. A. A geometric constraint engine. Artif. +L+ Intell. 58, 1–3 (1992), 327–360.
[17] Marriott, K., Chok, S. S., and Finlay, A. A tableau +L+ based constraint solving toolkit for interactive +L+ graphical applications. In Principles and Practice of +L+ Constraint Programming—CP98, vol. 1520 of LNCS, +L+ Springer, 1998, 340–354.
[18] Sannella, M. Skyblue: A multi-way local propagation +L+ constraint solver for user interface construction. In +L+ Proc. ACM UIST, 1994,137–146.
[19] Takahashi, S. Visualizing constraints in visualization +L+ rules. In Proc. CP2000 Workshop on Analysis and +L+ Visualization of Constraint Programs and Solvers, +L+ 2000.
[20] Zhao, J., and Badler, N. I. Inverse kinematics +L+ positioning using nonlinear programming for highly +L+ articulated figures. ACM Trans. Gr. 13, 4 (1994), +L+ 313–336.
101
