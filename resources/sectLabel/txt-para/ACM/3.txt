# Para 0 2
A Computational Approach to Reflective Meta-Reasoning about
Languages with Bindings *
# Para 2 1
Aleksey Nogin Alexei Kopylov Xin Yu Jason Hickey
# Para 3 4
Department of Computer Science
California Institute of Technology
M/C 256-80, Pasadena, CA 91125
{nogin,kopylov,xiny,jyh}@cs.caltech.edu
# Para 7 1
Abstract
# Para 8 23
We present a foundation for a computational meta-theory of lan-
guages with bindings implemented in a computer-aided formal rea-
soning environment. Our theory provides the ability to reason ab-
stractly about operators, languages, open-ended languages, classes 
of languages, etc. The theory is based on the ideas of higher-order 
abstract syntax, with an appropriate induction principle parameter-
ized over the language (i. e. a set of operators) being used. In our ap-
proach, both the bound and free variables are treated uniformly and 
this uniform treatment extends naturally to variable-length bind-
ings. The implementation is reflective, namely there is a natural 
mapping between the meta-language of the theorem-prover and the 
object language of our theory. The object language substitution op-
eration is mapped to the meta-language substitution and does not 
need to be defined recursively. Our approach does not require de-
signing a custom type theory; in this paper we describe the im-
plementation of this foundational theory within a general-purpose 
type theory. This work is fully implemented in the MetaPRL the-
orem prover, using the pre-existing NuPRL-like Martin-L¨of-style 
computational type theory. Based on this implementation, we lay 
out an outline for a framework for programming language experi-
mentation and exploration as well as a general reflective reasoning 
framework. This paper also includes a short survey of the existing 
approaches to syntactic reflection.
# Para 31 4
Categories and Subject Descriptors D.3.1 [Programming Lan-
guages]: Formal Definitions and Theory—Syntax; F.4.3 [Math-
ematical Logic and Formal Languages]: Formal Languages— 
Operations on languages
# Para 35 1
General Terms Languages, Theory, Verification
# Para 36 3
Keywords Higher-Order Abstract Syntax, Reflection, Type The-
ory, Meta PRL, N uPRL, Programming Language Experimentation, 
Languages with Bindings.
# Para 39 2
* An extended version of this paper is available as Caltech Technical Report 
CaltechCSTR:2005.003 [NKYH05]
# Para 41 5
Permission to make digital or hard copies of all or part of this work for personal or 
classroom use is granted without fee provided that copies are not made or distributed 
for profit or commercial advantage and that copies bear this notice and the full citation 
on the first page. To copy otherwise, to republish, to post on servers or to redistribute 
to lists, requires prior specific permission and/or a fee.
# Para 46 1
MERLIN’05 September 30, 2005, Tallinn, Estonia.
# Para 47 1
Copyright �c 2005 ACM 1-59593-072-8/05/0009...$5.00.
# Para 48 1
1. Introduction
# Para 49 1
1.1 Reflection
# Para 50 4
Very generally, reflection is the ability of a system to be “self- 
aware” in some way. More specifically, by reflection we mean the 
property of a computational or formal system to be able to access 
and internalize some of its own properties.
# Para 54 6
There are many areas of computer science where reflection 
plays or should play a major role. When exploring properties of 
programming languages (and other languages) one often realizes 
that languages have at least two kinds of properties — semantic 
properties that have to do with the meaning of what the language’s 
constructs express and syntactic properties of the language itself.
# Para 60 11
Suppose for example that we are exploring some language that 
contains arithmetic operations. And in particular, in this language 
one can write polynomials like x2 +2x + 1. In this case the number 
of roots of a polynomial is a semantic property since it has to do 
with the valuation of the polynomial. On the other hand, the degree 
of a polynomial could be considered an example of a syntactic 
property since the most natural way to define it is as a property of 
the expression that represents that polynomial. Of course, syntactic 
properties often have semantic consequences, which is what makes 
them especially important. In this example, the number of roots of 
a polynomial is bounded by its degree.
# Para 71 6
Another area where reflection plays an important role is run-
time code generation — in most cases, a language that supports 
run-time code generation is essentially reflective, as it is capable 
of manipulating its own syntax. In order to reason about run-time 
code generation and to express its semantics and properties, it is 
natural to use a reasoning system that is reflective as well.
# Para 77 9
There are many different flavors of reflection. The syntactic 
reflection we have seen in the examples above, which is the ability 
of a system to internalize its own syntax, is just one of these 
many flavors. Another very important kind of reflection is logical 
reflection, which is the ability of a reasoning system or logic to 
internalize and reason about its own logical properties. A good 
example of a logical reflection is reasoning about knowledge — 
since the result of reasoning about knowledge is knowledge itself, 
the logic of knowledge is naturally reflective [Art04].
# Para 86 6
In most cases it is natural for reflection to be iterated. In the 
case of syntactic reflection we might care not only about the syntax 
of our language, but also about the syntax used for expressing the 
syntax, the syntax for expressing the syntax for expressing the 
syntax and so forth. In the case of the logic of knowledge it is 
natural to have iterations of the form “I know that he knows that
# Para 92 1
I know ...”.
# Para 93 2
When a formal system is used to reason about properties of pro-
gramming languages, iterated reflection magnifies the power of the
# Para 95 1
2
# Para 96 9
system, making it more natural to reason not just about individual 
languages, but also about classes of languages, language schemas, 
and so on. More generally, reflection adds a lot of additional power 
to a formal reasoning system [GS89, Art99]. In particular, it is 
well-known [G¨od36, Mos52, EM71, Par71] that reflection allows 
a super-exponential reduction in the size of certain proofs. In addi-
tion, reflection could be a very useful mechanism for implement-
ing proof search algorithms [ACU93, GWZ00, CFW04]. See also 
[Har95] for a survey of reflection in theorem proving.
# Para 105 1
1.2 Uniform Reflection Framework
# Para 106 10
For each of the examples in the previous section there are many 
ad-hoc ways of achieving the specific benefits of a specific fla-
vor of reflection. This work aims at creating a unifying reflective 
framework that would allow achieving most of these benefits in a 
uniform manner, without having to reinvent and re-implement the 
basic reflective methodology every time. We believe that such a 
framework will increase the power of the formal reasoning tools, 
and it may also become an invaluable tool for exploring the proper-
ties of novel programming languages, for analyzing run-time code 
generation, and for formalizing logics of knowledge.
# Para 116 3
This paper establishes a foundation for the development of this 
framework — a new approach to reflective meta-reasoning about 
languages with bindings. We present a theory of syntax that:
# Para 119 3
•	in a natural way provides both a higher-order abstract syntax 
(HOAS) approach to bindings and a de Bruijn-style approach 
to bindings, with easy and natural translation between the two;
# Para 122 3
•	provides a uniform HOAS-style approach to both bound and 
free variables that extends naturally to variable-length “vectors” 
of binders;
# Para 125 4
•	permits meta-reasoning about languages — in particular, the 
operators, languages, open-ended languages, classes of lan-
guages etc. are all first-class objects that can be reasoned about 
both abstractly and concretely;
# Para 129 2
•	comes with a natural induction principle for syntax that can be 
parameterized by the language being used;
# Para 131 4
•	provides a natural mapping between the object syntax and meta- 
syntax that is free of exotic terms, and allows mapping the 
object-level substitution operation directly to the meta-level one 
(i.e. P-reduction);
# Para 135 2
•	is fully derived in a pre-existing type theory in a theorem 
prover;
# Para 137 2
•	is designed to serve as a foundation for a general reflective 
reasoning framework in a theorem prover;
# Para 139 2
•	is designed to serve as a foundation for a programming lan-
guage experimentation framework.
# Para 141 12
The paper is structured as follows. Our work inherits a large 
number of ideas from previous efforts and we start in Section 2 
with a brief survey of existing techniques for formal reasoning 
about syntax. Next in Section 3 we outline our approach to rea-
soning about syntax and in Section 4 we present a formal account 
of our theory based on a Martin-L¨of style computational type the-
ory [CAB+86, HAB+] and the implementation of that account in 
the MetaPRL theorem prover [Hic97, Hic99, Hic01, HNC+03, 
HNK+, HAB+]. Then in Section 5 we outline our plan for building 
a uniform reflection framework based on the syntactic reflection. 
Finally, in Section 6 we resume the discussion of related work that 
was started in Section 2. 
# Para 153 1
1.3 Notation and Terminology
# Para 154 5
We believe that our approach to reasoning about syntax is fairly 
general and does not rely on any special features of the theo-
rem prover we use. However, since we implement this theory in 
MetaPRL, we introduce some basic knowledge about MetaPRL 
terms.
# Para 159 1
A MetaPRL term consists of:
# Para 160 2
1. An operator name (like “sum”), which is a unique name indi-
cating the logic and component of a term;
# Para 162 2
2. A list of parameters representing constant values; and 
3. A set of subterms with possible variable bindings.
# Para 164 2
We use the following syntax to describe terms, based on the N u P R L 
definition [ACHA90]:
# Para 166 6
In addition, MetaPRL has a meta-syntax somewhat similar to 
the higher-order abstract syntax presented in Pfenning and Elliott 
[PE88]. MetaPRL uses the second-order variables in the style of 
Huet and Lang [HL78] to describe term schemas. For example, 
Xx.V [x], where V is a second-order variable of arity 1, is a schema 
that stands for an arbitrary term whose top-level operator is X.
# Para 172 9
This meta-syntax requires that every time a binding occurrence 
is explicitly specified in a schema, all corresponding bound occur-
rences have to be specified as well. This requirement makes it very 
easy to specify free variable restrictions — for example, Xx.V, 
where V is a second-order meta-variable of arity 0, is a schema 
that stands for an arbitrary term whose top-level operator is X and 
whose body does not have any free occurrences of the variable 
bound by that X. In particular, the schema Xx. V matches the term 
Xy.1, but not the term Xx.x.
# Para 181 4
In addition, this meta-language allows specifying certain term 
transformations, including implicit substitution specifications. For 
example, a beta reduction transformation may be specified using 
the following schema:
# Para 185 1
(Xx.V1 [x]) V2 H V1 [V2]
# Para 186 1
Here the substitution of V2 for x in V1 is specified implicitly.
# Para 187 4
Throughout this paper we will use this second-order notation to 
denote arbitrary terms — namely, unless stated otherwise, when we 
write “Xx.t[x]” we mean an arbitrary term of this form, not a term 
containing a concrete second-order variable named “t”.
# Para 191 10
As in LF [HHP93] we assume that object level variables (i.e. 
the variables of the language whose syntax we are expressing) 
are directly mapped to meta-theory variables (i.e. the variable of 
the language that we use to express the syntax). Similarly, we 
assume that the object-level binding structure is mapped to the 
meta-level binding structure. In other words, the object-level notion 
of the “binding/bound occurrence” is a subset of that in the meta-
language. We also consider a-equal terms — both on the object 
level and on the meta-level — to be identical and we assume that 
substitution avoids capture by renaming.
# Para 201 4
The sequent schema language we use [NH02] contains a num-
ber of more advanced features in addition to those outlined here. 
However, for the purposes of this presentation, the basic features 
outlined above are sufficient.
# Para 205 1
2. Previous Models of Reflection
# Para 206 3
In 1931 G¨odel used reflection to prove his famous incompleteness 
theorem [G¨od31]. To express arithmetic in arithmetic itself, he 
assigned a unique number (a G¨odel number) to each arithmetic
# Para 209 1
opname
# Para 210 1
�- J 
# Para 211 1
operator name
# Para 212 1
[p1; .. .; pn] f�v1.t1; . . . ; �vm.tm}
# Para 213 1
Y	Y	J
# Para 214 1
parameters	subterms
# Para 215 1
3
# Para 216 2
formula. A G¨odel number of a formula is essentially a numeric 
code of a string of symbols used to represent that formula.
# Para 218 5
A modern version of the G¨odel’s approach was used by Aitken 
et al. [ACHA90, AC92, ACU93, Con94] to implement reflection 
in the NuPRL theorem prover [CAB+86, ACE+00]. A large part 
of this effort was essentially a reimplementation of the core of the 
NuPRL prover inside NuPRL’s logical theory.
# Para 223 16
In G¨odel’s approach and its variations (including Aitken’s one), 
a general mechanism that could be used for formalizing one logical 
theory in another is applied to formalizing a logical theory in itself. 
This can be very convenient for reasoning about reflection, but for 
our purposes it turns out to be extremely impractical. First, when 
formalizing a theory in itself using generic means, the identity 
between the theory being formalized and the one in which the 
formalization happens becomes very obfuscated, which makes it 
almost impossible to relate the reflected theory back to the original 
one. Second, when one has a theorem proving system that already 
implements the logical theory in question, creating a completely 
new implementation of this logical theory inside itself is a very 
tedious redundant effort. Another practical disadvantage of the 
G¨odel numbers approach is that it tends to blow up the size of 
the formulas; and iterated reflection would cause the blow-up to 
be iterated as well, making it exponential or worse.
# Para 239 14
A much more practical approach is being used in some pro-
gramming languages, such as Lisp and Scheme. There, the com-
mon solution is for the implementation to expose its internal syntax 
representation to user-level code by the quote constructor (where 
quote (t) prevents the evaluation of the expression t). The prob-
lems outlined above are solved instantly by this approach: there is 
no blow-up, there is no repetition of structure definitions, there is 
even no need for verifying that the reflected part is equivalent to the 
original implementation since they are identical. Most Scheme im-
plementations take this even further: the eval function is the inter-
nal function for evaluating a Scheme expression, which is exposed 
to the user-level; Smith [Smi84] showed how this approach can 
achieve an infinite tower of processors. A similar language with the 
quotation and antiquotation operators was introduced in [GMO03].
# Para 253 9
This approach, however, violates the congruence property with 
respect to computation: if two terms are computationally equal then 
one can be substituted for the other in any context. For instance, 
although 2 * 2 is equal to 4, the expressions “2*2” and “4” are 
syntactically different, thus we can not substitute 2*2 by 4 in 
the expression quote(2*2). The congruence property is essential 
in many logical reasoning systems, including the NuPRL system 
mentioned above and the MetaPRL system [HNC+03, HNK+, 
HAB+] that our group uses.
# Para 262 16
A possible way to expose the internal syntax without violat-
ing the congruence property is to use the so-called “quoted” or 
“shifted” operators [AA99, Bar01, Bar05] rather than quoting the 
whole expression at once. For any operator op in the original lan-
guage, we add the quoted operator (denoted as op) to represent a 
term built with the operator op. For example, if the original lan-
guage contains the constant “0” (which, presumably, represents the 
number 0), then in the reflected language, 0 would stand for the 
term that denotes the expression “0”. Generally, the quoted opera-
tor has the same arity as the original operator, but it is defined on 
syntactic terms rather than on semantic objects. For instance, while 
* is a binary operator on numbers, * is a binary operator on terms. 
Namely, if t1 and t2 are syntactic terms that stand for expressions 
e1 and e2 respectively, then t1 *t2 is a new syntactic term that stands 
for the expression e1 *e2. Thus, the quotation of the expression 1 *2 
would be 1 * 2.
# Para 278 2
In general, the well-formedness (typing) rule for a quoted oper-
ator is the following:
# Para 280 1
t1 E Term	...	tn E Term
# Para 281 1
op{t1; ... ; tn} E Term
# Para 282 1
where Term is a type of terms.
# Para 283 3
Note that quotations can be iterated arbitrarily many times, 
allowing us to quote quoted terms. For instance, 1 stands for the 
term that denotes the term that denotes the numeral 1.
# Para 286 7
Problems arise when quoting expressions that contain binding 
variables. For example, what is the quotation of Xx.x? There are 
several possible ways of answering this question. A commonly 
used approach [PE88, DH94, DFH95, ACM02, ACM03] in logical 
frameworks such as Elf [Pfe89], LF [HHP93], and Isabelle [PN90, 
Pau94] is to construct an object logic with a concrete X operator 
that has a type like
# Para 293 1
(Term -+ Term) -+ Term or (Var -+ Term) -+ Term.
# Para 294 4
In this approach, the quoted Xx.x might look like X(Xx.x) and the 
quoted Xx.1 might look like X(Xx.1). Note that in these examples 
the quoted terms have to make use of both the syntactic (i. e. quoted) 
operator X and the semantic operator X.
# Para 298 6
Exotic Terms. Naive implementations of the above approach 
suffer from the well-known problem of exotic terms [DH95, 
DFH95]. The issue is that in general we can not allow applying 
the X operator to an arbitrary function that maps terms to terms (or 
variables to terms) and expect the result of such an application to 
be a “proper” reflected term.
# Para 304 1
Consider for example the following term:
# Para 305 1
X(Xx. if x = 1 then 1 else 2)
# Para 306 4
It is relatively easy to see that it is not a real syntactic term and 
can not be obtained by quoting an actual term. (For comparison, 
consider X(Xx. if x = 1 then 1 else 2), which is a quotation of 
Xx. if x = 1 then 1 else 2).
# Para 310 8
How can one ensure that Xe denotes a “real” term and not an 
“exotic” one? That is, is it equal to a result of quoting an actual 
term of the object language? One possibility is to require e to be 
a substitution function; in other words it has to be equal to an 
expression of the form Xx.t[x] where t is composed entirely of term 
constructors (i.e. quoted operators) and x, while using destructors 
(such as case analysis, the if operator used in the example above, 
etc) is prohibited.
# Para 318 11
There are a number of approaches to enforcing the above restric-
tion. One of them is the usage of logical frameworks with restricted 
function spaces [PE88, HHP93], where X-terms may only con-
tain constructors. Another is to first formalize the larger type that 
does include exotic terms and then to define recursively a predicate 
describing the “validity” or “well-formedness” of a term [DH94, 
DFH95] thus removing the exotic terms from consideration. Yet 
another approach is to create a specialized type theory that com-
bines the idea of restricted function spaces with a modal type oper-
ator [DPS97, DL99, DL01]. There the case analysis is disallowed 
on objects of “pure” type T, but is allowed on objects of a special
# Para 329 1
type ❑T. This allows expressing both the restricted function space
# Para 330 2
“T1 -+ T2” and the unrestricted one “(�T1) -+ T2” within a single 
type theory.
# Para 332 7
Another way of regarding the problem of exotic terms is that it 
is caused by the attempt to give a semantic definition to a primarily 
syntactic property. A more syntax-oriented approach was used by 
Barzilay et al. [BA02, BAC03, Bar05]. In Barzilay’s approach, the 
quoted version of an operator that introduces a binding has the 
same shape (i.e. the number of subterms and the binding structure) 
as the original one and the variables (both the binding and the
# Para 339 1
(1)
# Para 340 1
4
# Para 341 2
bound occurrences) are unaffected by the quotation. For instance, 
the quotation of Xx.x is just Xx.x.
# Para 343 1
The advantages of this approach include:
# Para 344 1
•	This approach is simple and clear.
# Para 345 2
•	Quoted terms have the same structure as original ones, inherit-
ing a lot of properties of the object syntax.
# Para 347 3
•	In all the above approaches, the a-equivalence relation for 
quoted terms is inherited “for free”. For example, Xx.x and 
Xy.y are automatically considered to be the same term.
# Para 350 4
•	Substitution is also easy: we do not need to re-implement the 
substitution that renames binding variables to avoid the capture 
of free variables; we can use the substitution of the original 
language instead.
# Para 354 5
To prune exotic terms, Barzilay says that Xx.t[x] is a valid term 
when Xx.t[x] is a substitution function. He demonstrates that it is 
possible to formalize this notion in a purely syntactical fashion. In 
this setting, the general well-formedness rule for quoted terms with 
bindings is the following:
# Para 359 1
is substk {x1, · · · , xk.t[&quot;x]}	· · ·	is substl {z 1, · · · , zl.s[&quot;z]}
# Para 360 1
op{x1, · · · , xk.t[&quot;x]; · · · ; z1, · · · , zl.s[&quot;z]} E Term
# Para 361 5
(2) 
where is substn {x1 , · · · , xn.t[&quot;x]} is the proposition that t is a sub-
stitution function over variables x1 , · · · , xn (in other words, it is a 
syntactic version of the Valid predicate of [DH94, DFH95]). This 
proposition is defined syntactically by the following two rules:
# Para 366 1
is substn {x1, · · · , xn . xi}
# Para 367 1
and
# Para 368 2
is substn+k{x1, · · · , xn,y1, · · · , yk.t[&quot;x;&quot;y]}
...
# Para 370 1
is substn+l {x1, · · · , xn, z1, ··· , zl.s[&quot;x; &quot;z]}}
# Para 371 1
is substn {x1 · · ·xn.op{y1 · · ·yk.t[&quot;x; &quot;y]; · · · ; z1 · · ·zl.s[&quot;x; &quot;z]}}
# Para 372 4
In this approach the is substn {} and X operators are essentially 
untyped (in NuPRL type theory, the computational properties of 
untyped terms are at the core of the semantics; types are added on 
top of the untyped computational system).
# Para 376 14
Recursive Definition and Structural Induction Principle. A 
difficulty shared by both the straightforward implementations of 
the (Term -+ Term) -+ Term approach and by the Barzilay’s one 
is the problem of recursively defining the Term type. We want to 
define the Term type as the smallest set satisfying rules (1) and (2). 
Note, however, that unlike rule (1), rule (2) is not monotonic in the 
sense that is substk {x1, · · · , xk.t[&quot;x]} depends non-monotonically 
on the Term type. For example, to say whether Xx.t[x] is a term, we 
should check whether t is a substitution function over x. It means at 
least thatfor every x in Term, t[x] should be in Term as well. Thus 
we need to define the whole type Term before using (2), which 
produces a logical circle. Moreover, since X has type (Term -+ 
Term) -+ Term, it is hard to formulate the structural induction 
principle for terms built with the X term constructor.
# Para 390 6
Variable-Length Lists of Binders. In Barzilay’s approach, for 
each number n, is substn {} is considered to be a separate operator 
— there is no way to quantify over n, and there is no way to 
express variable-length lists of binders. This issue of expressing the 
unbounded-length lists of binders is common to some of the other 
approaches as well.
# Para 396 4
Meta-Reasoning. Another difficulty that is especially apparent 
in Barzilay’s approach is that it only allows reasoning about con-
crete operators in concrete languages. This approach does not pro-
vide the ability to reason about operators abstractly; in particular, 
# Para 400 2
there is no way to state and prove meta-theorems that quantify over 
operators or languages, much less classes of languages.
# Para 402 2
3. Higher-Order Abstract Syntax 
with Inductive Definitions
# Para 404 8
Although it is possible to solve the problems outlined in the previ-
ous Section (and we will return to the discussion of some of those 
solutions in Section 6), our desire is to avoid these difficulties from 
the start. We propose a natural model of reflection that manages to 
work around those difficulties. We will show how to give a sim-
ple recursive definition of terms with binding variables, which does 
not allow the construction of exotic terms and does allow structural 
induction on terms.
# Para 412 2
In this Section we provide a conceptual overview of our ap-
proach; details are given in Section 4.
# Para 414 1
3.1 Bound Terms
# Para 415 11
One of the key ideas of our approach is how we deal with terms 
containing free variables. We extend to free variables the principle 
that variable names do not really matter. In fact, we model free 
variables as bindings that can be arbitrarily a-renamed. Namely, 
we will write bterm{x1, · · · , xn.t[&quot;x]} for a term t over variables 
x1, · · ·, xn. For example, instead of term x*y we will use the 
term bterm{x, y.x*y} when it is considered over variables x and 
y and bterm{x, y, z.x*y} when it is considered over variables x, 
y and z. Free occurrences of xi in t[&quot;x] are considered bound 
in bterm{x1, · · · , xn.t[&quot;x]} and two a-equal bterm{} expressions 
(“bterms”) are considered to be identical.
# Para 426 3
Not every bterm is necessarily well-formed. We will define the 
type of terms in such a way as to eliminate exotic terms. Consider 
for example a definition of lambda-terms.
# Para 429 2
EXAMPLE 1. We can define a set of reflected lambda-terms as the 
smallest set such that
# Para 431 2
•	bterm{x1, · · · , xn.xi}, where 1 &lt; i &lt; n, is a lambda-term (a 
variable);
# Para 433 1
•	ifbterm{x1, · · · , xn, xn+1.t[&quot;x] ) is a lambda-term, then
# Para 434 1
bterm{x1 , · · · , xn .Xxn+1 .t[&quot;x])
# Para 435 1
is also a lambda-term (an abstraction);
# Para 436 2
•	if bterm{x1, · · · , xn.t1 [&quot;x]} and bterm{x1, · · · , xn.t2[&quot;x]} are 
lambda-terms, then
# Para 438 1
bterm{x1; · · · ; xn.apply{t1 [&quot;x]; t2[&quot;x]}}
# Para 439 1
is also a lambda-term (an application).
# Para 440 4
In a way, bterms could be understood as an explicit coding for 
Barzilay’s substitution functions. And indeed, some of the basic 
definitions are quite similar. The notion of bterms is also very 
similar to that of local variable contexts [FPT99].
# Para 444 1
3.2 Terminology
# Para 445 1
Before we proceed further, we need to define some terminology.
# Para 446 4
DEFINITION 1. We change the notion of subterm so that the sub- 
terms of a bterm are also bterms. For example, the immediate sub- 
terms of bterm{x, y.x*y} are bterm{x, y.x} and bterm{x, y.y}; the 
immediate subterm ofbterm{x.Xy.x} is bterm{x, y.x}.
# Para 450 3
DEFINITION 2. We call the number of outer binders in a bterm 
expression its binding depth. Namely, the binding depth of the 
bterm bterm{x1, · · · , xn.t[&quot;x]} is n.
# Para 453 3
DEFINITION 3. Throughout the rest of the paper we use the notion 
of operator shape. The shape ofan operator is a list ofnatural num-
bers each stating how many new binders the operator introduces on
# Para 456 1
5
# Para 457 3
the corresponding subterm. The length of the shape list is therefore 
the arity of the operator. For example, the shape of the + operator 
is [0; 0] and the shape of the X operator is [1].
# Para 460 2
The mapping from operators to shapes is also sometimes called 
a binding signature of a language [FPT99, Plo90].
# Para 462 3
DEFINITION 4. Let op be an operator with shape [d1; · · · ; dN], 
and let btl be a list of bterms [b1; · · · ; bM]. We say that btl is 
compatible with op at depth n when,
# Para 465 1
1. N=M;
# Para 466 1
2. the binding depth of bterm bj is n + dj for each 1 &lt; j &lt; N.
# Para 467 1
3.3 Abstract Operators
# Para 468 8
Expressions of the form bterm{&quot;x.op{· · · }} can only be used to ex-
press syntax with concrete operators. In other words, each expres-
sion of this form contains a specific constant operator op. However, 
we would like to reason about operators abstractly; in particular, 
we want to make it possible to have variables of the type “Op” that 
can be quantified over and used in the same manner as operator 
constants. In order to address this we use explicit term constructors 
in addition to bterm{&quot;x.op{· · · }} constants.
# Para 476 1
The expression mk bterm{n; “op”; btl}, where “op” is some en-
# Para 477 1
coding of the quoted operator op, stands for a bterm with binding
# Para 478 1
depth n, operator op and subterms btl. Namely,
# Para 479 1
mk bterm{n; op; bterm{x1 , · · · , xn, &quot;y1 .t1 [&quot;x; &quot;y1]} :: · · · ::
# Para 480 1
bterm{x1, · · · ,xn,&quot;yk.tk[&quot;x; &quot;yk]} :: nil}
# Para 481 4
is bterm{x1, · · · , xn.op {&quot;y1 .t1 [&quot;x; &quot;y1]; · · · ; &quot;yk.tk[&quot;x; &quot;yk]}}. Here, 
nil is the empty list and :: is the list cons operator and there-
fore the expression b1 :: · · · :: bn :: nil represents the concrete list 
[b1; ··· ; bn].
# Para 485 7
Note that if we know the shape of the operator op and we know 
that the mk bterm expression is well-formed (or, more specifically, 
if we know that btl is compatible with op at depth n), then it 
would normally be possible to deduce the value of n (since n is 
the difference between the binding depth of any element of the list 
btl and the corresponding element of the shape(op) list). There are 
two reasons, however, for supplying n explicitly:
# Para 492 4
•	When btl is empty (in other words, when the arity of op is 0), 
the value of n can not be deduced this way and still needs to be 
supplied somehow. One could consider 0-arity operators to be a 
special case, but this results in a significant loss of uniformity.
# Para 496 5
•	When we do not know whether an mk bterm expression is 
necessarily well-formed (and as we will see it is often useful 
to allow this to happen), then a lot of definitions and proofs 
are greatly simplified when the binding depth of mk bterm 
expressions is explicitly specified.
# Para 501 10
Using the mk bterm constructor and a few other similar con-
structors that will be introduced later, it becomes easy to reason ab-
stractly about operators. Indeed, the second argument to mk bterm 
can now be an arbitrary expression, not just a constant. This has a 
cost of making certain definitions slightly more complicated. For 
example, the notion of “compatible with op at depth n” now be-
comes an important part of the theory and will need to be explicitly 
formalized. However, this is a small price to pay for the ability to 
reason abstractly about operators, which easily extends to reason-
ing abstractly about languages, classes of languages and so forth.
# Para 511 1
3.4 Inductively Defining the Type of Well-Formed Bterms
# Para 512 3
There are two equivalent approaches to inductively defining the 
general type (set) of all well-formed bterms. The first one follows 
the same idea as in Example 1:
# Para 515 1
•	bterm{x1 , · · · , xn.xi } is a well-formed bterm for 1 &lt; i &lt; n;
# Para 516 3
•	mk bterm{n; op; btl} is a well-formed bterm when op is a well- 
formed quoted operator and btl is a list of well-formed bterms 
that is compatible with op at some depth n.
# Para 519 7
If we denote bterm{x1, · · · , xl, y, z1, · · · , zr.y} as var{l; r}, 
we can restate the base case of the above definition as “var{l; r}, 
where l and r are arbitrary natural numbers, is a well-formed 
bterm”. Once we do this it becomes apparent that the above def-
inition has a lot of similarities with de Bruijn-style indexing of 
variables [dB72]. Indeed, one might call the numbers l and r the 
left and right indices of the variable var{l; r}.
# Para 526 2
It is possible to provide an alternate definition that is closer to 
pure HOAS:
# Para 528 4
•	bnd{x.t[x]}, where t is a well-formed substitution function, is 
a well-formed bterm (the bnd operation increases the binding 
depth of t by one by adding x to the beginning of the list of t’s 
outer binders).
# Para 532 3
•	mk term{op; btl}, where op is a well-formed quoted operator, 
and btl is a list of well-formed bterms that is compatible with 
op at depth 0, is a well-formed bterm (of binding depth 0).
# Para 535 10
Other than better capturing the idea of HOAS, the latter defini-
tion also makes it easier to express the reflective correspondence 
between the meta-syntax (the syntax used to express the theory of 
syntax, namely the one that includes the operators mk bterm, bnd, 
etc.) and the meta-meta-syntax (the syntax that is used to express 
the theory of syntax and the underlying theory, in other words, the 
syntax that includes the second-order notations.) Namely, provided 
that we define the subst{bt; t} operation to compute the result of 
substituting a closed term t for the first outer binder of the bterm 
bt, we can state that
# Para 545 1
subst{bnd{x.t1 [x]} ; t2} ≡ t1 [t2] (3)
# Para 546 4
(where t1 and t2 are literal second-order variables). In other words, 
we can state that the substitution operator subst and the implicit 
second-order substitution in the “meta-meta-” language are equiv-
alent.
# Para 550 2
The downside of the alternate definition is that it requires defin-
ing the notion of “being a substitution function”.
# Para 552 1
3.5 Our Approach
# Para 553 9
In our work we try to combine the advantages of both approaches 
outlined above. In the next Section we present a theory that includes 
both the HOAS-style operations (bnd, mk term) and the de Bruijn-
style ones (var, mk bterm). Our theory also allows deriving the 
equivalence (3). In our theory the definition of the basic syntactic 
operations is based on the HOAS-style operators; however, the 
recursive definition of the type of well-formed syntax is based on 
the de Bruijn-style operations. Our theory includes also support for 
variable-length lists of binders.
# Para 562 1
4. Formal Implementation in a Theorem Prover
# Para 563 6
In this Section we describe how the foundations of our theory are 
formally defined and derived in the NuPRL-style Computational 
Type Theory in the MetaPRL Theorem Prover. For brevity, we 
will present a slightly simplified version of our implementation; 
full details are available in the extended version of this paper 
[NKYH05, Appendix].
# Para 569 1
4.1 Computations and Types
# Para 570 3
In our work we make heavy usage of the fact that our type theory 
allows us to define computations without stating upfront (or even 
knowing) what the relevant types are. In NuPRL-style type theo-
# Para 573 1
6
# Para 574 5
ries (which some even dubbed “untyped type theory”), one may de-
fine arbitrary recursive functions (even potentially nonterminating 
ones). Only when proving that such function belongs to a particular 
type, one may have to prove termination. See [All87a, All87b] for 
a semantics that justifies this approach.
# Para 579 2
The formal definition of the syntax of terms consists of two 
parts:
# Para 581 5
•	The definition of untyped term constructors and term oper-
ations, which includes both HOAS-style operations and de 
Bruijn-style operations. As it turns out, we can establish most 
of the reduction properties without explicitly giving types to all 
the operations.
# Para 586 3
•	The definition of the type of terms. We will define the type of 
terms as the type that contains all terms that can be legitimately 
constructed by the term constructors.
# Para 589 1
4.2 HOAS Constructors
# Para 590 2
At the core of our term syntax definition are two basic HOAS-style 
constructors:
# Para 592 4
•	bnd{x.t[x]} is meant to represent a term with a free variable x. 
The intended semantics (which will not become explicit until 
later) is that bnd{x.t[x]} will only be considered well-formed 
when t is a substitution function.
# Para 596 4
Internally, bnd{x.t[x]} is implemented simply as the pair 
(0, Xx.t[x]). This definition is truly internal and is used only 
to prove the properties of the two destructors presented below; 
it is never used outside of this Section (Section 4.2).
# Para 600 5
•	mk term{op; ts} pairs op with ts. The intended usage of this 
operation (which, again, will only become explicit later) is that 
it represents a closed term (i.e. a bterm of binding depth 0) with 
operator op and subterms ts. It will be considered well-formed 
when op is an operator and ts is a list of terms that is compatible
# Para 605 1
with op at depth 0. For example, mk term{X; bnd{x.x}} is Xx.x.
# Para 606 3
Internally, mk term{op; ts} is implemented as the nested pair 
(1, (op, ts)). Again, this definition is never used outside of this 
Section.
# Para 609 1
We also implement two destructors:
# Para 610 4
•	subst{bt; t} is meant to represent the result of substituting term 
t for the first variable of the bterm bt. Internally, subst{bt; t} 
is defined simply as an application (bt.2) t (where bt.2 is the 
second element of the pair bt).
# Para 614 2
We derive the following property of this substitution operation:
subst{bnd{x.t1 [x]} ; t2} ≡ t1 [t2]
# Para 616 4
where “≡” is the computational equality relation1 and t1 and 
t2 may be absolutely arbitrary, even ill-typed. This derivation 
is the only place where the internal definition of subst{bt; t} is 
used.
# Para 620 3
Note that the above equality is exactly the “reflective property 
of substitution” (3) that was one of the design goals for our 
theory.
# Para 623 2
•	weak dest {bt; bcase; op, ts.mkt case[op; ts]} is designed to 
provide a way to find out whether bt is a bnd{} or a mk term{op; ts}
# Para 625 2
1 In NuPRL-style type theories the computational equality relation (which 
is also sometimes called “squiggle equality” and is sometimes denoted
# Para 627 1
as“∼” or “←-+”) is the finest-grained equality relation in the theory.
# Para 628 4
When a ≡ b is true, a may be replaced with b in an arbitrary context. 
Examples of computational equality include beta-reduction Xx.a[x]b ≡ 
a[b], arithmetical equalities (1 + 2 ≡ 3), and definitional equality (an 
abstraction is considered to be computationally equal to its definition).
# Para 632 4
and to “extract” the op and ts in the latter case. In the rest of 
this paper we will use the “pretty-printed” form for weak dest 
— “match bt with bnd{ } -+ bcase I mk term{op; ts} -+ 
mkt case[op; ts]”. Internally, it is defined as
# Para 636 1
if bt.1 = 0 then bcase else mkt case[bt.2.1; bt.2.2].
# Para 637 2
From this internal definition we derive the following properties 
of weak dest:
# Para 639 1
⎛	⎞
# Para 640 1
matchbnd{x.t[x]} with
# Para 641 1
⎝bnd{ } -+ bcase	⎠
# Para 642 1
bcase
# Para 643 1
mk term{op; ts} -+ mkt case[op; ts]≡
# Para 644 1
⎛
# Para 645 1
matchmk term{op; ts} with
# Para 646 3
⎝bnd{ } -+ bcase 
Imk term{o; t} -+ mkt case[o; t] 
4.3 Vector HOAS Operations
# Para 649 7
As we have mentioned at the end of Section 2, some approaches to 
reasoning about syntax make it hard or even impossible to express 
arbitrary-length lists of binders. In our approach, we address this 
challenge by allowing operators where a single binding in the meta-
language stands for a list of object-level bindings. In particular, we 
allow representing bnd{x1.bnd{x2. · · · bnd{xn.t[x1; ... ; xn]} · · ·}} 
as
# Para 656 2
vbnd{n; x.t[nth{1; x}; . . . ; nth{n; x}]}, where “nth{i; l}” is the “i-
th element of the list l” function.
# Para 658 1
We define the following vector-style operations:
# Para 659 3
•	vbnd{n; x.t[x]} represents a “telescope” of nested bnd opera-
tions. It is defined by induction2 on the natural number n as 
follows:
# Para 662 1
vbnd{0; x.t[x]}:= t[nil]
# Para 663 1
vbnd{n + 1; x.t[x]}:= bnd{v.vbnd{n; x.t[v :: x]}}
# Para 664 2
We also introduce vbnd{n; t} as a simplified notation for 
vbnd{n; x.t} when t does not have free occurrences of x.
# Para 666 5
•	vsubst{bt; ts} is a “vector” substitution operation that is meant 
to represent the result of simultaneous substitution of the terms 
in the ts list for the first ItsI variables of the bterm bt (here IlI is 
the length of the list l). vsubst{bt; ts} is defined by induction on 
the list ts as follows:
# Para 671 1
vsubst{bt; nil}:= bt
# Para 672 1
vsubst{bt; t :: ts}:= vsubst{subst{bt; t} ; ts}
# Para 673 1
Below are some of the derived properties of these operations:
# Para 674 1
	bnd{v.t[v]} ≡ vbnd{1; hd(v)}	(4)
# Para 675 1
Vm , n E N.
# Para 676 1
�vbnd{m +n; x.t[x]} ≡ vbnd{m; y.vbnd{n; z.t[y@z]}}) (5)
# Para 677 1
	Vl E List. (vsubst{vbnd{Il I; v.t[v]} ;l} ≡ t[l])	(6)
# Para 678 1
Vl E List.Vn E N. �(n ≥ IlI) ⇒	(7)
# Para 679 1
(vsubst{vbnd{n; v.t[v]} ;l} ≡ vbnd{n − IlI; v.bt[l@v]}))
# Para 680 1
Vn E N.	(8)
# Para 681 1
vbnd{n; l.vsubst{vbnd{n; v.t[v]} ;l}} ≡ vbnd{n; l.t[l]})
# Para 682 5
where “hd” is the list “head” operation, “@” is the list append 
operation, “List” is the type of arbitrary lists (the elements of a list 
do not have to belong to any particular type), N is the type of natural 
numbers, and all the variables that are not explicitly constrained to 
a specific type stand for arbitrary expressions.
# Para 687 3
2 Our presentation of the inductive definitions is slightly simplified by 
omitting some minor technical details. See [NKYH05, Appendix] for 
complete details.
# Para 690 1
⎞⎠ ≡mkt case[op; ts]
# Para 691 1
7
# Para 692 5
Equivalence (5) allows the merging and splitting of vector bnd 
operations. Equivalence (6) is a vector variant of equivalence (3). 
Equivalence (8) is very similar to equivalence (6) applied in the 
vbnd{n; l. · · ·} context, except that (8) does not require l to be a 
member of any special type.
# Para 697 1
4.4 De Bruijn-style Operations
# Para 698 2
Based on the HOAS constructors defined in the previous two sec-
tions, we define two de Bruijn-style constructors.
# Para 700 2
•	var{i; j} is defined as vbnd{i; bnd{v.vbnd{j; v}}}. It is easy to 
see that this definition indeed corresponds to the informal
# Para 702 2
bterm{x1,··· ,xl, y, z1,··· , zr .y} 
definition given in Section 3.4.
# Para 704 3
•	mk bterm{n; op; ts} is meant to compute a bterm of binding 
depth n, with operator op, and with ts as its subterms. This op-
eration is defined by induction on natural number n as follows:
# Para 707 2
mk bterm{0; op; ts}:= mk term{op; ts} 
mk bterm{n + 1; op; ts}:=
# Para 709 1
bnd{v.mk bterm{n; op; map Xt.subst{t; v} ts}}
# Para 710 2
Note that, if ts is a list of bnd expressions (which is the intended 
usage of the mk bterm operation), then the
# Para 712 1
bnd{v. · · · map Xt.subst{t; v} ts · · ·}
# Para 713 3
has the effect of stripping the outer bnd from each of the mem-
bers of the ts list and “moving” them into a single “merged” bnd 
on the outside.
# Para 716 6
We also define a number of de Bruijn-style destructors, i.e., op-
erations that compute various de Bruijn-style characteristics of a 
bterm. Since the var and mk bterm constructors are defined in terms 
of the HOAS constructors, the destructors have to be defined in 
terms of HOAS operations as well. Because of this, these defini-
tions are often far from straightforward.
# Para 722 6
It is important to emphasize that the tricky definitions that we 
use here are only needed to establish the basic properties of the 
operations we defined. Once the basic theory is complete, we can 
raise the level of abstraction and no usage of this theory will 
ever require using any of these definitions, being aware of these 
definitions, or performing similar tricks again.
# Para 728 2
•	bdepth{t} computes the binding depth of term t. It is defined 
recursively using the Y combinator as
# Para 730 1
rXb.matchb with
# Para 731 1
Y	bnd{ } -+ 1 + f (subst{b; mk term{0; 0}})
# Para 732 1
|mkterm{ ; }-+0
# Para 733 6
In effect, this recursive function strips the outer binders from a 
bterm one by one using substitution (note that here we can use 
an arbitrary mk bterm expression as a second argument for the 
substitution function; the arguments to mk bterm do not have 
to have the “correct” type) and counts the number of times it 
needs to do this before the outermost mk bterm is exposed.
# Para 739 1
We derive the following properties of bdepth:
# Para 740 2
Vl, r E ICY. (bdepth {var{l; r}} ≡ (l +r + 1)); 
Vn E ICY.(bdepth{mk bterm{n; op; ts}} ≡ n).
# Para 742 5
Note that the latter equivalence only requires n to have the 
“correct” type, while op and ts may be arbitrary. Since the 
bdepth operator is needed for defining the type of Term of well- 
formed bterms, at this point we would not have been able to 
express what the “correct” type for ts would be.
# Para 747 2
•	left{t} is designed to compute the “left index” of a var expres-
sion. It is defined as
# Para 749 1
	�	�
# Para 750 1
Xf.Xb.Xl.
# Para 751 1
match b with	�
# Para 752 1
	Y	bnd{ } -+
# Para 753 2
�1 + f (subst{b; mk term {l; 0}})(l + 1) � � 
|mk term{lf; ) -+ lf
# Para 755 8
In effect, this recursive function substitutes mk term{0; 0} 
for the first binding of t, mk term{1; 0} for the second one, 
mk term{2; 0} for the next one and so forth. Once all the binders 
are stripped and a mk term{l; 0} is exposed, l is the index 
we were looking for. Note that here we intentionally supply 
mk term with an argument of a “wrong” type (ICY instead of 
Op); we could have avoided this, but then the definition would 
have been significantly more complicated.
# Para 763 1
As expected, we derive that
# Para 764 1
Vl, r E ICY.(left{var{l; r}} ≡ l).
# Para 765 3
•	right{t} computes the “right index” of a var expression. It 
is trivial to define in terms of the previous two operators: 
right{t}:= bdepth{t} − left{t} − 1.
# Para 768 1
•	get op{t; op} is an operation such that
# Para 769 1
Vn E ICY.(get op{mk bterm{n; op; ts} ; opf) ≡ op),
# Para 770 1
Vl, r E ICY. ((get op{var{i; j} ; op} ≡ op).
# Para 771 1
Its definition is similar to that of left{}.
# Para 772 5
•	subterms{t} is designed to recover the last argument of a 
mk bterm expression. The definition is rather technical and 
complicated, so we omit it; see [NKYH05, Appendix C] for 
details. The main property of the subterms operation that we 
derive is
# Para 777 2
Vn E ICY.Vbtl E List.(subterms{mk bterm{n; op; btl}} ≡ 
map Xb.vbnd{n; v.vsubst{b; v}} btl)
# Para 779 6
The right-hand side of this equivalence is not quite the plain 
“btl” that one might have hoped to see here. However, when 
btl is a list of bterms with binding depths at least n, which is 
necessarily the case for any well-formed mk bterm{n; op; btl}, 
equivalence (8) would allow simplifying this right-hand side to 
the desired btl.
# Para 785 1
4.5 Operators
# Para 786 5
For this basic theory the exact representation details for operators 
are not essential and we define the type of operators Op abstractly. 
We only require that operators have decidable equality and that 
there exist a function of the type Op -+ ICY List that computes 
operators’ shapes.
# Para 791 4
Using this shape function and the bdepth function from Sec-
tion 4.4, it is trivial to formalize the “ts is compatible with op at 
depth n” predicate of Definition 4. We denote this predicate as 
shape compat{n; op; ts} and define it as
# Para 795 1
|shape{op}| = |btl|A
# Para 796 1
Vi E 1..|btl|.bdepth{nth{btl; i}} = n +nth{shape{op}; i}
# Para 797 1
4.6 The Type of Terms
# Para 798 4
In this section we will define the type of terms (i.e. well-formed 
bterms), Term, as the type of all terms that can be constructed by 
the de Bruijn constructors from Section 4.4. That is, the Term type 
contains all expressions of the forms:
# Para 802 1
•	var{i; j} for all natural numbers i, j; or
# Para 803 1
)t
# Para 804 1
t0
# Para 805 1
8
# Para 806 2
• mk bterm{n; op; ts} for any natural number n, operator op, and 
list of terms ts that is compatible with op at depth n.
# Para 808 2
The Term type is defined as a fixpoint of the following function 
from types to types:
# Para 810 1
Iter(X) := Image(dom(X); x.mk(x)),
# Para 811 1
where
# Para 812 4
•	Image is a type constructor such that Image(T; x. f [xl) is the 
type of all the f [tl for t e T (for it to be well-formed, T must 
be a well-formed type and f must not have any free variables 
except for x);
# Para 816 1
•	dom(X) is a type defined as
# Para 817 1
(N×N)+(n:N× op:Op× {ts:X List I shape compat{n; op; ts}});
# Para 818 2
•	and mk(x) (where x is presumably a member of the type 
dom(X)) is defined as
# Para 820 1
matchx with
# Para 821 1
inl (i, j) -+ var{i ; j}
# Para 822 1
Iinr (n, op, ts) -+ mk bterm{n; op; ts} .
# Para 823 1
The fixpoint of Iter is reached by defining
# Para 824 1
•	Term0 := Void (an empty type)
# Para 825 1
•	Termn+1 := Iter(Termn)
# Para 826 1
•	Term := U Termn
# Para 827 1
neN
# Para 828 2
We derive the intended introduction rules for the Term type:
i eN	j eN
# Para 830 1
var{i ; j} e Term
# Para 831 1
and
# Para 832 1
n e N op e Op ts e TermList shape compat{n; op; ts}
# Para 833 1
.
# Para 834 1
mk bterm{n; op; ts} e Term
# Para 835 3
Also, the structural induction principle is derived for the Term 
type. Namely, we show that to prove that some property P[tl holds 
for any term t, it is sufficient to prove
# Para 838 2
•	(Base case) P holds for all variables, that is, P[var{i ; j}l holds 
for all natural numbers i and j;
# Para 840 4
•	(Induction step) P[mk bterm{n; op; ts}l is true for any natural 
number n, any operator op, and any list of terms ts that is 
compatible with op at depth n, provided P[tl is true for any 
element t of the list ts.
# Para 844 4
Note that the type of “terms over n variables” (where n = 0 cor-
responds to closed terms) may be trivially defined using the Term 
type and the “subset” type constructor — {t : Term II bdepth{t} = 
n}.
# Para 848 1
5. Conclusions and Future Work
# Para 849 12
In Sections 3 and 4 we have presented a basic theory of syntax 
that is fully implemented in a theorem prover. As we mentioned in 
the introduction, the approach is both natural and expressive, and 
provides a foundation for reflective reasoning about classes of lan-
guages and logics. However, we consider this theory to be only 
the first step towards building a user-accessible uniform reflection 
framework and a user-accessible uniform framework for program-
ming language reasoning and experimentation, where tasks similar 
to the ones presented in the POPLMARK challenge [ABF+05] can 
be performed easily and naturally. In this section we provide an out-
line of our plans for building such frameworks on top of the basic 
syntactic theory.
# Para 861 1
5.1 Higher-Level User Interface
# Para 862 5
One obvious shortcoming of the theory presented in Sections 3 
and 4 is that it provides only the basic low-level operations such 
as bnd, var, subterms, etc. It presents a very low-level account of 
syntax in a way that would often fail to abstract away the details 
irrelevant to the user.
# Para 867 8
To address this problem we are planning to provide user in-
terface functionality capable of mapping the high-level concepts 
to the low-level ones. In particular, we are going to provide an 
interface that would allow instantiating general theorems to spe-
cific collections of operators and specific languages. Thus, the user 
will be able to write something like “reflect language [Xx..; 
apply{.; .}] ” and the system will create all the components outlined 
in Example 1:
# Para 875 1
•	It will create a definition for the type
# Para 876 1
Language[Xx..; apply{.; .}l
# Para 877 2
of reflected lambda-terms (where Language[ll is a general def-
inition of a language over a list of operators l);
# Para 879 1
•	It will state and derive the introduction rules for this type;
# Para 880 2
•	It will state and derive the elimination rule for this type (the 
induction principle).
# Para 882 2
Moreover, we are planning to support even more complicated lan-
guage declarations, such as
# Para 884 1
t := int I t -+ t; e := v I Xx : t.e[xl I apply{e; e}
# Para 885 2
that would cause the system to create mutually recursive type 
definitions and appropriate rules.
# Para 887 6
Finally, we are also planning to support “pattern bindings” that 
are needed for a natural encoding of ML-like pattern matching 
(such as the one sketched in the POPLMARK challenge [ABF+05]). 
As far as the underlying theory goes, we believe that the mecha-
nisms very similar to the “vector bindings” presented in Section 4.3 
will be sufficient here.
# Para 893 1
5.2 “Dereferencing” Quoted Terms
# Para 894 4
As in Barzilay’s work, the quoted operator approach makes it easy 
to define the “unquoting” (or “dereferencing”) operator [lunq. If t 
is a syntactic term, then [tllunq is the value represented by t. By 
definition,
# Para 898 1
[op{t1; ... ; tn}lunq = op{[t1lunq; ... ; [tnllunq}.
# Para 899 1
For instance, [2 * 3lunq is 2 * 3 (i.e. 6).
# Para 900 3
In order to define unquoting on terms with bindings, we need to 
introduce the “guard” operation hp pi such that [bt)llunq is t for an 
arbitrary expression t. Then [lunq can be defined as follows:
# Para 903 2
[op{x1, ..., xk.t[x1; ... ; xkl; ... ;z1, ..., zl.s[z1; ... ; zll}lunq = 
op{x1, . . . ,xk.[[t[(ix1 ; ... ; Ixk�llunq;
# Para 905 1
. . .	;
# Para 906 1
z1, . . . , zl.[s[(z1�� ; ... ; (1zl�llunq}.
# Para 907 2
For example, [[Xx.2*xlunq = Xx.[2*��x�llunq = Xx.[2lunq * 
[bx)lunq =Xx.2 * x.
# Para 909 2
The unquote operation establishes the identity between the orig-
inal syntax and the reflected syntax, making it a “true” reflection.
# Para 911 4
Note that the type theory (which ensures, in particular, that 
only terminating functions may be shown to belong to a function 
type) would keep the [ llunq operation from introducing logical 
paradoxes.3
# Para 915 2
3 This is, obviously, not a proper argument. While a proper argument can be 
made here, it is outside of the scope of this particular paper.
# Para 917 1
9
# Para 918 4
Also, since the notion of the quoted operators is fully open- 
ended, each new language added to the system will automatically 
get to use the Q lunq operation for all its newly introduced opera-
tors.
# Para 922 1
5.3 Logical Reflection
# Para 923 6
After defining syntactic reflection, it is easy to define logical reflec-
tion. If we consider the proof system open-ended, then the logical 
reflection is trivial — when P is a quotation of a proposition, we 
can regard “QPlunq” as meaning “P is true”. The normal modal 
rules for the Qlunq modality are trivially derivable. For example 
modus ponens
# Para 929 1
QP  =:�  Qlunq =:� QPlunq =:� QQQlunq
# Para 930 1
is trivially true because if we evaluate the first Qllunq (remember,
# Para 931 1
QP =:� Qlunq = (QPlunq =:� QQlunq)
# Para 932 2
by definition of Qlunq), we get an obvious tautology 
(QPlunq =:� QQQlunq) =:� QPlunq =:� QQlunq.
# Para 934 8
In order to consider a closed proof system (in other words, if 
we want to be able to do induction over derivations), we would 
need to define a provability predicate for that system. We are 
planning to provide user interface functionality that would allow 
users to describe a set of proof rules and the system would generate 
appropriate proof predicate definitions and derive appropriate rules 
(in a style similar to the one outlined in Section 5.1 for the case of 
language descriptions).
# Para 942 1
6. Related Work
# Para 943 3
In Section 2 we have already discussed a number of approaches 
that we consider ourselves inheriting from. Here we would like to 
revisit some of them and mention a few other related efforts.
# Para 946 8
Our work has a lot in common with the HOAS implemented in 
Coq by Despeyroux and Hirschowitz [DH94]. In both cases, the 
more general space of terms (that include the exotic ones) is later 
restricted in a recursive manner. In both cases, the higher-order 
analogs of first-order de Bruijn operators are defined and used as a 
part of the “well-formedness” specification for the terms. Despey-
roux and Hirschowitz use functions over infinite lists of variables 
to define open terms, which is similar to our vector bindings.
# Para 954 15
There are a number of significant differences as well. Our ap-
proach is sufficiently syntactical, which allows eliminating all ex-
otic terms, even those that are extensionally equal to the well- 
formed ones, while the more semantic approach of [DH94, 
DFH95] has to accept such exotic terms (their solution to this prob-
lem is to consider an object term to be represented by the whole 
equivalence class of extensionally equal terms); more generally 
while [DH94] states that “this problem of extensionality is recur-
rent all over our work”, most of our lemmas establish identity and 
not just equality, thus avoiding most of the issues of extensional 
equality. In our implementation, the substitution on object terms is 
mapped directly to P-reduction, while Despeyroux et al. [DFH95] 
have to define it recursively. In addition, we provide a uniform ap-
proach to both free and bound variables that naturally extends to 
variable-length “vector” bindings.
# Para 969 3
While our approach is quite different from the modal X-calculus 
one [DPS97, DL99, DL01], there are some similarities in the in-
tuition behind it. Despeyroux et al. [DPS97] says “Intuitively, we
# Para 972 1
interpret ❑B as the type of closed objects of type B. We can iter-
# Para 973 5
ate or distinguish cases over closed objects, since all constructors 
are statically known and can be provided for.” The intuition be-
hind our approach is in part based on the canonical model of the 
NuPRL type theory [All87a, All87b], where each type is mapped 
to an equivalence relations over the closed terms of that type.
# Para 978 8
Gordon and Melham [GM96] define the type of X-terms as a 
quotient of the type of terms with concrete binding variables over 
a-equivalence. Michael Norrish [Nor04] builds upon this work by 
replacing certain variable “freshness” requirements with variable 
“swapping”. This approach has a number of attractive properties; 
however, we believe that the level of abstraction provided by the 
HOAS-style approaches makes the HOAS style more convenient 
and accessible.
# Para 986 9
Ambler, Crole, and Momigliano [ACM02] have combined the 
HOAS with the induction principle using an approach which in 
some sense is opposite to ours. Namely, they define the HOAS 
operators on top of the de Bruijn definition of terms using higher 
order pattern matching. In a later work [ACM03] they have de-
scribed the notion of “terms-in-infinite-context” which is quite sim-
ilar to our approach to vector binding. While our vector bindings 
presented in Section 4.3 are finite length, the exact same approach 
would work for the infinite-length “vectors” as well.
# Para 995 1
Acknowledgments
# Para 996 3
The authors are grateful to Eli Barzilay whose ideas were an in-
spiration for some of the work that lead to this paper. We are also 
grateful for his comments on an early draft of this paper.
# Para 999 2
We are grateful to the anonymous reviewers for their very thor-
ough and fair feedback and many helpful suggestions.
# Para 1001 1
References
# Para 1002 1
[AA99] Eric Aaron and Stuart Allen. Justifying calculational logic
# Para 1003 3
by a conventional metalinguistic semantics. Technical Report 
TR99-1771, Cornell University, Ithaca, New York, September 
1999.
# Para 1006 6
[ABF+05] Brian E. Aydemir, Aaron Bohannon, Matthew Fairbairn, 
J. Nathan Foster, Benjamin C. Pierce, Peter Sewell, Dimitrios 
Vytiniotis, Geoffrey Washburn, Stephanie Weirich, and Steve 
Zdancewic. Mechanized metatheory for the masses: The 
POPLmark challenge. Available fromhttp://www.cis. 
upenn.edu/group/proj/plclub/mmm/,2005.
# Para 1012 1
[AC92] William Aitken and Robert L. Constable. Reflecting on
# Para 1013 2
NuPRL : Lessons 1–4. Technical report, Cornell University, 
Computer Science Department, Ithaca, NY, 1992.
# Para 1015 6
[ACE+00] Stuart Allen, Robert Constable, Richard Eaton, Christoph 
Kreitz, and Lori Lorigo. The NuPRL open logical envi-
ronment. In David McAllester, editor, Proceedings of the 
17th International Conference on Automated Deduction, vol-
ume 1831 of Lecture Notes in Artificial Intelligence, pages 
170–176. Springer Verlag, 2000.
# Para 1021 5
[ACHA90] Stuart F. Allen, Robert L. Constable, Douglas J. Howe, 
and William Aitken. The semantics of reflected proof. In 
Proceedings of the 5th Symposium on Logic in Computer 
Science, pages 95–197. IEEE Computer Society Press, June 
1990.
# Para 1026 1
[ACM02] Simon Ambler, Roy L. Crole, and Alberto Momigliano.
# Para 1027 5
Combining higher order abstract syntax with tactical theorem 
proving and (co)induction. In TPHOLs ’02: Proceedings 
of the 15th International Conference on Theorem Proving 
in Higher Order Logics, pages 13–30, London, UK, 2002. 
Springer-Verlag.
# Para 1032 1
[ACM03] S. J. Ambler, R. L. Crole, and Alberto Momigliano. A
# Para 1033 4
definitional approach to primitive recursion over higher 
order abstract syntax. In Proceedings of the 2003 workshop 
on Mechanized reasoning about languages with variable 
binding, pages 1–11. ACM Press, 2003.
# Para 1037 1
[ACU93] William Aitken, Robert L. Constable, and Judith Underwood.
# Para 1038 3
Metalogical Frameworks II: Using reflected decision pro-
cedures.Journal of Automated Reasoning, 22(2):171–221, 
1993.
# Para 1041 1
10
# Para 1042 1
[All87a]	Stuart F. Allen. A Non-type-theoretic Definition of Martin-
# Para 1043 3
L¨of’s Types. In D. Gries, editor, Proceedings ofthe 2nd IEEE 
Symposium on Logic in Computer Science, pages 215–224. 
IEEE Computer Society Press, June 1987.
# Para 1046 1
[All87b]	Stuart F. Allen. A Non-Type-Theoretic Semantics for Type-
# Para 1047 1
Theoretic Language. PhD thesis, Cornell University, 1987.
# Para 1048 1
[Art99]	Sergei Artemov. On explicit reflection in theorem proving
# Para 1049 2
and formal verification. In Ganzinger [Gan99], pages 267– 
281.
# Para 1051 1
[Art04]	Sergei Artemov. Evidence-based common knowledge.
# Para 1052 2
Technical Report TR-2004018, CUNY Ph.D. Program in 
Computer Science Technical Reports, November 2004.
# Para 1054 1
[BA02]	Eli Barzilay and Stuart Allen. Reflecting higher-order abstract
# Para 1055 6
syntax in NuPRL. In Victor A. Carre˜no, C´ezar A. Mu˜noz, 
and Sophi`ene Tahar, editors, Theorem Proving in Higher 
Order Logics; Track B Proceedings of the 15th International 
Conference on Theorem Proving in Higher Order Logics 
(TPHOLs 2002), Hampton, VA, August 2002, pages 23–32. 
National Aeronautics and Space Administration, 2002.
# Para 1061 1
[BAC03]	Eli Barzilay, Stuart Allen, and Robert Constable. Practical
# Para 1062 3
reflection in NuPRL. Short paper presented at 18th Annual 
IEEE Symposium on Logic in Computer Science, June 22– 
25, Ottawa, Canada, 2003.
# Para 1065 1
[Bar01]	Eli Barzilay. Quotation and reflection in NuPRL and Scheme.
# Para 1066 2
Technical Report TR2001-1832, Cornell University, Ithaca, 
New York, January 2001.
# Para 1068 1
[Bar05]	Eli Barzilay. Implementing Reflection in NuPRL. PhD thesis,
# Para 1069 1
Cornell University, 2005. In preparation.
# Para 1070 6
[CAB+86] Robert L. Constable, Stuart F. Allen, H. M. Bromley, W. R. 
Cleaveland, J. F. Cremer, R. W. Harper, Douglas J. Howe, 
T. B. Knoblock, N. P. Mendler, P. Panangaden, James T. 
Sasaki, and Scott F. Smith. Implementing Mathematics with 
the NuPRL ProofDevelopment System. Prentice-Hall, NJ, 
1986.
# Para 1076 1
[CFW04]	Luis Crus-Filipe and Freek Weidijk. Hierarchical reflection.
# Para 1077 1
In Slind et al. [SBG04], pages 66–81.
# Para 1078 1
[Con94]	Robert L. Constable. Using reflection to explain and enhance
# Para 1079 5
type theory. In Helmut Schwichtenberg, editor, Proof and 
Computation, volume 139 of NATO Advanced Study Insti-
tute, International Summer School held in Marktoberdorf, 
Germany, July 20-August 1, NATO Series F, pages 65–100. 
Springer, Berlin, 1994.
# Para 1084 1
[dB72]	N. G. de Bruijn. Lambda calculus notation with nameless
# Para 1085 5
dummies, a tool for automatic formula manipulation, with 
application to the Church-Rosser theorem. Indagaciones 
Mathematische, 34:381–392, 1972. This also appeared in the 
Proceedings of the Koninklijke Nederlandse Akademie van 
Wetenschappen, Amsterdam, series A, 75, No. 5.
# Para 1090 1
[DFH95]	Jo¨elle Despeyroux, Amy Felty, and Andr´e Hirschowitz.
# Para 1091 6
Higher-order abstract syntax in Coq. In M. Dezani-
Ciancaglini and G. Plotkin, editors, Proceedings of the 
International Conference on Typed Lambda Calculus and 
its Applications, volume 902 of Lecture Notes in Computer 
Science, pages 124–138. Springer-Verlag, April 1995. Also 
appears as INRIA research report RR-2556.
# Para 1097 1
[DH94]	Jo¨elle Despeyroux and Andr´e Hirschowitz. Higher-order
# Para 1098 6
abstract syntax with induction in Coq. In LPAR ’94: 
Proceedings of the 5th International Conference on Logic 
Programming and Automated Reasoning, volume 822 
of Lecture Notes in Computer Science, pages 159–173. 
Springer-Verlag, 1994. Also appears as INRIA research 
report RR-2292.
# Para 1104 1
[DH95]	James Davis and Daniel Huttenlocher. Shared annotations for
# Para 1105 3
cooperative learning. In Proceedings of the ACM Conference 
on Computer Supported Cooperative Learning, September 
1995.
# Para 1108 1
[DL99]	Jo¨elle Despeyroux and Pierre Leleu. A modal lambda
# Para 1109 5
calculus with iteration and case constructs. In T. Altenkirch, 
W. Naraschewski, and B. Reus, editors, Types for Proofs 
and Programs: International Workshop, TYPES ’98, Kloster 
Irsee, Germany, March 1998, volume 1657 of Lecture Notes 
in Computer Science, pages 47–61, 1999.
# Para 1114 1
[DL01]	Jo¨elle Despeyroux and Pierre Leleu. Recursion over objects
# Para 1115 2
of functional type. Mathematical Structures in Computer 
Science, 11(4):555–572, 2001.
# Para 1117 1
[DPS97]	Jo¨elle Despeyroux, Frank Pfenning, and Carsten Sch¨urmann.
# Para 1118 7
Primitive recursion for higher–order abstract syntax. In 
R. Hindley, editor, Proceedings of the Third International 
Conference on Typed Lambda Calculus and Applications 
(TLCA’97), volume 1210 of Lecture Notes in Computer 
Science, pages 147–163. Springer-Verlag, April 1997. An 
extended version is available as Technical Report CMU-CS-
96-172, Carnegie Mellon University.
# Para 1125 1
[EM71]	Andrzej Ehrenfeucht and Jan Mycielski. Abbreviating
# Para 1126 2
proofs by adding new axioms. Bulletin of the American 
Mathematical Society, 77:366–367, 1971.
# Para 1128 1
[F+86]	Solomon Feferman et al., editors. Kurt G¨odel Collected
# Para 1129 2
Works, volume 1. Oxford University Press, Oxford, 
Clarendon Press, New York, 1986.
# Para 1131 1
[FPT99]	Marcelo Fiore, Gordon Plotkin, and Daniele Turi. Abstract
# Para 1132 3
syntax and variable binding. In Proceedings of 14th IEEE 
Symposium on Logic in Computer Science, pages 193+. IEEE 
Computer Society Press, 1999.
# Para 1135 1
[Gan99]	Harald Ganzinger, editor. Proceedings of the 16th Interna-
# Para 1136 3
tional Conference on Automated Deduction, volume 1632 
of Lecture Notes in Artificial Intelligence, Berlin, July 7–10 
1999. Trento, Italy.
# Para 1139 1
[GM96]	A. D. Gordon and T. Melham. Five axioms of alpha-
# Para 1140 5
conversion. In J. von Wright, J. Grundy, and J. Harrison, 
editors, Theorem Proving in Higher Order Logics: 9th 
International Conference, Turku, Finland, August 1996: 
Proceedings, volume 1125 of Lecture Notes in Computer 
Science, pages 173–190. Springer-Verlag, 1996.
# Para 1145 4
[GMO03] Jim Grundy, Tom Melham, and John O’Leary. A reflective 
functional language for hardware design and theorem 
proving. Technical Report PRG-RR-03-16, Oxford Univerity, 
Computing Laboratory, 2003.
# Para 1149 1
[G¨od31 ]	Kurt G¨odel. ¨Uber formal unentscheidbare s¨atze der principia
# Para 1150 3
mathematica und verwandter systeme I. Monatshefte f¨ur 
Mathematik und Physik, 38:173–198, 1931. English version 
in [vH67].
# Para 1153 1
[G¨od36]	K. G¨odel. ¨Uber die L¨ange von beweisen. Ergebnisse
# Para 1154 2
eines mathematischen Kolloquiums, 7:23–24, 1936. English 
translation in [F+86], pages 397–399.
# Para 1156 1
[GS89]	F. Giunchiglia and A. Smaill. Reflection in constructive
# Para 1157 4
and non-constructive automated reasoning. In H. Abramson 
and M. H. Rogers, editors, Meta-Programming in Logic 
Programming, pages 123–140. MIT Press, Cambridge, 
Mass., 1989.
# Para 1161 6
[GWZ00] H. Geuvers, F. Wiedijk, and J. Zwanenburg. Equational rea-
soning via partial reflection. In J. Harrison and M. Aagaard, 
editors, Theorem Proving in Higher Order Logics: 13th Inter-
national Conference, TPHOLs 2000, volume 1869 of Lecture 
Notes in Computer Science, pages 162–178. Springer-Verlag, 
2000.
# Para 1167 1
[HAB+]	Jason J. Hickey, Brian Aydemir, Yegor Bryukhov, Alexei
# Para 1168 2
Kopylov, Aleksey Nogin, and Xin Yu. A listing of Meta PRL 
theories. http://metaprl.org/theories.pdf.
# Para 1170 1
[Har95]	J. Harrison. Metatheory and reflection in theorem proving:
# Para 1171 3
A survey and critique. Technical Report CRC-53, SRI 
International, Cambridge Computer Science Research 
Centre, Millers Yard, Cambridge, UK, February 1995.
# Para 1174 1
11
# Para 1175 1
[HHP93]	Robert Harper, Furio Honsell, and Gordon Plotkin. A
# Para 1176 3
framework for defining logics. Journal of the Association 
for Computing Machinery, 40(1):143–184, January 1993. A 
revised and expanded verion of ’87 paper.
# Para 1179 1
[Hic97]	Jason J. Hickey. NuPRL-Light: An implementation
# Para 1180 7
framework for higher-order logics. In William McCune, 
editor, Proceedings of the 14th International Conference 
on Automated Deduction, volume 1249 of Lecture Notes in 
Artificial Intelligence, pages 395–399. Springer, July 13–17 
1997. An extended version of the paper can be found at 
http://www.cs.caltech.edu/~jyh/papers/cade14_ 
nl/default.html.
# Para 1187 1
[Hic99]	Jason J. Hickey. Fault-tolerant distributed theorem proving.
# Para 1188 1
In Ganzinger [Gan99], pages 227–231.
# Para 1189 1
[Hic01]	Jason J. Hickey. The MetaPRL Logical Programming
# Para 1190 2
Environment. PhD thesis, Cornell University, Ithaca, NY, 
January 2001.
# Para 1192 1
[HL78]	G´erard P. Huet and Bernard Lang. Proving and applying
# Para 1193 2
program transformations expressed with second-order 
patterns. Acta Informatica, 11:31–55,1978.
# Para 1195 10
[HNC+03] Jason Hickey, Aleksey Nogin, Robert L. Constable, 
Brian E. Aydemir, Eli Barzilay, Yegor Bryukhov, Richard 
Eaton, Adam Granicz, Alexei Kopylov, Christoph Kreitz, 
Vladimir N. Krupski, Lori Lorigo, Stephan Schmitt, Carl 
Witty, and Xin Yu. MetaPRL — A modular logical en-
vironment. In David Basin and Burkhart Wolff, editors, 
Proceedings of the 16th International Conference on Theo-
rem Proving in Higher OrderLogics (TPHOLs 2003), volume 
2758 of Lecture Notes in Computer Science, pages 287–303. 
Springer-Verlag, 2003.
# Para 1205 1
[HNK+]	Jason J. Hickey, Aleksey Nogin, Alexei Kopylov, et al.
# Para 1206 1
MetaPRL home page. http://metaprl.org/.
# Para 1207 1
[Mos52]	Andrzej Mostowski. Sentences undecidable in formalized
# Para 1208 2
arithmetic: an exposition of the theory of Kurt G¨odel. 
Amsterdam: North-Holland, 1952.
# Para 1210 1
[NH02]	Aleksey Nogin and Jason Hickey. Sequent schema for
# Para 1211 5
derived rules. In Victor A. Carre˜no, C´ezar A. Mu˜noz, 
and Sophi`ene Tahar, editors, Proceedings of the 15th 
International Conference on Theorem Proving in Higher 
Order Logics (TPHOLs 2002), volume 2410 of Lecture Notes 
in Computer Science, pages 281–297. Springer-Verlag, 2002.
# Para 1216 6
[NKYH05] Aleksey Nogin, Alexei Kopylov, Xin Yu, and Jason Hickey. 
A computational approach to reflective meta-reasoning 
about languages with bindings. Technical Report Cal-
techCSTR:2005.003, California Institure of Technology, 
2005. Available at http://resolver.caltech.edu/ 
CaltechCSTR:2005.003.
# Para 1222 1
[Nor04]	Michael Norrish. Recursive function definition for types with
# Para 1223 1
binders. In Slind et al. [SBG04], pages 241–256.
# Para 1224 1
[Par71]	R. Parikh. Existence and feasibility in arithmetic. The Journal
# Para 1225 1
ofSymbolic Logic, 36:494–508,1971.
# Para 1226 1
[Pau94]	Lawrence C. Paulson. Isabelle: A Generic Theorem Prover,
# Para 1227 2
volume 828 of Lecture Notes in Computer Science. Springer-
Verlag, New York, 1994.
# Para 1229 1
[PE88]	Frank Pfenning and Conal Elliott. Higher-order abstract
# Para 1230 4
syntax. In Proceedings oftheACMSIGPLAN’88 Conference 
on Programming Language Design and Implementation 
(PLDI), volume 23(7) of SIGPLANNotices, pages 199–208, 
Atlanta, Georgia, June 1988. ACM Press.
# Para 1234 1
[Pfe89]	Frank Pfenning. Elf: a language for logic definition and
# Para 1235 4
verified metaprogramming. In Proceedings of the 4th IEEE 
Symposium on Logic in Computer Science, pages 313–322, 
Asilomar Conference Center, Pacific Grove, California, June 
1989. IEEE Computer Society Press.
# Para 1239 1
[Plo90]	Gordon Plotkin. An illative theory of relations. In R. Cooper,
# Para 1240 4
K. Mukai, and J. Perry, editors, Situation Theory and Its 
Applications, Volume 1, number 22 in CSLI Lecture Notes, 
pages 133–146. Centre for the Study of Language and 
Information, 1990.
# Para 1244 1
[PN90]	L. Paulson and T. Nipkow. Isabelle tutorial and user’s man-
# Para 1245 2
ual. Technical report, University of Cambridge Computing 
Laboratory, 1990.
# Para 1247 1
[SBG04]	Konrad Slind, Annette Bunker, and Ganesh Gopalakrishnan,
# Para 1248 4
editors. Proceedings of the 17th International Conference 
on Theorem Proving in Higher Order Logics (TPHOLs 
2004), volume 3223 of Lecture Notes in Computer Science. 
Springer-Verlag, 2004.
# Para 1252 1
[Sch01]	Carsten Sch¨urmann. Recursion for higher-order encodings.
# Para 1253 4
In L. Fribourg, editor, Computer Science Logic, Proceedings 
of the 10th Annual Conference of the EACSL, volume 2142 
of Lecture Notes in Computer Science, pages 585–599. 
Springer-Verlag, 2001.
# Para 1257 1
[Smi84]	B.C. Smith. Reflection and semantics in Lisp. Principles of
# Para 1258 1
Programming Languages, pages 23–35, 1984.
# Para 1259 1
[vH67]	J. van Heijenoort, editor. From Frege to G¨odel: A Source
# Para 1260 2
Book in Mathematical Logic, 1879–1931. Harvard University 
Press, Cambridge, MA, 1967.
# Para 1262 1
12
