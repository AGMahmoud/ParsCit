Before getting into the details of the implementation, a brief description of the Omnipage output as well as PDFx output is provided in the following subsections.

\section{Omnipage Output XML}
The XML generated by Omnipage after processing a document has the following structure:
\begin{itemize}
\item Each document is divided into pages.
  Pages are divided into sections that represent blocks of text (or tables, images etc) placed horizontally from top to bottom of the page.
  Each section is divided into columns.
  If the running text in eah sentence occupies the entire width of the page, then there would be just one column.
  However, it is very common for scientific articles to have two columns with the text first filling up the left column and then the right.
  Each column is divided into paragraphs, paragraphs into lines, lines into runs, runs into words.
\item Word represents the smallest modularity in the xml.
  The 'space' tag which appears after each word tag is also of the smallest modularity.
\item The order of text in the xml reflects the flow of text on a page.
  This means that the xml covers all the paragraphs, lines and words in the left column and then moves to the right column in case of 2 columns.
\item Runs appear within a line if there is a change in the textual property (font, sub/super-script etc) of words within that line.
  Each run represents a block of text that has the same textual properties.
\item Elements like tables, figures and the page number on a page appear within the 'dd' tag.
\end{itemize}

\section{PDFx Output XML}
Following are the points regarding the structure of XML generated by PDFx after processing pdf documents.
\begin{itemize}
\item The XML contains a group of 'fontspec' tags at the beginning of the document.
  Each 'fontspec' tag is for a font that has been observed by PDFx in that document and contains information about the font family, the size of text with that font and a unique identifier for the size and font family appearing in that document.
\item Each page in the pdf document has a corresponding 'page' tag. Unlike Omnipage, there are no further divisions to the page.
  Each page tag is essentially a dump of all the words that appear on that page.
\item Similar to the organization of text flow in Omnipage, the PDFx XML also has all the words appearing in an order reflecting the flow of information in the page.
\end{itemize}

\section{Overview}
The crosswalk has been implemented as a Python script which is located in the 'bin' directory of ParsCit library root directory.
To incorporate this functionality in the core system, a command line switch has been added to \emph{ParsCit/bin/citeExtract.pl}.
This is done by including 'pdf' as one of the legal values for the '-i' (inputType) commandline option.

The input to this script is an XML file that should be generated using PDFx on a pdf file.
The output of this script is another XML file representing the same pdf file with the markup similar to Omnipage output, which for simplicity will be referred to as pseudo-Omni format.
To process the xml tags, 'lxml' Python library has been used.
This library is used to parse the input XML as well as create the output XML.

The processing starts by considering each 'page' tag of the PDFx XML.
Since the 'page' tag in the PDFx XML contains only words, the main logic is basically to look for change in the word attributes (top, bottom, left, and right) and comparing with the previous word to see if there is a change in the line or not.
Logic to decide whether there should be a change in the paragraph and column is built over this code flow.
Once all the words under a 'page' tag have been processed, one significant move is to look for the page number.
This is because in Omnipage format, the page number appears under the 'dd' tag at the after the rest of the text has been accounted for.

\section{Details}
The central idea is to read the PDFx generated XML and simultaneously generate the output (pseudo-Omni) XML with each word read.
Each 'word' tag in the PDFx XML corresponds to a 'wd' tag in the output XML.

The main logic starts in the function \emph{getCurrentLine} which is called with each encounter of a 'word' tag in the PDFx XML.
This function returns the 'ln' (line) tag which is added to the output pseudo-Omni XML as a child of the 'para' tag and is also the parent for the corresponding 'wd' tag.
The returned 'ln' tag is either the same tag that the previous 'wd' tag was under, or a new 'ln' tab indicating the beginning of the next line.
This is determined by measuring the distance between the coordinates representing the bottom of the current word and the bottom of the line containing the previous word.
If this distance is less than a tuned value (represented by LSPACE), then it is assumed that the current word belongs to the same line as the previous word and the same line is returned.

If not, then the first thing before creating and processing a new 'ln' tag is to conclude the properties of the previous line.
This includes filling in values for the essential attributes of the 'ln' tag (currently the attribute 'r' representing the \emph{right coordiante} of the line) and checking for the presence of runs within the completed line.
Runs are identified by comparing the 'font' attribute of each word.
Chuncks of words that belong to the same font are grouped together into 'run' tags inside the 'ln' tag.

The next step in processing the new line has been referred to as margin overflow.
This occurs when the first line of a new paragraph is indented.
As will be shown later, in that case, the parents ('para' and 'column') of this indented line share the left ('l') attribute of the line.
In this case, the remaining lines would have a sligthly shifted (towards the left) left coordinate.
To fix this, the 'l' attribute of new line is compared with the 'l' attribute of the previous line's parents.
If the new line is found slightly shifted towards the left, then the 'l' attribute of the enclosing para and column are updated to that of the new line.
Care is taken to ensure that the new line is not from another column.

The next thing to determine is whether there is a change in the para or column or neither.
For this, there are a couple of conditions to check for.
The distance between the current line and the previous line should be greater than the tuned value PSPACE.

***para & column ***
***final touches***
