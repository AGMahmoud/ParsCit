MBT: A Memory-Based Part of Speech Tagger-Generator |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_begin xmlFontSize_largest0 xmlFontSizeChange_begin xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Walter Daelemans, Jakub Zavrel |XML| xmlLoc_0 xmlAlign_none xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_larger xmlFontSizeChange_smaller xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Computational Linguistics and AT |XML| xmlLoc_0 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Tilburg University |XML| xmlLoc_1 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
P.O. Box 90153, NL-5000 LE Tilburg |XML| xmlLoc_1 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
fwalter.daelemans,zavrelleaub.n1 |XML| xmlLoc_1 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Peter Berck, Steven Gillis |XML| xmlLoc_1 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_no xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Center for Dutch Language and Speech |XML| xmlLoc_1 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
University of Antwerp |XML| xmlLoc_1 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Universiteitsplein 1, B-2610 Wilrijk |XML| xmlLoc_2 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Ipeter.berck,steven.gillislftia.ua.ac.be |XML| xmlLoc_2 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Abstract |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
We introduce a memory-based approach to part of speech tagging. Memory-based  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
learning is a form of supervised learning based on similarity-based reasoning. The part  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
of speech tag of a word in a particular context is extrapolated from the most similar  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
cases held in memory. Supervised learning approaches are useful when a tagged corpus  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
is available as an example of the desired output of the tagger. Based on such a corpus,  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
the tagger-generator automatically builds a tagger which is able to tag new text the  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
same way, diminishing development time for the construction of a tagger considerably.  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Memory-based tagging shares this advantage with other statistical or machine learning  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
approaches. Additional advantages specific to a memory-based approach include (i) the  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
relatively small tagged corpus size sufficient for training, (ii) incremental learning, (iii)  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
explanation capabilities, (iv) flexible integration of information in case representations,  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
(v) its non-parametric nature, (vi) reasonably good results on unknown words without  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
morphological analysis, and (vii) fast learning and tagging. In this paper we show that  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
a large-scale application of the memory-based approach is feasible: we obtain a tagging  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
accuracy that is on a par with that of known statistical approaches, and with attractive  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
space and time complexity properties when using IGTree, a tree-based formalism for  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
indexing and searching huge case bases. The use of IGTree has as additional advantage  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
that optimal context size for disambiguation is dynamically computed. |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
1 Introduction |XML| xmlLoc_5 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Part of Speech (POS) tagging is a process in which syntactic categories are assigned to  |XML| xmlLoc_5 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
words. It can be seen as a mapping from sentences to strings of tags. |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Automatic tagging is useful for a number of applications: as a preprocessing stage  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
to parsing, in information retrieval, in text to speech systems, in corpus linguistics, etc.  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
The two factors determining the syntactic category of a word are its lexical probability  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
(e.g. without context, man is more probably a noun than a verb), and its contextual  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
probability (e.g. after a pronoun, man is more probably a verb than a noun, as in they  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
man the boats). Several approaches have been proposed to construct automatic taggers.  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Most work on statistical methods has used n-gram models or Hidden Markov Model-based  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
taggers (e.g. Church, 1988; DeRose, 1988; Cutting et al. 1992; Merialdo, 1994, etc.). In |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
14 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
these approaches, a tag sequence is chosen for a sentence that maximizes the product of  |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
lexical and contextual probabilities as estimated from a tagged corpus. |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In rule-based approaches, words are assigned a tag based on a set of rules and a  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
lexicon. These rules can either be hand-crafted (Garside et al., 1987; Klein &amp; Simmons,  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
1963; Green 8.6 Rubin, 1971), or learned, as in Hindle (1989) or the transformation-based  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
error-driven approach of Brill (1992). |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In a memory-based approach, a set of cases is kept in memory. Each case consists of a  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word (or a lexical representation for the word) with preceding and following context, and  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the corresponding category for that word in that context. A new sentence is tagged by  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
selecting for each word in the sentence and its context the most similar case(s) in memory,  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and extrapolating the category of the word from these &apos;nearest neighbors&apos;. A memory-  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
based approach has features of both learning rule-based taggers (each case can be regarded  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
as a very specific rule, the similarity based reasoning as a form of conflict resolution and  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
rule selection mechanism) and of stochastic taggers: it is fundamentally a form of k-nearest  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
neighbors (k-nn) modeling, a well-known non-parametric statistical pattern recognition  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
technique. The approach in its basic form is computationally expensive, however; each  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
new word in context that has to be tagged, has to be compared to each pattern kept  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
in memory. In this paper we show that a heuristic case base compression formalism  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(Daelemans et al., 1996), makes the memory-based approach computationally attractive. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
2 Memory-Based Learning |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Memory-based Learning is a form of supervised, inductive learning from examples. Ex- |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
amples are represented as a vector of feature values with an associated category label.  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
During training, a set of examples (the training set) is presented in an incremental fash- |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ion to the classifier, and added to memory. During testing, a set of previously unseen  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
feature-value patterns (the test set) is presented to the system. For each test pattern, its  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
distance to all examples in memory is computed, and the category of the least distant  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
instance(s) is used as the predicted category for the test pattern. The approach is based  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
on the assumption that reasoning is based on direct reuse of stored experiences rather  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
than on the application of knowledge (such as rules or decision trees) abstracted from  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
experience. |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In AI, the concept has appeared in several disciplines (from computer vision to robotics),  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
using terminology such as similarity-based, example-based, memory-based, exemplar-  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
based, case-based, analogical, lazy, nearest-neighbour, and instance-based (Stanfill and  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Waltz, 1986; Kolodner, 1993; Aha et al. 1991; Salzberg, 1990). Ideas about this type of  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
analogical reasoning can be found also in non-mainstream linguistics and pyscholinguistics  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(Skousen, 1989; Derwing Skousen, 1989; Chandler, 1992; Scha, 1992). In computational  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
linguistics (apart from incidental computational work of the linguists referred to earlier),  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the general approach has only recently gained some popularity: e.g., Cardie (1994, syn- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tactic and semantic disambiguation); Daelemans (1995, an overview of work in the early  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
nineties on memory-based computational phonology and morphology); Jones (1996, an  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
overview of example-based machine translation research); Federici and Pirrelli (1996). |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
2.1 Similarity Metric |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Performance of a memory-based system (accuracy on the test set) crucially depends on  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the distance metric (or similarity metric) used. The most straightforward distance metric  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
would be the one in equation (1), where X and Y are the patterns to be compared, and  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
6(x, yi) is the distance between the values of the i-th feature in a pattern with n features. |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
15 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
A(X, Y) E .6(xi,y•)	(1) |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Distance between two values is measured using equation (2), an overlap metric, for  |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
symbolic features (we will have no numeric features in the tagging application). |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
S(xt, yz) = 0 if xi = yi, else 1 (2) |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
We will refer to this approach as IB1 (Aha et al., 1991). We extended the algorithm  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
described there in the following way: in case a pattern is associated with more than one  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
category in the training set (i.e. the pattern is ambiguous), the distribution of patterns  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
over the different categories is kept, and the most frequently occurring category is selected  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
when the ambiguous pattern is used to extrapolate from. |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
In this distance metric, all features describing an example are interpreted as being  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
equally important in solving the classification problem, but this is not necessarily the  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
case. In tagging, the focus word to be assigned a category is obviously more relevant than  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
any of the words in its context. We therefore weigh each feature with its information gain;  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
a number expressing the average amount of reduction of training set information entropy  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
when knowing the value of the feature (Daelemans &amp; van de Bosch, 1992, Quinlan, 1993;  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Hunt et al. 1966) (Equation 3). We will call this algorithm IB-IG. |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
,A(X,Y) = E G(fi)5(xi,yi) (3) |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
3 IGTrees |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Memory-based learning is an expensive algorithm: of each test item, all feature values  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
must be compared to the corresponding feature values of all training items. Without  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
optimisation, it has an asymptotic retrieval complexity of 0(NF) (where N is the number  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
of items in memory, and F the number of features). The same asymptotic complexity  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
is of course found for memory storage in this approach. We use IGTrees (Daelemans et  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
al. 1996) to compress the memory. IGTree is a heuristic approximation of the IB-IG  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
algorithm. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
3.1 The IGTree Algorithms |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
IGTree combines two algorithms: one for compressing a case base into a trees, and one for  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
retrieving classification information from these trees. During the construction of IGTree  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
decision trees, cases are stored as paths of connected nodes. All nodes contain a test  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(based on one of the features) and a class label (representing the default class at that  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
node). Nodes are connected via arcs denoting the outcomes for the test (feature values).  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
A feature relevance ordering technique (in this case information gain, see Section 2.1) is  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
used to determine the order in which features are used as tests in the tree. This order  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
is fixed in advance, so the maximal depth of the tree is always equal to the number of  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
features, and at the same level of the tree, all nodes have the same test (they are an  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
instance of oblivious decision trees; cf. Langley &amp; Sage, 1994). The reasoning behind this  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
reorganisation (which is in fact a compression) is that when the computation of feature  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
relevance points to one feature clearly being the most important in classification, search  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
can be restricted to matching a test case to those stored cases that have the same feature  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
value at that feature. Besides restricting search to those memory cases that match only  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
on this feature, the case memory can be optimised by further restricting search to the |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
16 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Procedure BUILD-IG-TREE:  |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Input: |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
•	A training set T of cases with their classes (start value: a full case base), |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_yes
•	an information-gain-ordered list of features (tests) Fz...Fn (start value: Fi...Fn).  |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_yes
Output: A (sub)tree. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_yes
1. If T is unambiguous (all cases in T have the same class c), create a leaf node with class label c. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_yes
2. Else if i = (n + 1), create a leaf node with as label the class occurring most frequently in T.  |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_yes
3. Otherwise, until i = n (the number of features) |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_yes
•	Select the first feature (test) Fi in F„..F7i, and construct a new node N for feature F.„ and as  |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
default class c (the class occurring most frequently in T). |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
•	Partition T into subsets T1...Tni according to the values 01...vrn which occur for F, in T (cases  |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
with the same value for this feature in the same subset). |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
•	For each je{l, m}: BUILD-IG-TREE (T3, Fi+1.-Fn), |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
connect the root of this subtree to N and label the arc with v.,. |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Figure I: Algorithm for building IGTrees (`BUILD-IG-TREE&apos;). |XML| xmlLoc_2 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
second most important feature, followed by the third most important feature, etc. A  |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
considerable compression is obtained as similar cases share partial paths. |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Instead of converting the case base to a tree in which all cases are fully represented as  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
paths, storing all feature values, we compress the tree even more by restricting the paths  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
to those input feature values that disambiguate the classification from all other cases in  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
the training material. The idea is that it is not necessary to fully store a case as a path  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
when only a few feature values of the case make its classification unique. This implies that  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
feature values that do not contribute to the disambiguation of the case classification (i.e.,  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
the values of the features with lower feature relevance values than the the lowest value  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
of the disambiguating features) are not stored in the tree. In our tagging application,  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
this means that only context feature values that actually contribute to disambiguation  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
are used in the construction of the tree. |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Leaf nodes contain the unique class label corresponding to a path in the tree. Non-  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
terminal nodes contain information about the most probable or default classification given  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
the path thus far, according to the bookkeeping information on class occurrences main- |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
tained by the tree construction algorithm. This extra information is essential when using  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
the tree for classification. Finding the classification of a new case involves traversing the  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
tree (i.e., matching all feature values of the test case with arcs in the order of the overall  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
feature information gain), and either retrieving a classification when a leaf is reached, or  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
using the default classification on the last matching non-terminal node if a feature-value  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
match fails. |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
A final compression is obtained by pruning the derived tree. All leaf-node daughters  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
of a mother node that have the same class as that node are removed from the tree, as  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
their class information does not contradict the default class information already present  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
at the mother node. Again, this compression does not affect IGTree&apos;s generalisation  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
performance. |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
The recursive algorithms for tree construction (except the final pruning) and retrieval  |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
are given in Figures 1 and 2. For a detailed discussion, see Daelemans et al. (1996). |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
17 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Procedure SEARCH-IC-TREE: |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Input: |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
•	The root node N of a subtree (start value: top node of a complete IGTree), |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_yes
•	an unlabeled case I with information-gain-ordered feature values ft... fn, (start value: fi.•./.).  |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_yes
Output: A class label. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_yes
1. If N is a leaf node, output default class c associated with this node. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
2. Otherwise, if test F, of the current node does not originate an arc labeled with ft, output default  |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
class c associated with N. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
3. Otherwise, |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
•	new node M is the end node of the arc originating from N with as label L. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_yes
•	SEARCH-IG-TREE (M, fi+i |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_yes
Figure 2: Algorithm for searching IGTrees (&apos;SEARCH-IG-TREE&apos;).  |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
3.2 IGTree Complexity |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
The asymptotic complexity of IGTree (i.e, in the worst case) is extremely favorable.  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Complexity of searching a query pattern in the tree is proportional to F * log(V), where  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
F is the number of features (equal to the maximal depth of the tree), and V is the average  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
number of values per feature (i.e., the average branching factor in the tree). In IB1, search  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
complexity is 0(N * F) (with N the number of stored cases). Retrieval by search in the  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
tree is independent from the number of training cases, and therefore especially useful for  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
large case bases. Storage requirements are proportional to N (compare 0(N * F) for  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
IB1). Finally, the cost of building the tree on the basis of a set of cases is proportional to  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
N * log(V) * F in the worst case (compare 0(N) for training in IB1). |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
In practice, for our part-of-speech tagging experiments, IGTree retrieval is 100 to 200  |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
times faster than normal memory-based retrieval, and uses over 95% less memory. |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
4 Architecture of the Tagger |XML| xmlLoc_5 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
The architecture takes the form of a tagger generator given a corpus tagged with the  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
desired tag set, a POS tagger is generated which maps the words of new text to tags  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
in this tag set according to the same systematicity. The construction of a POS tagger  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
for a specific corpus is achieved in the following way. Given an annotated corpus, three  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
datastructures are automatically extracted: a lexicon, a case base for known words (words  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
occurring in the lexicon), and a case base for unknown words. Case Bases are indexed  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
using IGTree. During tagging, each word in the text to be tagged is looked up in the  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
lexicon. If it is found, its lexical representation is retrieved and its context is determined,  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
and the resulting pattern is looked up in the known words case base. When a word is  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
not found in the lexicon, its lexical representation is computed on the basis of its form,  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
its context is determined, and the resulting pattern is looked up in the unknown words  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
case base. In each case, output is a best guess of the category for the word in its current  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
context. In the remainder of this section, we will describe each step in more detail. We  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
start from a training set of tagged sentences T. |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
18 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
4.1 Lexicon Construction |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
A lexicon is extracted from T by computing for each word in T the number of times it  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
occurs with each category. E.g. when using the first 2 million words of the Wall Street  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Journal corpus&apos; as T, the word once would get the lexical definition RB: 330; IN: 77,  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
i.e. once was tagged 330 times as an adverb, and 77 times as a preposition/subordinating  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
conjunction.2 |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Using these lexical definitions, a new, possibly ambiguous, tag is produced for each  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word type. E.g. once would get a new tag, representing the category of words which  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
can be both adverbs and prepositions/conjunctions (RB-IN). Frequency order is taken  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
into account in this process: if there would be words which, like once, can be RB or IN,  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
but more frequently IN than RB (e.g. the word below), then a different tag (IN-RB) is  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
assigned to these words. The original tag set, consisting of 44 morphosyntactic tags, was  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
expanded this way to 419 (possibly ambiguous) tags. In the WSJ example, the resulting  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
lexicon contains 57962 word types, 7464 (13%) of which are ambiguous. On the same  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
training set, 76% of word tokens are ambiguous. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
When tagging a new sentence, words are looked up in the lexicon. Depending on  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
whether or not they can be found there, a case representation is constructed for them,  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and they are retrieved from either the known words case base or the unknown words case  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
base. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
4.2 Known Words |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
A windowing approach (Sejnowski &amp; Rosenberg, 1987) was used to represent the tagging  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
task as a classification problem. A case consists of information about a focus word to  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
be tagged, its left and right context, and an associated category (tag) valid for the focus  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word in that context. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
There are several types of information which can be stored in the case base for each  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word, ranging from the words themselves to intricate lexical representations. In the pre- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
liminary experiments described in this paper, we limited this information to the possibly  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ambiguous tags of words (retrieved from the lexicon) for the focus word and its context  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
to the right, and the disambiguated tags of words for the left context (as the result of  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
earlier tagging decisions). Table 1 is a sample of the case base for the first sentence of the  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
corpus (Pierre Vinken, 61 years old, will join the board as a nonexecutiye director nom  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
29) when using this case representation. The final column shows the target category; the  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
disambiguated tag for the focus word. We will refer to this case representation as ddf at  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(d for disambiguated, f for focus, a for ambiguous, and t for target). The information  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
gain values are given as well. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
A search among a selection of different context sizes suggested ddf at as a suitable  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
case representation for tagging known words. An interesting property of memory-based  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
learning is that case representations can be easily extended with different sources of in- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
formation if available (e.g. feedback from a parser in which the tagger operates, semantic  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
types, the words themselves, lexical representations of words obtained from a different  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
source than the corpus, etc.). The information gain feature relevance ordering technique  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
achieves a delicate relevance weighting of different information sources when they are  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
fused in a single case representation. The window size used by the algorithm will also  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
dynamically change depending on the information present in the context for the disam- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
biguation of a particular focus symbol (see Schiitze et al., 1994, and Pereira et al., 1995 |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
1ACL Data Collection Initiative CD-ROM 1, September 1991. |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
2We disregarded a category associated with a word when less than 10% of the word tokens were tagged  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
with that category. This way, noise in the training material is filtered out. The value for this parameter will  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
have to be adapted for other training sets, and was chosen here to maximise generalization accuracy (accuracy  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
on tagging unseen text). |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
19 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Table 1: Case representation and information gain pattern for known words. |XML| xmlLoc_0 xmlAlign_right xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word	d	case representation d	f	a			t |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
IG	.06	.22	.82	.23	 |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
Pierre Vinken ,	= = np	=	np np ,	np	np np |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
61	nP ,	np np	cd nns jj-np	,	cd nns jj |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
years	cd	,		cd nns	 |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
old		cd nns		jj-np	 |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
				,	 |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
for similar approaches). |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
4.3 Unknown Words |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
If a word is not present in the lexicon, its ambiguous category cannot be retrieved. In that  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
case, a category can be guessed only on the basis of the form or the context of the word.  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Again, we take advantage of the data fusion capabilities of a memory-based approach by  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
combining these two sources of information in the case representation, and having the  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
information gain feature relevance weighting technique figure out their relative relevance  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
(see Schmid, 1994; Samuelsson, 1994 for similar solutions). |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
In most taggers, some form of morphological analysis is performed on unknown words,  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
in an attempt to relate the unknown word to a known combination of known morphemes,  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
thereby allowing its association with one or more possible categories. After determin- |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
ing this ambiguous category, the word is disambiguated using context knowledge, the  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
same way as known words. Morphological analysis presupposes the availability of highly  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
language-specific resources such as a morpheme lexicon, spelling rules, morphological  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
rules, and heuristics to prioritise possible analyses of a word according to their plausi- |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
bility. This is a serious knowledge engineering bottleneck when the goal is to develop a  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
language and annotation-independent tagger generator. |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
In our memory-based approach, we provide morphological information (especially  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
about suffixes) indirectly to the tagger by encoding the three last letters of the word  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
as separate features in the case representation. The first letter is encoded as well because  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
it contains information about prefix and capitalization of the word. Context information  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
is added to the case representation in a similar way as with known words. It turned out  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
that in combination with the &apos;morphological&apos; features, a context of one disambiguated tag  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
of the word to the left of the unknown word and one ambiguous category of the word to  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
the right, gives good results. We will call this case representation pdassst:3 three suffix  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
letters (s), one prefix letter (p), one left disambiguated context words (d), and one am- |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
biguous right context word (a). As the chance of an unknown word being a function word  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
is small, and cases representing function words may interfere with correct classification  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
of open-class words, only open-class words are used during construction of the unknown  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
words case base. |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Table 2 shows part of the case base for unknown words. |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
3These parameters (optimal context size and number of suffix features) were again optimised for general- |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
ization accuracy. |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
20 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Table 2: Case representation and information gain pattern for unknown words. |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word	p	d	case representation a	s	s			s	t |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
IG	.21	.21	.14	.15	.20	.32	 |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
Pierre Vinken 61	P V 6 y o	=	np	r k =	r e 6 r 1	e n 1 s d	np np cd nns |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
years		np	,	a o			jj |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
old		,	nns jj-np				 |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
		cd nns	,				 |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
4.4 Control |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Figure 3 shows the architecture of the tagger-generator: a tagger is produced by extracting  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a lexicon and two case-bases from the tagged example corpus. During tagging, the control  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
is the following: words are looked up in the lexicon and separated into known and unknown  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
words. They are retrieved from the known words case base and the unknown words case  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
base, respectively. In both cases, context is used, in the case of unknown words, the first  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and three last letters of the word are used instead of the ambiguous tag for the focus  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word. As far as disambiguated tags for left context words are used, these are of course  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
not obtained by retrieval from the lexicon (which provides ambiguous categories), but by  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
using the previous decisions of the tagger. |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
TAGGER GENERATION	TAGGING |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
LEXICON word -&gt; a |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_yes xmlBullet_no xmlIndent_no
KNOWN WORDS ■ CASE BASE |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_yes xmlBullet_no xmlIndent_no
ddfa -&gt; t |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_yes xmlBullet_no xmlIndent_no
UNKNOWN WORDS i CASE BASE |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_yes xmlBullet_no xmlIndent_no
pdasss -&gt; t |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_yes xmlBullet_no xmlIndent_no
TAGGER |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_yes xmlBullet_no xmlIndent_no
Tagged Corpus	 |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_yes xmlBullet_no xmlIndent_no
New Text |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
	- Tagged Text |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Figure 3: Architecture of the tagger-generator: flow of control.  |XML| xmlLoc_5 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
4.5 IGTrees for Tagging |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
As explained earlier, both case bases are implemented as IGTrees. For the known words  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
case base, paths in the tree represent variable size context widths. The first feature  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(the expansion of the root node of the tree) is the focus word, then context features are  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
added as further expansions of the tree until the context disambiguates the focus word  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
completely. Further expansion is halted at that point. In some cases, short context sizes  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(corresponding to bigrams, e g) are sufficient to disambiguate a focus word, in other cases,  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
more context is needed. IGTrees provide an elegant way of automatic determination of |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
21 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
optimal context size. In the unknown words case base, the trie representation provides  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
an automatic integration of information about the form and the context of a focus word  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
not encountered before. In general, the top levels of the tree represent the morphological  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
information (the three suffix letter features and the prefix letter), while the deeper levels  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
contribute contextual disambiguation. |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
5 Experiments |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
In this section, we report first results on our memory-based tagging approach. In a first  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
set of experiments, we compared our IGTree implementation of memory-based learning  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
to more traditional implementations of the approach. In further experiments we studied  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the performance of our system on predicting the category of both known and unknown  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
words. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Experimental Set-up |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
The experimental methodology was taken from Machine Learning practice (e.g. Weiss  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
&amp; Kulikowski, 1991): independent training and test sets were selected from the origi- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
nal corpus, the system was trained on the training set, and the generalization accuracy  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(percentage of correct category assignments) was computed on the independent test set.  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Storage and time requirements were computed as well. Where possible, we used a 10-fold  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
cross-validation approach. In this experimental method, a data set is partitioned ten  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
times into 90% training material, and 10% testing material. Average accuracy provides a  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
reliable estimate of the generalization accuracy. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
5.1 Experiment 1: Comparison of Algorithms |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Our goal is to adhere to the concept of memory-based learning with full memory while  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
at the same time keeping memory and processing speed within attractive bounds. To  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
this end, we applied the IGTree formalism to the task. In order to prove that IGTree is a  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
suitable candidate for practical memory-based tagging, we compared three memory-based  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
learning algorithms: (i) IB1, a slight extension (to cope with symbolic values and ambigu- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ous training items) of the well-known k-nn algorithm in statistical pattern recognition (see  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Aha et al., 1991), (ii) IB1-IG, an extension of IB1 which uses feature relevance weighting  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(described in Section 2), and (iii) IGTree, a memory- and processing time saving heuris- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tic implementation of IB1-IG (see Section 3). Table 3 lists the results in generalization  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
accuracy, storage requirements and speed for the three algorithms using a ddf at pattern,  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a 100,000 word training set, and a 10,000 word test set. In this experiment, accuracy was  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tested on known words only. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Table 3: Comparison of three memory-based learning techniques. |XML| xmlLoc_5 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Algorithm	Accuracy	Time	Memory (Kb) |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
IB1	92.5	0:43:34	977 |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
IB1-IG	96.0	0:49:45	977 |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
IGTree	96.0	0:00:29	35 |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
The IGTree version turns out to be better or equally good in terms of generalization  |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
accuracy, but also is more than 100 times faster for tagging of new words4, and compresses |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
4In training, i.e. building the case base, TM. and IB1-IG (4 seconds) are faster than IGTree (26 seconds)  |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
because the latter has to build a tree instead of just storing the patterns. |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
22 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
the original case base to 4% of the size of the original case base. This experiment shows  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
that for this problem, we can use IGTree as a time and memory saving approximation  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
of memory-based learning (IB-IG version), without loss in generalization accuracy. The  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
time and speed advantage of IGTree grows with larger training sets. |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
5.2 Experiment 2: Learning Curve |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
A ten-fold cross-validation experiment on the first two million words of the WSJ corpus  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
shows an average generalization performance of IGTree (on known words only) of 96.3%.  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
We did 10-fold cross-validation experiments for several sizes of datasets (in steps of 100,000  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
memory items), revealing the learning curve in Figure 4. Training set size is on the X-axis,  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
generalization performance as measured in a 10-fold cross-validation experiment is on the  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Y-axis. the &apos;error&apos; range indicate averages plus and minus one standard deviation on each  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
10-fold cross-validation experiment.&apos; |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Part of Speech Tagging Learning Curve |XML| xmlLoc_2 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
	96.4	 |XML| xmlLoc_3 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
	96.2	 |XML| xmlLoc_3 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
	96 95.8 95.6 95.4 95.2	 |XML| xmlLoc_3 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
	95 94.8 94.6	 |XML| xmlLoc_3 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
		500	1000	1500	2000 |XML| xmlLoc_3 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
		Training size (x1000) |XML| xmlLoc_3 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
Figure 4: Learning curve for tagging. |XML| xmlLoc_4 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Already at small data set sizes, performance is relatively high. With increasingly  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
larger data sets, the performance becomes more stable (witness the error ranges). It  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
should be noted that in this experiment, we assumed correctly disambiguated tags in the  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
left context. In practice, when using our tagger, this is of course not the case because the  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
disambiguated tags in the left context of the current word to be tagged are the result of  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
a previous decision of the tagger, which may be a mistake. To test the influence of this  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
effect we performed a third experiment. |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
5.3 Experiment 3: Overall Accuracy |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
We performed the complete tagger generation process on a 2 million words training set  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(lexicon construction and known and unknown words case-base construction), and tested  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
on 200,000 test words. Performance on known words, unknown words, and total are given  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
in Table 4. In this experiment, numbers were not stored in the known words case base;  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
they are looked up in the unknown words case base. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
&apos;We are not convinced that variation in the results of the experiments in a 10-fold-cv set-up is statistically  |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
meaningful (the 10 experiments are not independent), but follow common practice here. |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
23 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Table 4: Accuracy of IGTree tagging on known and unknown words |XML| xmlLoc_0 xmlAlign_right xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
	Accuracy	Percentage |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
Known	96.7	94.5 |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
Unknown	90.6	5.5 |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
Total	96.4	100.0 |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
6 Related Research |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-1 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
A case-based approach, similar to our memory-based approach, was also proposed by  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Cardie (1993a, 1994) for sentence analysis in limited domains (not only POS tagging but  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
also semantic tagging and structural disambiguation). We will discuss only the reported  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
POS tagging results here. Using a fairly complex case representation based on output from  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the CIRCUS conceptual sentence analyzer (22 local context features describing syntactic  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and semantic information about a five-word window centered on the word to be tagged,  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
including the words themselves, and 11 global context features providing information  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
about the major constituents parsed already), and with a tag set of 18 tags (7 open-class,  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
11 closed class), she reports a 95% tagging accuracy. A decision-tree learning approach  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
to feature selection is used in this experiment (Cardie, 1993b, 1994) to discard irrelevant  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
features. Results are based on experiments with 120 randomly chosen sentences from  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the TIPSTER JV corpus (representing 2056 cases). Cardie (p.c.) reports 89.1% correct  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tagging for unknown words. Percentage unknown words was 20.6% of the test words,  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and overall tagging accuracy (known and unknown) 95%. Notice that her algorithm  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
gives no initial preference to training cases that match the test word during its initial  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
case retrieval. On the other hand, after retrieving the top k cases, the algorithm does  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
prefer those cases that match the test word when making its final predictions. So, it&apos;s  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
understandable that the algorithm is doing better on words that it&apos;s seen during training  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
as opposed to unknown words. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In our memory-based approach, feature weighting (rather than feature selection) for  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
determining the relevance of features is integrated more smoothly with the similarity  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
metric, and our results are based on experiments with a larger corpus (3 million cases).  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Our case representation is (at this point) simpler: only the (ambiguous) tags, not the  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
words themselves or any other information are used. The most important improvement is  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the use of IGTree to index and search the case base, solving the computational complexity  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
problems a case-based approach would run into when using large case bases. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
An approach based on k-nn methods (such as memory-based and case-based methods)  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
is a statistical approach, but it uses a different kind of statistics than Markov model-based  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
approaches. K-nn is a non-parametric technique; it assumes no fixed type of distribution  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
of the data. The most important advantages compared to current stochastic approaches  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
are that (i) few training items (a small tagged corpus) are needed for relatively good  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
performance, (ii) the approach is incremental: adding new cases does not require any  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
recomputation of probabilities, and (iii) it provides explanation capabilities, and (iv) it  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
requires no additional smoothing techniques to avoid zero-probabilities; the IGTree takes  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
care of that. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Compared to hand-crafted rule-based approaches, our approach provides a solution  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
to the knowledge-acquisition and reusability bottlenecks, and to robustness and cover- |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
age problems (similar advantages motivated Markov model-based statistical approaches).  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Compared to learning rule-based approaches such as the one by Brill (1992), a k-nn ap- |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
proach provides a uniform approach for all disambiguation tasks, more flexibility in the  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
engineering of case representations, and a more elegant approach to handling of unknown  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
words (see e.g. Cardie 1994). |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
24 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
7 Conclusion |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
We have shown that a memory-based approach to large-scale tagging is feasible both  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
in terms of accuracy (comparable to other statistical approaches), and also in terms of  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
computational efficiency (time and space requirements) when using IGTree to compress  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and index the case base. The approach combines some of the best features of learned  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
rule-based and statistical systems (small training corpora needed, incremental learning,  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
understandable and explainable behavior of the system). More specifically, memory-based  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tagging with IGTrees has the following advantages. |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
•	Accurate generalization from small tagged corpora. Already at small corpus size  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
(300-400 K tagged words), performance is good. These corpus sizes can be easily  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
handled by our system. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
•	Incremental learning. New &apos;cases&apos; (e.g. interactively corrected output of the tagger)  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
can be incrementally added to the case bases, continually improving the performance  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
of the overall system. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
•	Explanation capabilities. To explain the classification behavior of the system, a path  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
in the IGTree (with associated defaults) can be provided as an explanation, as well  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
as nearest neighbors from which the decision was extrapolated. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
•	Flexible integration of information sources. The feature weighting method takes  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
care of the optimal fusing of different sources of information (e.g. word form and  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
context), automatically. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
•	Automatic selection of optimal context. The IGTree mechanism (when applied to  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
the known words case base) automatically decides on the optimal context size for  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
disambiguation of focus words. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
•	Non-parametric estimation. The IGTree formalism provides automatic, nonparametric  |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
estimation of classifications for low-frequency contexts (it is similar in this respect  |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
to backed-off training), but avoids non-optimal estimation due to false intuitions or  |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
non-convergence of the gradient-descent procedure used in some versions of backed-  |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
off training. |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
•	Reasonably good results on unknown words without morphological analysis. On  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
the WSJ corpus, unknown words can be predicted (using context and word form  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
information) for more than 90%. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
•	Fast learning and tagging. Due to the favorable complexity properties of IGTrees  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
(lookup time in IGTrees is independent on number of cases), both tagger generation  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
and tagging are extremely fast. Tagging speed in our current implementation is  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
about 1000 words per second. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
We have barely begun to optimise the approach: a more intelligent similarity metric  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
would also take into account the differences in similarity between different values of the  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
same feature. E.g. the similarity between the tags rb-in-nn and rb-in should be bigger than  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
the similarity between rb-in and vb-nn. Apart from linguistic engineering refinements of  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
the similarity metric, we are currently experimenting with statistical measures to compute  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
such more fine-grained similarities (e.g. Stanfill &amp; Waltz, 1986, Cost &amp; Salzberg, 1994). |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Acknowledgements |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Research of the first author was done while he was a visiting scholar at NIAS (Netherlands  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Institute for Advanced Studies) in Wassenaar. Thanks to Antal van den Bosch, Ton  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Weijters, and Gert Durieux for discussions about tagging, IGTree, and machine learning  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
of natural language. |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
25 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
References |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Aha, D. W., Kibler, D., &amp; Albert, M. (1991). &apos;Instance-based learning algorithms&apos;.  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Machine Learning, 7, 37-66. |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Brill, E. (1992) &apos;A simple rule-based part-of-speech tagger&apos;. Proceedings Third ACL  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Applied, Trento, Italy, 152-155. |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Cardie, C. (1993a). &apos;A case-based approach to knowledge acquisition for domain-specific  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
sentence analysis&apos;. In AAAI-93, 798-803. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Cardie, C. (1993b). &apos;Using Decision Trees to Improve Case-Based Learning&apos;. In Pro- |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ceedings of the Tenth International Conference on Machine Learning, 25-32. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Cardie, C. (1994). &apos;Domain-Specific Knowledge Acquisition for Conceptual Sentence  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Analysis&apos;. Ph.D. Thesis, University of Massachusetts, Amherst, MA. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Chandler, S. (1992). &apos;Are rules and modules really necessary for explaining language?&apos;  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Journal of Psycholinguistic research, 22(6): 593-606. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Church, K. (1988). &apos;A stochastic parts program and noun phrase parser for unrestricted  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
text&apos;. Proceedings Second ACL Applied NLP, Austin, Texas, 136-143. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Cost, S. and Salzberg, S. (1993). &apos;A weighted nearest neighbour algorithm for learning  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
with symbolic features.&apos; Machine Learning, 10, 57-78. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Cutting, D., Kupiec, J., Pederson, J., Sibun, P. (1992). A practical part of speech tagger.  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Proceedings Third ACL Applied NLP, Trento, Italy, 133-140. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Daelemans, W. (1995). &apos;Memory-based lexical acquisition and processing.&apos; In Steffens,  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
P., editor, Machine Translation and the Lexicon, Lecture Notes in Artificial Intelli- |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
gence 898. Berlin: Springer, 85-98. |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Daelemans, W., Van den Bosch, A. (1992). &apos;Generalisation performance of backprop- |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
agation learning on a syllabification task.&apos; In M. Drossaers &amp; A. Nijholt (Eds.),  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
TWLT3: Connectionism and Natural Language Processing. Enschede: Twente Uni- |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
versity, 27-38. |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Daelemans, W., Van den Bosch, A., Weijters, T. (1996). &apos;IGTree: Using Trees for  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Compression and Classification in Lazy Learning Algorithms.&apos; In Aha, D. (ed.). Al  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Review Special Issue on Lazy Learning, forthcoming. |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
DeRose, S. (1988). &apos;Grammatical category disambiguation by statistical optimization.  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Computational Linguistics 14, 31-39. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Derwing, B. L. and Skousen, R. (1989). &apos;Real Time Morphology: Symbolic Rules or  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Analogical Networks&apos;. Berkeley Linguistic Society 15: 48-62. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Federici S. and V. Pirelli. (1996). &apos;Analogy, Computation and Linguistic Theory.&apos; In  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Jones, D. (ed.) New Methods in Language Processing. London: UCL Press, forth- |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
coming. |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Garside, R., Leech, G. and Sampson, G. (1987). The computational analysis of English:  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
A corpus-based approach, London: Longman, 1987. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Greene, B.B. and Rubin, G.M. (1971). Automatic Grammatical Tagging of English.  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Providence RI: Department of Linguistics, Brown University. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Hindle, Donald. (1989). &apos;Acquiring disambiguation rules from text.&apos; In Proceedings,  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
27th Annual Meeting of the Association for Computational Linguistics, Vancouver,  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
BC. |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Hunt, E., J. Mann, P. Stone. (1966). Experiments in Induction. New York: Academic  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Press. |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Jones, D. Analogical Natural Language Processing. London: UCL Press, 1996. |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
26 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Klein S. and Simmons, R. (1963). &apos;A grammatical approach to grammatical coding of  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
English words.&apos; JACM 10, 334-347. |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Kolodner, J. (1993). Case-Based Reasoning. San Mateo: Morgan Kaufmann. |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Langley, P. and Sage, S. (1994). &apos;Oblivious decision trees and abstract cases.&apos; In  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
D. W. Aha (Ed.), Case-Based Reasoning: Papers from the 1994 Workshop (Techni- |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
cal Report WS-94-01). Menlo Park, CA: AAAI Press. |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Merialdo, B. ( 1994). &apos;Tagging English Text with a Probabilistic Model.&apos; Computational  |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Linguistics 20 (2), 155-172. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Pereira, F., Y. Singer, N. Tishby. (1995). &apos;Beyond Word N-grams.&apos; Proceedings Third |XML| xmlLoc_1 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Workshop on Very Large Corpora, MIT, Cambridge Mass., 95-106. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Quinlan, J. (1993). C4.5: Programs for Machine Learning. San Mateo, CA: Morgan  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Kaufmann. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Salzberg, S. (1990) &apos;A nearest hyperrectangle learning method&apos;. Machine Learning 6,  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
251-276. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Samuelsson, C. (1994) &apos;Morphological Tagging Based Entirely on Bayesian Inference.&apos; In  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Proceedings of the 9th Nordic Conference on Computational Linguistics, Stockholm  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
University, Sweden, 1994. |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Scha, R. (1992) &apos;Virtuele Grammatica&apos;s en Creatieve Algoritmen.&apos; Gramma/TTT 1 (1),  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
57-77. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Schmid, H. (1994) &apos;Part-of-speech tagging with neural networks.&apos; In Proceedings of  |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
COLING, Kyoto, Japan. |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Schiitze, H., and Y. Singer. (1994) &apos;Part-of-speech Tagging Using a Variable Context  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Markov Model&apos; Proceedings of ACL 1994, Las Cruces, New Mexico. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Skousen, R. (1989). Analogical Modeling of Language. Dordrecht: Kluwer. |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Sejnowski, T. J., Rosenberg, C. S. (1987). Parallel networks that learn to pronounce  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
English text. Complex Systems, 1, 145-168. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Stanfill, C. and Waltz, D. (1986). &apos;Toward memory-based reasoning.&apos; Communications  |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
of the ACM, 29, 1212-1228. |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Weiss, S. and Kulikowski, C. (1991). Computer systems that learn. San-Mateo: Morgan  |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Kaufmann. |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
27 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
