title ||| A Geometric Constraint Library for
title ||| 3D Graphical Applications
author ||| Hiroshi Hosobe
affiliation ||| National Institute of Informatics
address ||| 2-1-2 Hitotsubashi, Chiyoda-ku, Tokyo 101-8430, Japan
email ||| hosobe@nii.ac.jp
sectionHeader ||| ABSTRACT
bodyText ||| Recent computer technologies have enabled fast high-quality
bodyText ||| 3D graphics on personal computers, and also have made
bodyText ||| the development of 3D graphical applications easier. How-
bodyText ||| ever, most of such technologies do not sufficiently support
bodyText ||| layout and behavior aspects of 3D graphics. Geometric con-
bodyText ||| straints are, in general, a powerful tool for specifying layouts
bodyText ||| and behaviors of graphical objects, and have been applied
bodyText ||| to 2D graphical user interfaces and specialized 3D graph-
bodyText ||| ics packages. In this paper, we present Chorus3D, a geo-
bodyText ||| metric constraint library for 3D graphical applications. It
bodyText ||| enables programmers to use geometric constraints for vari-
bodyText ||| ous purposes such as geometric layout, constrained dragging,
bodyText ||| and inverse kinematics. Its novel feature is to handle scene
bodyText ||| graphs by processing coordinate transformations in geomet-
bodyText ||| ric constraint satisfaction. We demonstrate the usefulness of
bodyText ||| Chorus3D by presenting sample constraint-based 3D graph-
bodyText ||| ical applications.
sectionHeader ||| Keywords
keyword ||| geometric constraints, constraint satisfaction, geometric lay-
keyword ||| out, 3D graphics, scene graphs
sectionHeader ||| 1. INTRODUCTION
bodyText ||| Recent advances in commodity hardware have enabled fast
bodyText ||| high-quality 3D graphics on personal computers. Also, soft-
bodyText ||| ware technologies such as VRML and Java 3D have made the
bodyText ||| development of 3D graphical applications easier. However,
bodyText ||| most of such technologies mainly focus on rendering aspects
bodyText ||| of 3D graphics, and do not sufficiently support layout and
bodyText ||| behavior aspects.
bodyText ||| Constraints are, in general, a powerful tool for specifying
bodyText ||| layouts and behaviors of graphical objects. It is widely
bodyText ||| recognized that constraints facilitate describing geometric
bodyText ||| layouts and behaviors of diagrams in 2D graphical user in-
bodyText ||| terfaces such as drawing editors, and therefore constraint
bodyText ||| solvers for this purpose have been extensively studied [3, 7,
copyright ||| Permission to make digital or hard copies of all or part of this work for
copyright ||| personal or classroom use is granted without fee provided that copies are
copyright ||| not made or distributed for profit or commercial advantage and that copies
copyright ||| bear this notice and the full citation on the first page. To copy otherwise, to
copyright ||| republish, to post on servers or to distribute to lists, requires prior specific
copyright ||| permission and/or fee.
note ||| Int. Symp. on Smart Graphics, June 11-13, 2002, Hawthorne, NY, USA.
note ||| Copyright 2002 ACM 1-58113-555-6/02/0600...$5.00
bodyText ||| 8, 9, 11, 12, 13, 17, 18]. Also, many specialized 3D graph-
bodyText ||| ics packages enable the specification of object layouts and
bodyText ||| behaviors by using constraints or similar functions.
bodyText ||| It is natural to consider that various 3D graphical applica-
bodyText ||| tions can also be enhanced by incorporating constraints. It
bodyText ||| might seem sufficient for this purpose to modify existing 2D
bodyText ||| geometric constraint solvers to support 3D geometry. It is,
bodyText ||| however, insufficient in reality because of the essential dif-
bodyText ||| ference between the ways of specifying 2D and 3D graphics;
bodyText ||| typical 2D graphics handles only simple coordinate systems,
bodyText ||| whereas most 3D graphics requires multiple coordinate sys-
bodyText ||| tems with complex relations such as rotations to treat scene
bodyText ||| graphs. It means that we need to additionally support coor-
bodyText ||| dinate transformations in 3D geometric constraint solvers.
bodyText ||| In this paper, we present Chorus3D, a geometric constraint
bodyText ||| library for 3D graphical applications. The novel feature of
bodyText ||| Chorus3D is to handle scene graphs by processing coordi-
bodyText ||| nate transformations in geometric constraint satisfaction.
bodyText ||| We have realized Chorus3D by adding this feature to our
bodyText ||| previous 2D geometric constraint library Chorus [13].
bodyText ||| Another important point of Chorus3D is that it inherits from
bodyText ||| Chorus the capability to handle “soft” constraints with hier-
bodyText ||| archical strengths or preferences (i.e., constraint hierarchies
bodyText ||| [7]), which are useful for specifying default layouts and be-
bodyText ||| haviors of graphical objects. It determines solutions so that
bodyText ||| they satisfy as many strong constraints as possible, leaving
bodyText ||| weaker inconsistent constraints unsatisfied.
bodyText ||| Chorus3D also inherits from Chorus a module mechanism
bodyText ||| which allows user-defined kinds of geometric constraints.
bodyText ||| This feature enables programmers to use geometric con-
bodyText ||| straints for various purposes including the following:
listItem ||| Geometric layout: A typical use of Chorus3D is to lay
listItem ||| out graphical objects. For example, it allows putting
listItem ||| objects parallel or perpendicular to others without re-
listItem ||| quiring predetermined positioning parameters. Also, it
listItem ||| provides constraint-based general graph layout based
listItem ||| on the spring model [14].
listItem ||| Constrained dragging: Chorus3D enables dragging ob-
listItem ||| jects with positioning constraints. For example, it
listItem ||| can constrain a dragged object to be on the surface
listItem ||| of a sphere. Constrained dragging is important for 3D
listItem ||| graphics because it provides a sophisticated way to ac-
page ||| 94
listItem ||| Translation: A translation transformation is characterized
listItem ||| with three variables tx, tr, and tz, and specifies the
listItem ||| translation of vector (tx,tr, tz).
listItem ||| Rotation: A rotation transformation is parameterized with
listItem ||| four variables rx, rr, rz, and rw, and specifies the ro-
listItem ||| tation of angle rw about the axis (rx, rr, rz).
listItem ||| Scale: A scale transformation is represented with three
listItem ||| variables sx, sr, and sz, and specifies the axis-wise
listItem ||| scale (sx, sr, sz) about the origin.
bodyText ||| We can express many practically useful transformations by
bodyText ||| using such elemental ones. In fact, any transformations rep-
bodyText ||| resented with Transform nodes in VRML can be realized by
bodyText ||| combining these kinds of transformations [4].
sectionHeader ||| 3. CONSTRAINT FRAMEWORK
bodyText ||| In this section, we briefly describe our framework for han-
bodyText ||| dling constraints. We base it on the framework for the 2D
bodyText ||| version of the Chorus constraint solver. See [13] for further
bodyText ||| detail.
subsectionHeader ||| 3.1 Problem Formulation
bodyText ||| We first present the mathematical formulation for modeling
bodyText ||| constraints and constraint systems. In the following, we
bodyText ||| write x to represent a variable vector (x1, x2, ... , xn) of
bodyText ||| n variables, and also v to indicate a variable value vector
bodyText ||| (v1, v2, ... , vn) of n real numbers (vi expresses the value of
bodyText ||| xi).
bodyText ||| To support various geometric constraints in a uniform man-
bodyText ||| ner, we adopt error functions as a means of expressing con-
bodyText ||| straints. An error function e(x) is typically associated with
bodyText ||| a single arithmetic constraint, and is defined as a func-
bodyText ||| tion from variable value vectors to errors expressed as non-
bodyText ||| negative real numbers; that is, e(v) gives the error of the
bodyText ||| associated constraint for v. An error function returns a zero
bodyText ||| if and only if the constraint is exactly satisfied. For example,
bodyText ||| e(x) = (xi — xj)2 can be used for the constraint xi = xj.
bodyText ||| We assume that, for each e(x), its gradient is known:
equation ||| De(x) =	�ae(x) ae(x) ae(x) ax1,ax2 ,...,axn )
bodyText ||| In the same way as constraint hierarchies [7], constraint sys-
bodyText ||| tems in our framework can be divided into levels consisting
bodyText ||| of constraints with equal strengths. Constraints with the
bodyText ||| strongest preference are said to be required (or hard), and
bodyText ||| are guaranteed to be always satisfied (if it is impossible,
bodyText ||| there will be no solution). By contrast, constraints with
bodyText ||| weaker preferences are said to be preferential (or soft), and
bodyText ||| may be relaxed if they conflict with stronger constraints.
bodyText ||| Solutions to constraint systems are defined as follows: let
bodyText ||| ei,j(x) be the error function of the j-th constraint (1 < j <
bodyText ||| mi) at strength level i (0 < i < l); then solutions v are
bodyText ||| determined with the optimization problem
bodyText ||| minimize	E(v) subject to e0,j (v) = 0 (1 < j < m0)
none ||| v
bodyText ||| commodate ordinary mouse dragging to 3D spaces.
bodyText ||| Inverse kinematics: Chorus3D is applicable to inverse
bodyText ||| kinematics, which is a problem of finding desired con-
bodyText ||| figurations of “articulated” objects [1, 20]. It allows
bodyText ||| the specification of articulated objects by using coor-
bodyText ||| dinate transformations, and can automatically calcu-
bodyText ||| late the parameters of the transformations that satisfy
bodyText ||| constraints. This method is also applicable to camera
bodyText ||| control by aiming at a possibly moving target object.
bodyText ||| In this paper, we demonstrate the usefulness of Chorus3D
bodyText ||| by presenting sample constraint-based 3D graphical appli-
bodyText ||| cations.
bodyText ||| This paper is organized as follows: We first present our ap-
bodyText ||| proach to the use of constraints for 3D graphics. Second,
bodyText ||| we describe our basic framework of constraints. Next, we
bodyText ||| present a method for processing coordinate transformations
bodyText ||| in our framework. We then provide the implementation of
bodyText ||| Chorus3D, and demonstrate examples of using constraints
bodyText ||| in 3D graphics. After giving related work and discussion, we
bodyText ||| mention the conclusions and future work of this research.
sectionHeader ||| 2. OUR APPROACH
bodyText ||| In this research, we integrate geometric constraints with 3D
bodyText ||| graphics. Basically, we realize this by extending our previ-
bodyText ||| ous 2D geometric constraint solver Chorus [13] to support
bodyText ||| 3D geometry. However, as already mentioned, it is not a
bodyText ||| straightforward task because 3D graphics typically requires
bodyText ||| handling scene graphs with hierarchical structures of coor-
bodyText ||| dinate systems, which is not covered by the 2D version of
bodyText ||| the Chorus constraint solver.
bodyText ||| To support hierarchies of coordinate systems, we introduce
bodyText ||| the following new model of constraints:
listItem ||| Point variables: Each point variable (which consists of
listItem ||| three real-valued constrainable variables) is associated
listItem ||| with one coordinate system, and its value is expressed
listItem ||| as local coordinates.
listItem ||| Geometric constraints: Geometric constraints on point
listItem ||| variables are evaluated by using the world coordinates
listItem ||| of the point variables (they can also refer to 1D vari-
listItem ||| ables for, e.g., distances and angles by using their val-
listItem ||| ues directly). A single constraint can refer to point
listItem ||| variables belonging to different coordinate systems.
listItem ||| Coordinate transformations: Parameters of coordinate
listItem ||| transformations are provided as constrainable vari-
listItem ||| ables, and the solver is allowed to change the param-
listItem ||| eters of transformations to appropriately satisfy given
listItem ||| constraints.
bodyText ||| With this model, we can gain the benefit of the easy mainte-
bodyText ||| nance of geometric relations by using constraints, as well as
bodyText ||| the convenience of modeling geometric objects by employing
bodyText ||| scene graphs.
bodyText ||| In our actual implementation, we provide the following three
bodyText ||| elemental kinds of coordinate transformations:
page ||| 95
bodyText ||| where E is an objective function defined as
equation ||| wiei,j (x)
bodyText ||| in which wi indicates the weight associated with strength i,
bodyText ||| and the relation w1 » w2 » . . . » wl holds. In this formu-
bodyText ||| lation, level 0 corresponds to required constraints, and the
bodyText ||| others to preferential ones. Intuitively, more weighted (or
bodyText ||| stronger) preferential constraints should be more satisfied.
bodyText ||| Our framework simulates constraint hierarchies. Particu-
bodyText ||| larly, if the squares of constraint violations are used to com-
bodyText ||| pute error functions, a system in our framework will obtain
bodyText ||| approximate solutions to the similar hierarchy solved with
bodyText ||| the criterion least-squares-better [3, 17]. The largest differ-
bodyText ||| ence is that a system in our framework slightly considers a
bodyText ||| weak constraint inconsistent with a stronger satisfiable one
bodyText ||| in computing its solutions, while the similar hierarchy would
bodyText ||| discard such a weak one.
bodyText ||| Our actual implementation of the Chorus3D constraint
bodyText ||| solver provides four external strengths required, strong,
bodyText ||| medium, and weak as well as two internal strengths very
bodyText ||| strong (used to approximately handle required nonlinear
bodyText ||| or inequality constraints) and very weak (exploited to make
bodyText ||| new solutions as close to previous ones as possible). It typ-
bodyText ||| ically assigns weights 324, 323, 322, 321, and 1 to strengths
bodyText ||| very strong, strong, medium, weak, and very weak respec-
bodyText ||| tively. These weights were determined according to the pre-
bodyText ||| cision of the actual numerical algorithm (described in the
bodyText ||| next subsection). To know how much these weights affect
bodyText ||| solutions, suppose a system of strong constraint x = 0 and
bodyText ||| medium one x = 100. Then the unique solution will be ob-
bodyText ||| tained as x = 3.0303 . . . (= 100/33). Thus the difference of
bodyText ||| strengths is obvious. According to our actual experience,
bodyText ||| this precision allows us to discriminate constraint strengths
bodyText ||| in most graphical applications.
subsectionHeader ||| 3.2 Algorithm
bodyText ||| To actually find solutions to constraint systems presented
bodyText ||| above, we need to solve their corresponding optimization
bodyText ||| problems. For this purpose, we designed a constraint sat-
bodyText ||| isfaction algorithm by combining a numerical optimization
bodyText ||| technique with a genetic algorithm. It uses numerical op-
bodyText ||| timization to find local solutions, while it adopts a genetic
bodyText ||| algorithm to search for global solutions.
bodyText ||| For numerical optimization, we mainly use the quasi-Newton
bodyText ||| method based on Broyden-Fletcher-Goldfarb-Sahnno updat-
bodyText ||| ing formula [2, 6], which is a fast iterative technique that
bodyText ||| exhibits superlinear convergence. Since it excludes fruit-
bodyText ||| less searches by utilizing its history, it is usually faster than
bodyText ||| straightforward Newton’s method.
bodyText ||| We introduced a genetic algorithm to alleviate the problem
bodyText ||| that some kinds of geometric constraints suffer from local op-
bodyText ||| timal but global non-optimal solutions [11, 16]. Generally,
bodyText ||| a genetic algorithm is a stochastic search method that re-
bodyText ||| peatedly transforms a population of potential solutions into
bodyText ||| another next-generation population [10, 15]. We typically
bodyText ||| necessitate it only for computing initial solutions; in other
bodyText ||| words, we can usually re-solve modified constraint systems
bodyText ||| without the genetic algorithm, only by applying numerical
bodyText ||| optimization to previous solutions.
sectionHeader ||| 4. PROCESSING COORDINATE
sectionHeader ||| TRANSFORMATIONS
bodyText ||| In this section, we propose a method for integrating coordi-
bodyText ||| nate transformations with our constraint framework.
bodyText ||| As already mentioned, we use world coordinates of points
bodyText ||| to evaluate 3D geometric constraints. A naive method for
bodyText ||| this is to duplicate point variables in all ancestor coordinate
bodyText ||| systems, and then to impose required constraints that rep-
bodyText ||| resent coordinate transformations between the point vari-
bodyText ||| ables. However, this method requires an optimization rou-
bodyText ||| tine supporting required nonlinear constraints, which lim-
bodyText ||| its the availability of actual techniques (in fact, we cannot
bodyText ||| use the quasi-Newton method for this purpose). Also, this
bodyText ||| method tends to yield many variables and constraints, and
bodyText ||| therefore requires an extra amount of memory.
bodyText ||| Below we propose a more widely applicable method for han-
bodyText ||| dling coordinate transformations. Its characteristic is to
bodyText ||| hide transformations from optimization routines, which is
bodyText ||| realized by embedding transformations in error functions.
subsectionHeader ||| 4.1 Model
bodyText ||| To begin with, we introduce another variable vector x' =
bodyText ||| (x'1, x'2, ... ,x' n), which is created by replacing variables for
bodyText ||| local coordinates of 3D points in x with the corresponding
bodyText ||| ones for world coordinates (1D variables remain the same).
bodyText ||| We can mathematically model this process as follows: Con-
bodyText ||| sider the sequence of the s transformations
equation ||| t0	t1	s 2	ts 1
equation ||| y0 (= x)� y1 �... t y3-1 —� y3 (= x')
bodyText ||| where y0 and y3 are equal to x and x' respectively, each
bodyText ||| yk (1 < k < s — 1) is an “intermediate” vector, and each tk
bodyText ||| (0 < k < s — 1) is a function that transforms yk into yk+1.
bodyText ||| Intuitively, tk corresponds to a coordinate transformation,
bodyText ||| and transforms related point variables from its source co-
bodyText ||| ordinate system into its destination system. It should be
bodyText ||| noted that, although transformations are, in general, hier-
bodyText ||| archical (or tree-structured), we can always find such a linear
bodyText ||| sequence by “serializing” them in an appropriate order.
bodyText ||| By using such transformations, we can compute x' as fol-
bodyText ||| lows:
equation ||| x' = t3-1(t3-2(...(t1(t0(x))) ... )) = t(x)
bodyText ||| where t is defined as the composition of all the elemental
bodyText ||| transformations. In the following description, we write yk,i
bodyText ||| to denote the i-th element of yk, and also tk,i to represent
bodyText ||| the i-th element of tk; that is,
equation ||| yk+1 = (yk+1,1 , yk+1,2, ... , yk+1,n)
equation ||| = (tk,1(yk),tk,2(yk), ..., tk,n(yk)) = tk(yk).
subsectionHeader ||| 4.2 Method
bodyText ||| Geometric constraints are evaluated by using world coordi-
bodyText ||| nates of points, which means that their error functions are
equation ||| Mi
equation ||| E
equation ||| j=1
equation ||| E(x) =
equation ||| �l
equation ||| i=1
page ||| 96
bodyText ||| defined as e(x'). Using the composed transformations, we	parameter of the coordinate transformation), we have
bodyText ||| can evaluate them as	yk,i = xi, which means that we have atk,j(yk)/axi.
bodyText ||| e(x') = e(t(x)).	Therefore, we can compute ae(x')/axi immediately.
bodyText ||| Importantly, we can efficiently realize this computation by
bodyText ||| applying only necessary transformations to actually used
bodyText ||| variables.
bodyText ||| We also need to compute the gradient of e(t(x)), i.e.,
equation ||| �ae(t(x)) ae(t(x)) ae(t(x))
equation ||| ax1 , ax2 , ..., axn ) .
bodyText ||| Basically, we can decompose each partial derivative
bodyText ||| ae(t(x))/axi into primitive expressions by repeatedly us-
bodyText ||| ing the chain rule. However, we should avoid the simple
bodyText ||| application of the chain rule since it would result in a large
bodyText ||| number of expressions.
bodyText ||| Instead, we perform a controlled way of decomposing such
bodyText ||| partial derivatives; it appropriately arranges the chain rule
bodyText ||| to restrict the computation to only necessary components.
bodyText ||| First, we decompose ae(t(x))/axi as follows:
equation ||| ats-1,j,(ys-1)
equation ||| axi
equation ||| ae(x')	ats-1,j,(ys-1)ats-2,js_1(ys-2)
equation ||| axj,Eays-1,js_1	axi
equation ||| js_1
equation ||| ats-2,js_1(ys-2)
equation ||| axi
equation ||| ae(x') ats-2,js_1(ys-2)
equation ||| ays-1,js_1	axi	.
bodyText ||| Note that each ae(x')/ax'j, is given by the defini-
bodyText ||| tion of the geometric constraint, and also that each
bodyText ||| ats-1,j,(ys-1)/ays-1,js_1 is a partial derivative in the gra-
bodyText ||| dient of a single coordinate transformation ts-1. Thus we
bodyText ||| can obtain each ae(x')/ays-1 ,js_1. Also, by repeating this
bodyText ||| process, we can compute, for each k,
equation ||| atk-1,jk (yk-1)
bodyText ||| and finally achieve
equation ||| ae(t(x))
equation ||| axi
equation ||| where each at0,j1(x)/axi is a component of the gradient of
bodyText ||| t0. Therefore, ae(t(x))/axi is now determined.
bodyText ||| Furthermore, we can considerably reduce the number of the
bodyText ||| computations of ae(x')/ayk,jk in practice. We can make the
bodyText ||| following observations about the above computation:
bodyText ||| 9 For each variable xj,, ae(x')/ax'j, can be non-zero only
bodyText ||| if xj,is actually needed to evaluate the designated con-
bodyText ||| straint.
bodyText ||| 9 If xi is originated in the coordinate system associated
bodyText ||| with tk (that is, xi is either a local coordinate or a
bodyText ||| These observations reveal that we need to transfer a partial
bodyText ||| derivative ae(x')/ayk,j to the next step only when xj rep-
bodyText ||| resents a really necessary coordinate that has not reached
bodyText ||| its local coordinate system. Also, since we can handle each
bodyText ||| necessary point independently, we can implement this pro-
bodyText ||| cess with a linear recursive function that hands over only
bodyText ||| three derivatives ae(x')/ayk,j at each recursive call.
sectionHeader ||| 5. IMPLEMENTATION
bodyText ||| We implemented the proposed method by developing a con-
bodyText ||| straint solver called Chorus3D, which is a 3D extension to
bodyText ||| our previous 2D geometric constraint solver Chorus [13]. We
bodyText ||| constructed Chorus3D as a C++ class library, and also de-
bodyText ||| veloped a native method interface to make it available to
bodyText ||| Java programs.
bodyText ||| Chorus3D allows programmers to add a new kind of arith-
bodyText ||| metic constraints (e.g., Euclidean geometric constraints) by
bodyText ||| constructing a new constraint class with a method that eval-
bodyText ||| uates their error functions. Also, programmers can intro-
bodyText ||| duce a new kind of non-arithmetic (or pseudo) constraints
bodyText ||| (for, e.g., general graph layout) by developing a new evalua-
bodyText ||| tion module which computes an “aggregate” error function
bodyText ||| for a given set of constraints.
bodyText ||| Chorus3D currently provides linear equality, linear inequal-
bodyText ||| ity, edit (update a variable value), stay (fix a variable value),
bodyText ||| Euclidean geometric constraints (for, e.g., parallelism, per-
bodyText ||| pendicularity, and distance equality), and graph layout con-
bodyText ||| straints based on the spring model [14]. Linear equality/
bodyText ||| inequality constraints can refer to only 1D variables (includ-
bodyText ||| ing elements of 3D point variables), while edit and stay con-
bodyText ||| straints can be associated with 1D and 3D point variables.
bodyText ||| Euclidean geometric constraints typically refer to point vari-
bodyText ||| ables although they sometimes require 1D variables for an-
bodyText ||| gles and distances. Each graph layout constraint represents
bodyText ||| a graph edge, and refers to two point variables as its asso-
bodyText ||| ciated graph nodes. As stated earlier, constraints on such
bodyText ||| point variables are evaluated by using world coordinates of
bodyText ||| the points. Also, a single constraint can refer to point vari-
bodyText ||| ables belonging to different coordinate systems.
bodyText ||| The application programming interface of Chorus3D is a
bodyText ||| natural extension to that of Chorus, which provides a certain
bodyText ||| compatibility with a recent linear solver called Cassowary
bodyText ||| [3]; in a similar way to Cassowary and Chorus, Chorus3D
bodyText ||| allows programmers to process constraint systems by cre-
bodyText ||| ating variables and constraints as objects, and by adding/
bodyText ||| removing constraint objects to/from the solver object. In
bodyText ||| addition, Chorus3D handles coordinate transformations as
bodyText ||| objects, and presents an interface for arranging them hier-
bodyText ||| archically.
sectionHeader ||| 6. EXAMPLES
bodyText ||| In this section, we present three examples to demonstrate
bodyText ||| how to incorporate geometric constraints into 3D graphics
bodyText ||| by using the Chorus3D constraint solver. All the examples
bodyText ||| are implemented in Java by using Java 3D as a graphics
equation ||| De(t(x)) =
equation ||| ae(t(x))
equation ||| axi
equation ||| =E
equation ||| j,
equation ||| ae(x')
equation ||| ax'j,
equation ||| =E
equation ||| j,
equation ||| = E
equation ||| js_1
equation ||| = E
equation ||| js_1
equation ||| I
equation ||| ats1,j, (ys-1)
equation ||| ae(x')
equation ||| E
equation ||| ays-1,js_1
equation ||| j,
equation ||| ax'j,
equation ||| I
equation ||| ae(t(x))
equation ||| axi
equation ||| =E	ae(x')
equation ||| jk
equation ||| 	ayk,jk
equation ||| =E	ae(x')
equation ||| j1
equation ||| 	ay1,j1
equation ||| axi
equation ||| at0,j1(x)
equation ||| axi
page ||| 97
figureCaption ||| Figure 1: A 3D geometric layout of a general graph
figureCaption ||| structure.
figureCaption ||| Figure 2: Dragging an object constrained to be on
figureCaption ||| a sphere.
bodyText ||| programming interface as well as the native method interface
bodyText ||| with Chorus3D. We also provide computation times taken
bodyText ||| for constraint satisfaction in these examples.
subsectionHeader ||| 6.1 Graph Layout
bodyText ||| The first example is an application which lays out a set
bodyText ||| of points with a general graph structure in a 3D space as
bodyText ||| shown in Figure 1. This application also allows a user to
bodyText ||| drag graph nodes with a mouse.' The used graph layout
bodyText ||| technique is based on a 3D extension to the spring model
bodyText ||| [14]. This kind of 3D graph layout is practically useful to
bodyText ||| information visualization, and has actually been adopted in
bodyText ||| a certain system [19].
bodyText ||| The constraint system of this graph layout consists of 26
bodyText ||| point variables (i.e., 78 real-valued variables), 31 graph lay-
bodyText ||| out constraints, and three linear equality constraints for fix-
bodyText ||| ing one of the point variables at the origin. When executed
bodyText ||| on an 866 MHz Pentium III processor running Linux 2.2.16,
bodyText ||| Chorus3D obtained an initial solution in 456 milliseconds. It
bodyText ||| performed constraint satisfaction typically within 250 mil-
bodyText ||| liseconds to reflect the user’s dragging a graph node.
subsectionHeader ||| 6.2 Constrained Dragging
bodyText ||| The second example is an application which allows a user
bodyText ||| to drag an object constrained to be on another spherical
bodyText ||| object. Figure 2 depicts this application, where the smaller
bodyText ||| solid spherical object is constrained to be on the surface of
bodyText ||| the larger wireframe one. The application declares a strong
bodyText ||| Euclidean geometric constraint which specifies a constant
bodyText ||| distance between the centers of these objects. When the
bodyText ||| user tries to drag the smaller object with a mouse, the appli-
bodyText ||| cation imposes another medium Euclidean constraint which
bodyText ||| collinearly locates the viewpoint, the 3D position of the
bodyText ||| mouse cursor (which is considered to be on the screen), and
footnote ||| 'Unlike constrained dragging in the next example, this
footnote ||| mouse operation is simply implemented with Java 3D’s
footnote ||| PickMouseBehavior classes.
footnote ||| Sphere
figureCaption ||| Figure 3: Implementation of constrained dragging.
bodyText ||| the center of the dragged object as shown in Figure 3. This
bodyText ||| collinearity constraint reflects the motion of the mouse in
bodyText ||| the position of the dragged object. Since the collinearity
bodyText ||| constraint is weaker than the first Euclidean constraint, the
bodyText ||| user cannot drag the smaller object to the outside of the
bodyText ||| larger sphere.
bodyText ||| The application initially declares one Euclidean geometric
bodyText ||| constraint on two point variables, and solved it in 1 mil-
bodyText ||| lisecond on the same computer as the first example. When
bodyText ||| the user tries to drag the smaller object, it adds another
bodyText ||| Euclidean constraint as well as two edit constraints for the
bodyText ||| viewpoint and mouse position. The solver maintained this
bodyText ||| constraint system usually within 2 milliseconds.
subsectionHeader ||| 6.3 Inverse Kinematics
bodyText ||| The final example applies inverse kinematics to a virtual
bodyText ||| robot arm by using constraints. Unlike the previous ex-
bodyText ||| amples, it takes advantage of coordinate transformations to
bodyText ||| express its constraint system.
figure ||| Mouse cursor which
figure ||| is on the screen
figure ||| Viewpoint
figure ||| Distance
figure ||| constraint
figure ||| Collinearity
figure ||| constraint
figure ||| Object which is on
figure ||| the sphere surface
figure ||| Screen
page ||| 98
figure ||| (a)	(b)	(c)
figureCaption ||| Figure 4: A robot arm application which performs inverse kinematics.
figure ||| (d)	(e)	(f)
bodyText ||| As illustrated in Figure 4(a), the robot arm consists of four
bodyText ||| parts called a base, a shoulder, an upper arm, and a forearm.
bodyText ||| Constraint satisfaction for inverse kinematics is performed
bodyText ||| to position its hand (the end of the forearm) at the target
bodyText ||| object if possible, or otherwise to make it maximally close
bodyText ||| to the target. Figures 4(b)–(f) show the movement of the
bodyText ||| robot arm. In Figures 4(b)–(e), its hand is positioned at
bodyText ||| the exact location of the target by using appropriate angles
bodyText ||| of its joints. By contrast, in Figure 4(f), the hand cannot
bodyText ||| reach the target, and therefore the arm is extended toward
bodyText ||| the target instead.
bodyText ||| Figure 5 describes the constraint program used in the robot
bodyText ||| arm application. After constructing a constraint solver
bodyText ||| s, it creates six coordinate transformations shldrTTfm,
bodyText ||| shldrRTfm, uarmTTfm, uarmRTfm, farmTTfm, and farmRTfm.
bodyText ||| Here the rotation angle parameters of the rotation trans-
bodyText ||| formations shldrRTfm, uarmRTfm, and farmRTfm will actu-
bodyText ||| ally work as variables that can be altered by the solver.
bodyText ||| Next, it generates a point variable handPos to represent
bodyText ||| the position of the hand, and then suggests the target po-
bodyText ||| sition to the hand by using a preferential edit constraint
bodyText ||| editHandPos. Finally, executing the solver, it obtains the
bodyText ||| desired angles shldrAngle, uarmAngle, and farmAngle of
bodyText ||| the rotation transformations. These angles will be passed
bodyText ||| to the Java 3D library to render the properly configured
bodyText ||| robot arm.
bodyText ||| This program generates a constraint system which contains
bodyText ||| three translation and three rotation transformations, one ex-
bodyText ||| plicit point variable as well as six point variables and three
bodyText ||| 1D variables for coordinate transformations, and one edit
bodyText ||| constraint. The solver found an initial solution to this sys-
bodyText ||| tem in 18 milliseconds, and obtained each new solution for
bodyText ||| a frame update typically within 10 milliseconds.
sectionHeader ||| 7. RELATED WORK AND DISCUSSION
bodyText ||| There has been work on integrating constraints or similar
bodyText ||| functions with 3D graphics languages to facilitate the spec-
bodyText ||| ification of graphical objects. For example, we can view the
bodyText ||| event routing mechanism in VRML [4] as a limited form of
bodyText ||| one-way propagation constraints. Also, there is an attempt
bodyText ||| to extend VRML by introducing one-way propagation and
bodyText ||| finite-domain combinatorial constraints [5]. However, they
bodyText ||| cannot handle more powerful simultaneous nonlinear con-
bodyText ||| straints such as Euclidean geometric constraints.
bodyText ||| Although many constraint solvers have been developed in
page ||| 99
figure ||| // constraint solver
figure ||| s = new C3Solver();
figure ||| // translation transformation for the shoulder: fixed to (0, .1, 0)
figure ||| shldrTTfm = new C3TranslateTransform(new C3Domain3D(0, .1, 0));
figure ||| s.add(shldrTTfm); // shldrTTfm is parented by the world coordinate system
figure ||| // rotation transformation for the shoulder: axis fixed to (0, 1, 0); angle ranging over [-10000, 10000]
figure ||| shldrRTfm = new C3RotateTransform(new C3Domain3D(0, 1, 0), new C3Domain(-10000, 10000));
figure ||| s.add(shldrRTfm, shldrTTfm); // shldrRTfm is parented by shldrTTfm
figure ||| // translation transformation for the upper arm: fixed to (0, .1, 0)
figure ||| uarmTTfm = new C3TranslateTransform(new C3Domain3D(0, .1, 0));
figure ||| s.add(uarmTTfm, shldrRTfm); // uarmTTfm is parented by shldrRTfm
figure ||| // rotation transformation for the upper arm: axis fixed to (0, 0, 1); angle ranging over [-1.57,1.57]
figure ||| uarmRTfm = new C3RotateTransform(new C3Domain3D(0, 0, 1), new C3Domain(-1.57, 1.57));
figure ||| s.add(uarmRTfm, uarmTTfm); // uarmRTfm is parented by uarmTTfm
figure ||| // translation transformation for the forearm: fixed to (0, .5, 0)
figure ||| farmTTfm = new C3TranslateTransform(new C3Domain3D(0, .5, 0));
figure ||| s.add(farmTTfm, uarmRTfm); // farmTTfm is parented by uarmRTfm
figure ||| // rotation transformation for the forearm: axis fixed to (0, 0, 1); angle ranging over [-3.14, 0]
figure ||| farmRTfm = new C3RotateTransform(new C3Domain3D(0, 0, 1), new C3Domain(-3.14, 0));
figure ||| s.add(farmRTfm, farmTTfm); // farmRTfm is parented by farmTTfm
figure ||| // variable for the hand’s position, associated with farmRTfm and fixed to (0, .5, 0)
figure ||| handPos = new C3Variable3D(farmRTfm, new C3Domain3D(0, .5, 0));
figure ||| // medium-strength edit constraint for the hand’s position
figure ||| editHandPos = new C3EditConstraint(handPos, C3.MEDIUM);
figure ||| s.add(editHandPos);
figure ||| // suggest the hand being located at the target’s position
figure ||| editHandPos.set(getTargetWorldCoordinates() );
figure ||| // solve the constraint system
figure ||| s.solve();
figure ||| // get solutions
figure ||| double shldrAngle = shldrRTfm.rotationAngle().value() ;
figure ||| double uarmAngle = uarmRTfm.rotationAngle().value();
figure ||| double farmAngle = farmRTfm.rotationAngle().value();
figureCaption ||| Figure 5: Constraint program for the robot arm application.
bodyText ||| the field of graphical user interfaces [3, 7, 11, 12, 13, 17, 18],
bodyText ||| most of them do not provide special treatment for 3D graph-
bodyText ||| ics. In general, the role of nonlinear geometric constraints
bodyText ||| is more important in 3D applications than in 2D interfaces.
bodyText ||| Most importantly, 3D graphics usually requires rotations of
bodyText ||| objects which are rarely used in 2D interfaces. The main
bodyText ||| reason is that we often equally treat all “horizontal” direc-
bodyText ||| tions in a 3D space even if we may clearly distinguish them
bodyText ||| from “vertical” directions. Therefore, nonlinear constraint
bodyText ||| solvers are appropriate for 3D applications. In addition, co-
bodyText ||| ordinate transformations should be supported since they are
bodyText ||| typically used to handle rotations of objects.
bodyText ||| Gleicher proposed the differential approach [8, 9], which sup-
bodyText ||| ports 3D geometric constraints and coordinate transforma-
bodyText ||| tions. In a sense, it shares a motivation with Chorus3D; in
bodyText ||| addition to support for 3D graphics, it allows user-defined
bodyText ||| kinds of geometric constraints. However, it is based on a dif-
bodyText ||| ferent solution method from Chorus3D; it realizes constraint
bodyText ||| satisfaction by running virtual dynamic simulations. This
bodyText ||| difference results in a quite different behavior of solutions as
bodyText ||| well as an interface for controlling solutions. By contrast,
bodyText ||| Chorus3D provides a much more compatible interface with
bodyText ||| recent successful solvers such as Cassowary [3].
bodyText ||| Much research on inverse kinematics has been conducted in
bodyText ||| the fields of computer graphics and robotics [1, 20]. How-
bodyText ||| ever, inverse kinematics is typically implemented as special-
bodyText ||| ized software which only provides limited kinds of geometric
bodyText ||| constraints.
bodyText ||| Chorus3D has two limitations in its algorithm: one is on the
bodyText ||| precision of solutions determined by preferential constraints;
bodyText ||| the other is on the speed of the satisfaction of large con-
bodyText ||| straint systems. These limitations are mainly caused by the
bodyText ||| treatment of multi-level preferences of constraints in addi-
bodyText ||| tion to required constraints (i.e., constraint hierarchies). Al-
bodyText ||| though many numerical optimization techniques have been
bodyText ||| proposed and implemented in the field of mathematical pro-
bodyText ||| gramming [2, 6], most of them do not handle preferential
bodyText ||| constraints. To alleviate the limitations of Chorus3D, we
bodyText ||| are pursuing a more sophisticated method for processing
bodyText ||| multi-level preferential constraints.
bodyText ||| We implemented Chorus3D as a class library which can
bodyText ||| be exploited in C++ and Java programs. However, more
bodyText ||| high-level authoring tools will also be useful for declarative
bodyText ||| approaches to 3D design. One possible direction is to ex-
bodyText ||| tend VRML [4] to support geometric constraints. Standard
bodyText ||| VRML requires scripts in Java or JavaScript to realize com-
bodyText ||| plex layouts and behaviors. By contrast, constraint-enabled
bodyText ||| VRML will cover a wider range of applications without such
bodyText ||| additional scripts.
sectionHeader ||| 8. CONCLUSIONS AND FUTURE WORK
bodyText ||| In this paper, we presented Chorus3D, a geometric con-
bodyText ||| straint library for 3D graphical applications. It enables pro-
bodyText ||| grammers to use geometric constraints for various purposes
page ||| 100
bodyText ||| such as geometric layout, constrained dragging, and inverse
bodyText ||| kinematics. Its novel feature is to handle scene graphs
bodyText ||| by processing coordinate transformations in geometric con-
bodyText ||| straint satisfaction.
bodyText ||| Our future work includes the development of other kinds of
bodyText ||| geometric constraints to further prove the usefulness of our
bodyText ||| approach. In particular, we are planning to implement non-
bodyText ||| overlapping constraints [13] in Chorus3D so that we can use
bodyText ||| it for the collision resolution of graphical objects. Another
bodyText ||| future direction is to improve Chorus3D in the scalability
bodyText ||| and accuracy of constraint satisfaction.
sectionHeader ||| 9. REFERENCES
reference ||| [1] Badler, N. I., Phillips, C. B., and Webber, B. L.
reference ||| Simulating Humans: Computer Graphics, Animation,
reference ||| and Control. Oxford University Press, Oxford, 1993.
reference ||| [2] Bertsekas, D. P. Nonlinear Programming, 2nd ed.
reference ||| Athena Scientific, 1999.
reference ||| [3] Borning, A., Marriott, K., Stuckey, P., and Xiao, Y.
reference ||| Solving linear arithmetic constraints for user interface
reference ||| applications. In Proc. ACM UIST, 1997, 87–96.
reference ||| [4] Carey, R., Bell, G., and Marrin, C. The Virtual
reference ||| Reality Modeling Language (VRML97). ISO/IEC
reference ||| 14772-1:1997, The VRML Consortium Inc., 1997.
reference ||| [5] Diehl, S., and Keller, J. VRML with constraints. In
reference ||| Proc. Web3D-VRML, ACM, 2000, 81–86.
reference ||| [6] Fletcher, R. Practical Methods of Optimization,
reference ||| 2nd ed. John Wiley & Sons, 1987.
reference ||| [7] Freeman-Benson, B. N., Maloney, J., and Borning, A.
reference ||| An incremental constraint solver. Commun. ACM 33,
reference ||| 1 (1990), 54–63.
reference ||| [8] Gleicher, M. A graphical toolkit based on differential
reference ||| constraints. In Proc. ACM UIST, 1993, 109–120.
reference ||| [9] Gleicher, M. A differential approach to graphical
reference ||| manipulation (Ph.D. thesis). Tech. Rep.
reference ||| CMU-CS-94-217, Sch. Comput. Sci. Carnegie Mellon
reference ||| Univ., 1994.
reference ||| [10] Herrera, F., Lozano, M., and Verdegay, J. L. Tackling
reference ||| real-coded genetic algorithms: Operators and tools for
reference ||| behavioural analysis. Artif. Intell. Rev. 12, 4 (1998),
reference ||| 265–319.
reference ||| [11] Heydon, A., and Nelson, G. The Juno-2
reference ||| constraint-based drawing editor. Research Report
reference ||| 131a, Digital Systems Research Center, 1994.
reference ||| [12] Hosobe, H. A scalable linear constraint solver for user
reference ||| interface construction. In Principles and Practice of
reference ||| Constraint Programming—CP2000, vol. 1894 of
reference ||| LNCS, Springer, 2000, 218–232.
reference ||| [13] Hosobe, H. A modular geometric constraint solver for
reference ||| user interface applications. In Proc. ACM UIST, 2001,
reference ||| 91–100.
reference ||| [14] Kamada, T., and Kawai, S. An algorithm for drawing
reference ||| general undirected graphs. Inf. Process. Lett. 31, 1
reference ||| (1989), 7–15.
reference ||| [15] Kitano, H., Ed. Genetic Algorithms. Sangyo-Tosho,
reference ||| 1993. In Japanese.
reference ||| [16] Kramer, G. A. A geometric constraint engine. Artif.
reference ||| Intell. 58, 1–3 (1992), 327–360.
reference ||| [17] Marriott, K., Chok, S. S., and Finlay, A. A tableau
reference ||| based constraint solving toolkit for interactive
reference ||| graphical applications. In Principles and Practice of
reference ||| Constraint Programming—CP98, vol. 1520 of LNCS,
reference ||| Springer, 1998, 340–354.
reference ||| [18] Sannella, M. Skyblue: A multi-way local propagation
reference ||| constraint solver for user interface construction. In
reference ||| Proc. ACM UIST, 1994,137–146.
reference ||| [19] Takahashi, S. Visualizing constraints in visualization
reference ||| rules. In Proc. CP2000 Workshop on Analysis and
reference ||| Visualization of Constraint Programs and Solvers,
reference ||| 2000.
reference ||| [20] Zhao, J., and Badler, N. I. Inverse kinematics
reference ||| positioning using nonlinear programming for highly
reference ||| articulated figures. ACM Trans. Gr. 13, 4 (1994),
reference ||| 313–336.
page ||| 101
