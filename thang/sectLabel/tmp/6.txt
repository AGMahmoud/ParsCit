title ||| A Distributed 3D Graphics Library
author ||| Blair MacIntyre and Steven Feiner1
affiliation ||| Department of Computer Science
affiliation ||| Columbia University
sectionHeader ||| Abstract
bodyText ||| We present Repo-3D, a general-purpose, object-oriented library for
bodyText ||| developing distributed, interactive 3D graphics applications across
bodyText ||| a range of heterogeneous workstations. Repo-3D is designed to
bodyText ||| make it easy for programmers to rapidly build prototypes using a
bodyText ||| familiar multi-threaded, object-oriented programming paradigm.
bodyText ||| All data sharing of both graphical and non-graphical data is done
bodyText ||| via general-purpose remote and replicated objects, presenting the
bodyText ||| illusion of a single distributed shared memory. Graphical objects
bodyText ||| are directly distributed, circumventing the “duplicate database”
bodyText ||| problem and allowing programmers to focus on the application
bodyText ||| details.
bodyText ||| Repo-3D is embedded in Repo, an interpreted, lexically-scoped,
bodyText ||| distributed programming language, allowing entire applications to
bodyText ||| be rapidly prototyped. We discuss Repo-3D’s design, and introduce
bodyText ||| the notion of local variations to the graphical objects, which allow
bodyText ||| local changes to be applied to shared graphical structures. Local
bodyText ||| variations are needed to support transient local changes, such as
bodyText ||| highlighting, and responsive local editing operations. Finally, we
bodyText ||| discuss how our approach could be applied using other program-
bodyText ||| ming languages, such as Java.
category ||| CR Categories and Subject Descriptors: D.1.3 [Program-
category ||| ming Techniques]: Concurrent Programming—Distributed Pro-
category ||| gramming; H.4.1 [Information Systems Applications]: Office
category ||| Automation—Groupware; I.3.2 [Computer Graphics]: Graphics
category ||| Systems—Distributed/network graphics; I.3.6 [Computer Graph-
category ||| ics]: Methodology and Techniques—Graphics data structures and
category ||| data types; I.3.7 [Computer Graphics]: Three-Dimensional
category ||| Graphics and Realism—Virtual reality.
keyword ||| Additional Keywords and Phrases: object-oriented graphics,
keyword ||| distributed shared memory, distributed virtual environments,
keyword ||| shared-data object model.
sectionHeader ||| 1 INTRODUCTION
bodyText ||| Traditionally, distributed graphics has referred to the architecture
bodyText ||| of a single graphical application whose components are distributed
bodyText ||| over multiple machines [14, 15, 19, 27] (Figure 1a). By taking
bodyText ||| advantage of the combined power of multiple machines, and the
bodyText ||| particular features of individual machines, otherwise impractical
bodyText ||| applications became feasible. However, as machines have grown
bodyText ||| more powerful and application domains such as Computer
footnote ||| 1. {bm,feiner}@cs.columbia.edu, http://www.cs.columbia.edu/graphics
figureCaption ||| Figure 1: Two meanings of distributed graphics: (a) a single logical
figureCaption ||| graphics system with distributed components, and (b) multiple dis-
figureCaption ||| tributed logical graphics systems. We use the second definition here.
bodyText ||| Supported Cooperative Work (CSCW) and Distributed Virtual
bodyText ||| Environments (DVEs) have been making the transition from
bodyText ||| research labs to commercial products, the term distributed graphics
bodyText ||| is increasingly used to refer to systems for distributing the shared
bodyText ||| graphical state of multi-display/multi-person, distributed, interac-
bodyText ||| tive applications (Figure 1b). This is the definition that we use here.
bodyText ||| While many excellent, high-level programming libraries are
bodyText ||| available for building stand-alone 3D applications (e.g. Inventor
bodyText ||| [35], Performer [29], Java 3D [33]), there are no similarly powerful
bodyText ||| and general libraries for building distributed 3D graphics applica-
bodyText ||| tions. All CSCW and DVE systems with which we are familiar
bodyText ||| (e.g., [1, 7, 11, 12, 16, 28, 30, 31, 32, 34, 37, 41]) use the following
bodyText ||| approach: A mechanism is provided for distributing application
bodyText ||| state (either a custom solution or one based on a general-purpose
bodyText ||| distributed programming environment, such as ISIS [4] or Obliq
bodyText ||| [8]), and the state of the graphical display is maintained separately
bodyText ||| in the local graphics library. Keeping these “dual databases” syn-
bodyText ||| chronized is a complex, tedious, and error-prone endeavor. In con-
bodyText ||| trast, some non-distributed libraries, such as Inventor [35], allow
bodyText ||| programmers to avoid this problem by using the graphical scene
bodyText ||| description to encode application state. Extending this “single data-
bodyText ||| base” model to a distributed 3D graphics library is the goal of our
bodyText ||| work on Repo-3D.
bodyText ||| Repo-3D is an object-oriented, high-level graphics package,
bodyText ||| derived from Obliq-3D [25]. Its 3D graphics facilities are similar to
bodyText ||| those of other modern high-level graphics libraries. However, the
bodyText ||| objects used to create the graphical scenes are directly distribut-
bodyText ||| able—from the programmer’s viewpoint, the objects reside in one
bodyText ||| large distributed shared memory (DSM) instead of in a single
bodyText ||| process. The underlying system replicates any of the fine-grained
bodyText ||| objects across as many processes as needed, with no additional
bodyText ||| effort on the part of the programmer. Updates to objects are
bodyText ||| automatically reflected in all replicas, with any required objects
bodyText ||| automatically distributed as needed. By integrating the replicated
bodyText ||| objects into the programming languages we use, distributed
bodyText ||| applications may be built using Repo-3D with little more difficulty
bodyText ||| than building applications in a single process.
bodyText ||| No matter how simple the construction of a distributed applica-
bodyText ||| tion may be, a number of differences between distributed and
bodyText ||| monolithic applications must be addressed. These include:
listItem ||| •	Distributed control. In a monolithic application, a single com-
listItem ||| ponent can oversee the application and coordinate activities
listItem ||| among the separate components by notifying them of changes
listItem ||| to the application state. This is not possible in a non-trivial dis-
listItem ||| tributed application. Therefore, we must provide mechanisms
listItem ||| for different components to be notified of changes to the
listItem ||| distributed state.
listItem ||| •	Interactivity. Updates to distributed state will be slower than
listItem ||| updates to local state, and the amount of data that can be
listItem ||| distributed is limited by network bandwidth. If we do not want
listItem ||| to sacrifice interactive speed, we must be able to perform some
listItem ||| operations locally. For example, an object could be dragged
listItem ||| locally with the mouse, with only a subset of the changes
listItem ||| applied to the replicated state.
listItem ||| •	Local variations. There are times when a shared graphical
listItem ||| scene may need to be modified locally. For example, a
listItem ||| programmer may want to highlight the object under one user’s
listItem ||| mouse pointer without affecting the scene graph viewed by
listItem ||| other users.
bodyText ||| Repo-3D addresses these problems in two ways. First, a
bodyText ||| programmer can associate a notification object with any replicated
bodyText ||| object. The notification object’s methods will be invoked when the
bodyText ||| replicated object is updated. This allows reactive programs to be
bodyText ||| built in a straightforward manner. To deal with the second and third
bodyText ||| problems, we introduce the notion of local variations to graphical
bodyText ||| objects. That is, we allow the properties of a graphical object to be
bodyText ||| modified locally, and parts of the scene graph to be locally added,
bodyText ||| removed, or replaced.
bodyText ||| In Section 2 we describe how we arrived at the solution presented
bodyText ||| here. Section 3 discusses related work, and Section 4 offers a
bodyText ||| detailed description of the underlying infrastructure that was used.
bodyText ||| The design of Repo-3D is presented in Section 5, followed by
bodyText ||| some examples and concluding remarks in Sections 6 and 7.
sectionHeader ||| 2 BACKGROUND
bodyText ||| Repo-3D was created as part of a project to support rapid prototyp-
bodyText ||| ing of distributed, interactive 3D graphical applications, with a
bodyText ||| particular focus on DVEs. Our fundamental belief is that by
bodyText ||| providing uniform high-level support for distributed programming
bodyText ||| in the languages and toolkits we use, prototyping and experiment-
bodyText ||| ing with distributed interactive applications can be (almost) as
bodyText ||| simple as multi-threaded programming in a single process. While
bodyText ||| care must be taken to deal with network delays and bandwidth
bodyText ||| limitations at some stage of the program design (the languages and
bodyText ||| toolkits ought to facilitate this), it should be possible to ignore such
bodyText ||| issues until they become a problem. Our view can be summarized
bodyText ||| by a quote attributed to Alan Kay, “Simple things should be
bodyText ||| simple; complex things should be possible.”
bodyText ||| This is especially true during the exploration and prototyping
bodyText ||| phase of application programming. If programmers are forced to
bodyText ||| expend significant effort building the data-distribution components
bodyText ||| of the application at an early stage, not only will less time be spent
bodyText ||| exploring different prototypes, but radical changes in direction will
bodyText ||| become difficult, and thus unlikely. For example, the implementa-
bodyText ||| tion effort could cause programs to get locked into using a commu-
bodyText ||| nication scheme that may eventually prove less than ideal, or even
bodyText ||| detrimental, to the program’s final design.
bodyText ||| Since we are using object-oriented languages, we also believe
bodyText ||| that data distribution should be tightly integrated with the
bodyText ||| language’s general-purpose objects. This lets the language’s type
bodyText ||| system and programming constructs reduce or eliminate errors in
bodyText ||| the use of the data-distribution system. Language-level integration
bodyText ||| also allows the system to exhibit a high degree of network data
bodyText ||| transparency, or the ability for the programmer to use remote and
bodyText ||| local data in a uniform manner. Without pervasive, structured,
bodyText ||| high-level data-distribution support integrated into our program-
bodyText ||| ming languages and libraries, there are applications that will never
bodyText ||| be built or explored, either because there is too much programming
bodyText ||| overhead to justify trying simple things (“simple things are not
bodyText ||| simple”), or because the added complexity of using relatively
bodyText ||| primitive tools causes the application to become intractable (“com-
bodyText ||| plex things are not possible”).
bodyText ||| Of the tools available for integrating distributed objects into
bodyText ||| programming languages, client-server data sharing is by far the
bodyText ||| most common approach, as exemplified by CORBA [26],
bodyText ||| Modula-3 Network Objects [5], and Java RMI [39]. Unfortunately,
bodyText ||| interactive graphical applications, such as virtual reality, require
bodyText ||| that the data used to refresh the display be local to the process
bodyText ||| doing the rendering or acceptable frame refresh rates will not be
bodyText ||| achieved. Therefore, pure client-server approaches are inappropri-
bodyText ||| ate because at least some of the shared data must be replicated.
bodyText ||| Furthermore, since the time delay of synchronous remote method
bodyText ||| calls is unsuitable for rapidly changing graphical applications,
bodyText ||| shared data should be updated asynchronously. Finally, when data
bodyText ||| is replicated, local access must still be fast.
bodyText ||| The most widely used protocols for replicated data consistency,
bodyText ||| and thus many of the toolkits (e.g., ISIS [4] and Visual-Obliq [3]),
bodyText ||| allow data updates to proceed unimpeded, but block threads read-
bodyText ||| ing local data until necessary updates arrive. The same reason we
bodyText ||| need replicated data in the first place—fast local read access to the
bodyText ||| data—makes these protocols unsuitable for direct replication of the
bodyText ||| graphical data. Of course, these protocols are fine for replicating
bodyText ||| application state that will then be synchronized with a parallel
bodyText ||| graphical scene description, but that is what we are explicitly try-
bodyText ||| ing to avoid. Fortunately, there are replicated data systems (e.g.,
bodyText ||| Orca [2] or COTERIE [24]) that provide replicated objects that are
bodyText ||| well suited to interactive applications, and it is upon the second of
bodyText ||| these systems that Repo-3D is built.
sectionHeader ||| 3 RELATED WORK
bodyText ||| There has been a significant amount of work that falls under the
bodyText ||| first, older definition of distributed graphics. A large number of
bodyText ||| systems, ranging from established commercial products (e.g., IBM
bodyText ||| Visualization Data Explorer [21]) to research systems (e.g.,
bodyText ||| PARADISE [19] and ATLAS [14]), have been created to distribute
bodyText ||| interactive graphical applications over a set of machines. However,
bodyText ||| the goal of these systems is to facilitate sharing of application data
bodyText ||| between processes, with one process doing the rendering. While
bodyText ||| some of these systems can be used to display graphics on more
bodyText ||| than one display, they were not designed to support high-level
bodyText ||| sharing of graphical scenes.
bodyText ||| Most high-level graphics libraries, such as UGA [40], Inventor
bodyText ||| [35] and Java 3D [33], do not provide any support for distribution.
bodyText ||| Others, such as Performer [29], provide support for distributing
bodyText ||| components of the 3D graphics rendering system across multiple
bodyText ||| processors, but do not support distribution across multiple
bodyText ||| machines. One notable exception is TBAG [13], a high-level
bodyText ||| constraint-based, declarative 3D graphics framework. Scenes in
bodyText ||| TBAG are defined using constrained relationships between time-
bodyText ||| varying functions. TBAG allows a set of processes to share a
bodyText ||| single, replicated constraint graph. When any process asserts or
bodyText ||| retracts a constraint, it is asserted or retracted in all processes.
bodyText ||| However, this means that all processes share the same scene, and
bodyText ||| that the system’s scalability is limited because all processes have a
bodyText ||| copy of (and must evaluate) all constraints, whether or not they are
bodyText ||| interested in them. There is also no support for local variations of
bodyText ||| the scene in different processes.
bodyText ||| Machiraju [22] investigated an approach similar in flavor to ours,
bodyText ||| but it was not aimed at the same fine-grained level of interactivity
bodyText ||| and was ultimately limited by the constraints of the implementa-
bodyText ||| tion platform (CORBA and C++). For example, CORBA objects
bodyText ||| are heavyweight and do not support replication, so much of their
bodyText ||| effort was spent developing techniques to support object migration
bodyText ||| and “fine-grained” object sharing. However, their fine-grained
bodyText ||| objects are coarser than ours, and, more importantly, they do not
bodyText ||| support the kind of lightweight, transparent replication we desire.
bodyText ||| A programmer must explicitly choose whether to replicate, move,
bodyText ||| or copy an object between processes when the action is to occur (as
bodyText ||| opposed to at object creation time). Replicated objects are indepen-
bodyText ||| dent new copies that can be modified and used to replace the origi-
bodyText ||| nal—simultaneous editing of objects, or real-time distribution of
bodyText ||| changes as they are made is not supported.
bodyText ||| Of greater significance is the growing interest for this sort of sys-
bodyText ||| tem in the Java and VRML communities. Java, like Modula-3, is
bodyText ||| much more suitable as an implementation language than C or C++
bodyText ||| because of its cross-platform compatibility and support for threads
bodyText ||| and garbage collection: Without the latter two language features,
bodyText ||| implementing complex, large-scale distributed applications is
bodyText ||| extremely difficult. Most of the current effort has been focused on
bodyText ||| using Java as a mechanism to facilitate multi-user VRML worlds
bodyText ||| (e.g., Open Communities [38]). Unfortunately, these efforts
bodyText ||| concentrate on the particulars of implementing shared virtual
bodyText ||| environments and fall short of providing a general-purpose shared
bodyText ||| graphics library. For example, the Open Communities work is
bodyText ||| being done on top of SPLINE [1], which supports only a single
bodyText ||| top-level world in the local scene database.
bodyText ||| Most DVEs [11, 12, 16, 31, 32] provide support for creating
bodyText ||| shared virtual environments, not general purpose interactive 3D
bodyText ||| graphics applications. They implement a higher level of abstrac-
bodyText ||| tion, providing support for rooms, objects, avatars, collision detec-
bodyText ||| tion, and other things needed in single, shared, immersive virtual
bodyText ||| environments. These systems provide neither general-purpose
bodyText ||| programming facilities nor the ability to work with 3D scenes at a
bodyText ||| level provided by libraries such as Obliq-3D or Inventor. Some use
bodyText ||| communication schemes that prevent them from scaling beyond a
bodyText ||| relatively small number of distributed processes, but for most the
bodyText ||| focus is explicitly on efficient communication. SIMNET [7], and
bodyText ||| the later NPSNet [41], are perhaps the best known large-scale
bodyText ||| distributed virtual-environment systems. They use a fixed, well-
bodyText ||| defined communication protocol designed to support a single,
bodyText ||| large-scale, shared, military virtual environment.
bodyText ||| The techniques for object sharing implemented in recent CSCW
bodyText ||| toolkits [28, 30, 34, 37] provide some of the features we need,
bodyText ||| particularly automatic replication of data to ease construction of
bodyText ||| distributed applications. However, none of these toolkits has
bodyText ||| integrated the distribution of data into its programming language’s
bodyText ||| object model as tightly as we desire. As a result, they do not pro-
bodyText ||| vide a high enough level of network data transparency or suffi-
bodyText ||| ciently strong consistency guarantees. In groupware applications,
bodyText ||| inconsistencies tend to arise when multiple users attempt to per-
bodyText ||| form conflicting actions: the results are usually obvious to the
bodyText ||| users and can be corrected using social protocols. This is not an
bodyText ||| acceptable solution for a general-purpose, distributed 3D graphics
bodyText ||| toolkit. Furthermore, none of these CSCW systems provides any
bodyText ||| support for asynchronous update notification, or is designed to
bodyText ||| support the kind of large-scale distribution we have in mind.
bodyText ||| Finally, while distributed games, such as Quake, have become
bodyText ||| very popular, they only distribute the minimum amount of applica-
bodyText ||| tion state necessary. They do not use (or provide) an abstract, high-
bodyText ||| level distributed 3D graphics system.
bodyText ||| Network
figureCaption ||| Figure 2: The architecture of Repo-3D. Aside from native graphics
figureCaption ||| libraries (X, Win32, OpenGL, Renderware) the Modula-3 runtime
figureCaption ||| shields most of the application from the OS. The Replicated Object
figureCaption ||| package uses an Event communication package and the Network
figureCaption ||| Object package. DistAnim-3D is implemented on top of a variety of
figureCaption ||| native graphics libraries and Replicated Objects. Repo exposes most of
figureCaption ||| the useful Modula-3 packages, as well as using Network Objects and
figureCaption ||| Replicated Objects to present a distributed shared memory model to
figureCaption ||| the programmer.
sectionHeader ||| 4 UNDERLYING INFRASTRUCTURE
bodyText ||| Our work was done in the Modula-3 programming language [18].
bodyText ||| We decided to use Modula-3 because of the language itself and the
bodyText ||| availability of a set of packages that provide a solid foundation for
bodyText ||| our infrastructure. Modula-3 is a descendant of Pascal that corrects
bodyText ||| many of its deficiencies, and heavily influenced the design of Java.
bodyText ||| In particular, Modula-3 retains strong type safety, while adding
bodyText ||| facilities for exception handling, concurrence object-oriented
bodyText ||| programming, and automatic garbage collection . One of its most
bodyText ||| important features for our work is that it gives us uniform access to
bodyText ||| these facilities across all architectures.
bodyText ||| Repo-3D relies on a number of Modula-3 libraries, as illustrated
bodyText ||| in Figure 2. Distributed data sharing is provided by two packages,
bodyText ||| the Network Object client-server object package [5], and the
bodyText ||| Replicated Object shared object package [24] (see Section 4.1).
bodyText ||| DistAnim-3D is derived from Anim-3D [25], a powerful, non-
bodyText ||| distributed, general-purpose 3D library originally designed for 3D
bodyText ||| algorithm animation (see Section 4.2). Finally, Repo itself is a
bodyText ||| direct descendant of Obliq [8], and uses the Replicated Object
bodyText ||| package to add replicated data to Obliq (see Section 4.3).
subsectionHeader ||| 4.1 Distributed Shared Memory
bodyText ||| Repo-3D’s data sharing mechanism is based on the Shared Data-
bodyText ||| Object Model of Distributed Shared Memory (DSM) [20]. DSM
bodyText ||| allows a network of computers to be programmed much like a mul-
bodyText ||| tiprocessor, since the programmer is presented with the familiar
bodyText ||| paradigm of a common shared memory. The Shared Data-Object
bodyText ||| Model of DSM is particularly well suited to our needs since it is a
bodyText ||| high-level approach that can be implemented efficiently at the
bodyText ||| application level. In this model, shared data is encapsulated in
bodyText ||| user-defined objects and can only be accessed through those
bodyText ||| objects’ method calls. The DSM address space is partitioned
bodyText ||| implicitly by the application programmer, with an object being the
bodyText ||| smallest unit of sharing. All shared data is fully network transpar-
footnote ||| 2. The Modula-3 compiler we used is available from Critical Mass, Inc. as
footnote ||| part of the Reactor programming environment. The compiler, and thus
footnote ||| our system, runs on all the operating systems we have available (plus
footnote ||| others): Solaris, IRIX, HP-UX, Linux, and Windows NT and 95.
figure ||| Repo-3D
figure ||| Modula-3 Runtime
figure ||| Operating System Services
figure ||| Repo
figure ||| Network Objects
figure ||| Replicated Objects
figure ||| Events
figure ||| DistAnim-3D
figure ||| Native
figure ||| Graphics
bodyText ||| ent because it is encapsulated within the programming language
bodyText ||| objects.
bodyText ||| Distribution of new objects between the processes is as simple as
bodyText ||| passing them back and forth as parameters to, or return values
bodyText ||| from, method calls—the underlying systems take care of the rest.3
bodyText ||| Objects are only distributed to new processes as necessary, and (in
bodyText ||| our system) are removed by the garbage collector when they are no
bodyText ||| longer referenced. Furthermore, distributed garbage collection is
bodyText ||| supported, so objects that are no longer referenced in any process
bodyText ||| are removed completely.
bodyText ||| There are three kinds of distributed object semantics in our DSM:
listItem ||| •	Simple objects correspond to normal data objects, and have no
listItem ||| special distributed semantics. When a simple object is copied
listItem ||| between processes, a new copy is created in the destination
listItem ||| process that has no implied relationship to the object in the
listItem ||| source process.
listItem ||| •	Remote objects have client-server distribution semantics. When
listItem ||| a remote object is copied between processes, all processes
listItem ||| except the one in which the object was created end up with a
listItem ||| proxy object that forwards method invocations across the
listItem ||| network to the original object.
listItem ||| •	Replicated objects have replicated distribution semantics.
listItem ||| When a replicated object is passed between processes, a new
listItem ||| replica is created in the destination process. If any replica is
listItem ||| changed, the change is reflected in all replicas.
bodyText ||| The Network Object package provides support for remote
bodyText ||| objects. It implements distributed garbage collection, exception
bodyText ||| propagation back to the calling site, and automatic marshalling and
bodyText ||| unmarshalling of method arguments and return values of virtually
bodyText ||| any data type between heterogeneous machine architectures. The
bodyText ||| package is similar to other remote method invocation (RMI) pack-
bodyText ||| ages developed later, such as the Java RMI library [39]. All method
bodyText ||| invocations are forwarded to the original object, where they are
bodyText ||| executed in the order they are received.
bodyText ||| The Replicated Object package supports replicated objects. Each
bodyText ||| process can call any method of an object it shares, just as it can
bodyText ||| with a simple or remote object. We will describe the Replicated
bodyText ||| Object package in more detail, as Repo-3D relies heavily on its
bodyText ||| design, and the design of a replicated object system is less straight-
bodyText ||| forward than a remote one. The model supported by the Replicated
bodyText ||| Object package follows two principles:
listItem ||| •	All operations on an instance of an object are atomic and
listItem ||| serializable. All operations are performed in the same order on
listItem ||| all copies of the object. If two methods are invoked simulta-
listItem ||| neously, the order of invocation is nondeterministic, just as if
listItem ||| two threads attempted to access the same memory location
listItem ||| simultaneously in a single process.
listItem ||| •	The above principle applies to operations on single objects.
listItem ||| Making sequences of operations atomic is up to the program-
listItem ||| mer.
bodyText ||| The implementation of the Replicated Object package is based
bodyText ||| on the approach used in the Orca distributed programming
bodyText ||| language [2]. A full replication scheme is used, where a single
bodyText ||| object is either fully replicated in a process or not present at all.
bodyText ||| Avoiding partial replication significantly simplifies the implemen-
bodyText ||| tation and the object model, and satisfies the primary rationale for
bodyText ||| replication: fast read-access to shared data. To maintain replication
bodyText ||| consistency an update scheme is used, where updates to the object
bodyText ||| are applied to all copies.
footnote ||| 3. An important detail is how the communication is bootstrapped. In the
footnote ||| case of the Network and Replicated Object packages, to pass a first
footnote ||| object between processes, one of them exports the object to a special
footnote ||| network object demon under some known name on some known
footnote ||| machine. The second process then retrieves the object.
bodyText ||| The method of deciding what is and is not an update is what
bodyText ||| makes the Orca approach particularly interesting and easy to
bodyText ||| implement. All methods are marked as either read or update meth-
bodyText ||| ods by the programmer who creates the object type. Read methods
bodyText ||| are assumed to not change the state of the object and are therefore
bodyText ||| applied immediately to the local object without violating consis-
bodyText ||| tency. Update methods are assumed to change the state. To distrib-
bodyText ||| ute updates, arguments to the update method are marshalled into a
bodyText ||| message and sent to all replicas. To ensure all updates are applied
bodyText ||| in the same order, the current implementation of the Replicated
bodyText ||| Object package designates a sequencer process for each object.
bodyText ||| There may be more than one sequencer in the system to avoid
bodyText ||| overloading one process with all the objects (in this case, each
bodyText ||| object has its updates managed by exactly one of the sequencers.)
bodyText ||| The sequencer is responsible for assigning a sequence number to
bodyText ||| each message before it is sent to all object replicas. The replicas
bodyText ||| then execute the incoming update messages in sequence. The pro-
bodyText ||| cess that initiated the update does not execute the update until it
bodyText ||| receives a message back from the sequencer and all updates with
bodyText ||| earlier sequence numbers have been executed.
bodyText ||| There are three very important reasons for choosing this
bodyText ||| approach. First, it is easy to implement on top of virtually any
bodyText ||| object-oriented language, using automatically generated object
bodyText ||| subtypes and method wrappers that communicate with a simple
bodyText ||| runtime system. We do this in our Modula-3 implementation, and it
bodyText ||| would be equally applicable to an implementation in C++ or Java.
bodyText ||| For example, the JSDT [36] data-sharing package in Java uses a
bodyText ||| similar approach.
bodyText ||| Second, the Replicated Object package does not pay attention to
bodyText ||| (or even care) when the internal data fields of an object change.
bodyText ||| This allows the programmer great flexibility in deciding exactly
bodyText ||| what constitutes an update or not, and what constitutes the shared
bodyText ||| state 4. For example, objects could have a combination of global
bodyText ||| and local state, and the methods that change the local state could
bodyText ||| be classified as read methods since they do not modify the global
bodyText ||| state. Alternatively, read methods could do some work locally and
bodyText ||| then call an update method to propagate the results, allowing time-
bodyText ||| consuming computation to be done once and the result distributed
bodyText ||| in a clean way. We took advantage of both of these techniques in
bodyText ||| implementing Repo-3D.
bodyText ||| Finally, the immediate distribution of update methods ensures
bodyText ||| that changes are distributed in a timely fashion, and suggests a
bodyText ||| straightforward solution to the asynchronous notification problem.
bodyText ||| The Replicated Object package generates a Notification Object
bodyText ||| type for each Replicated Object type. These new objects have
bodyText ||| methods corresponding to the update methods of their associated
bodyText ||| Replicated Object. The arguments to these methods are the same as
bodyText ||| the corresponding Replicated Object methods, plus an extra
bodyText ||| argument to hold the Replicated Object instance. These notifiers
bodyText ||| can be used by a programmer to receive notification of changes to
bodyText ||| a Replicated Object in a structured fashion. To react to updates to a
bodyText ||| Replicated Object instance, a programmer simply overrides the
bodyText ||| methods of the corresponding Notification Object with methods
bodyText ||| that react appropriately to those updates, and associates an instance
footnote ||| 4. Of course, it falls squarely on the shoulders of the programmer to
footnote ||| ensure that the methods provided always leave the object in a consistent
footnote ||| state. This is not significantly different than what needs to be done
footnote ||| when building a complex object that is simultaneously accessed by
footnote ||| multiple threads in a non-distributed system. For example, if a
footnote ||| programmer reads an array of numbers from inside the object and then
footnote ||| uses an update method to write a computed average back into the
footnote ||| object, the internal array may have changed before the average is
footnote ||| written, resulting in a classic inconsistency problem. In general,
footnote ||| methods that perform computations based on internal state (rather than
footnote ||| on the method arguments) are potentially problematic and need to be
footnote ||| considered carefully.
figure ||| RootGO
figure ||| ChoiceGroupGO
figure ||| OrthoCameraGO
figure ||| PerspCameraGO
figure ||| AmbientLightGO
figure ||| VectorLightGO
figure ||| PointLightGO
figure ||| SpotLightGO
figure ||| GO
figure ||| IndexedLineSetGO
figure ||| NonSurfaceGO
figure ||| Text2DGO
figure ||| PolygonGO
figure ||| BoxGO
figure ||| SphereGO
figure ||| CylinderGO
figure ||| DiskGO
figure ||| TorusGO
figure ||| QuadMeshGO
figure ||| IndexedPolygonSetGO
figureCaption ||| Figure 3: The Repo-3D GO class hierarchy. Most of the classes are
figureCaption ||| also in Obliq-3D; the italicized ones were added to Repo-3D.
figureCaption ||| Figure 4: The relationship between properties, names, values, and
figureCaption ||| behaviors. Each oval represents an object and arrows show contain-
figureCaption ||| ment.
bodyText ||| of it with the Replicated Object instance. Each time an update
bodyText ||| method of the Replicated Object is invoked, the corresponding
bodyText ||| method of the Notifier Object is also invoked. Notification Objects
bodyText ||| eliminate the need for object polling and enable a “data-driven”
bodyText ||| flow of control.
subsectionHeader ||| 4.2 Obliq-3D
bodyText ||| Obliq-3D is composed of Anim-3D, a 3D animation package
bodyText ||| written in Modula-3, and a set of wrappers that expose Anim-3D to
bodyText ||| the Obliq programming language (see Section 4.3). Anim-3D is
bodyText ||| based on three simple and powerful concepts: graphical objects for
bodyText ||| building graphical scenes, properties for specifying the behavior of
bodyText ||| the graphical objects, and input event callbacks to support interac-
bodyText ||| tive behavior. Anim-3D uses the damage-repair model: whenever a
bodyText ||| graphical object or property changes (is damaged), the image is
bodyText ||| repaired without programmer intervention.
bodyText ||| Graphical objects (GOs) represent all the logical entities in the
bodyText ||| graphical scene: geometry (e.g., lines, polygons, spheres, polygon
bodyText ||| sets, and text), lights and cameras of various sorts, and groups of
bodyText ||| other GOs. One special type of group, the RootGO, represents a
bodyText ||| window into which graphics are rendered. GOs can be grouped
bodyText ||| together in any valid directed acyclic graph (DAG). The GO class
bodyText ||| hierarchy is shown in Figure 3.
bodyText ||| A property is a defined by a name and a value. The name deter-
bodyText ||| mines which attribute is affected by the property, such as “Texture
bodyText ||| Mode” or “Box Corner1”. The value specifies how it is affected
bodyText ||| and is determined by its behavior, a time-variant function that
bodyText ||| takes the current animation time and returns a value. Properties,
bodyText ||| property values, and behaviors are all objects, and their relation-
bodyText ||| ships are shown in Figure 4. When a property is created, its name
bodyText ||| and value are fixed. However, values are mutable and their behav-
bodyText ||| ior may be changed at any time. There are four kinds of behaviors
bodyText ||| for each type of properties: constant (do not vary over time),
bodyText ||| synchronous (follow a programmed set of requests, such as “move
bodyText ||| from A to B starting at time t=1 and taking 2 seconds”), asynchro-
bodyText ||| nous (execute an arbitrary time-dependent function to compute the
bodyText ||| value) and dependent (asynchronous properties that depend on
bodyText ||| other properties). Synchronous properties are linked to animation
bodyText ||| handles and do not start satisfying their requests until the anima-
bodyText ||| tion handle is signalled. By linking multiple properties to the same
bodyText ||| handle, a set of property value changes can be synchronized.
bodyText ||| Associated with each GO g is a partial mapping of property
bodyText ||| names to values determined by the properties that have been asso-
bodyText ||| ciated with g. A property associated with g affects not only g but
bodyText ||| all the descendants of g that do not override the property. A single
bodyText ||| property may be associated with any number of GOs. It is perfectly
bodyText ||| legal to associate a property with a GO that is not affected by it; for
bodyText ||| example, attaching a “Surface Color” property to a GroupGO does
bodyText ||| not affect the group node itself, but could potentially affect the
bodyText ||| surface color of any GO contained in that group. A RootGO sets an
bodyText ||| initial default value for each named property.
bodyText ||| There are three types of input event callbacks in Anim-3D, corre-
bodyText ||| sponding to the three kinds of interactive events they handle:
bodyText ||| mouse callbacks (triggered by mouse button events), motion call-
bodyText ||| backs (triggered by mouse motion events) and keyboard callbacks
bodyText ||| (triggered by key press events). Each object has three callback
bodyText ||| stacks, and the interactive behavior of an object can be redefined
bodyText ||| by pushing a new callback onto the appropriate stack. Any event
bodyText ||| that occurs within a root window associated with a RootGO r will
bodyText ||| be delivered to the top handler on r’s callback stack. The handler
bodyText ||| could delegate the event to one of r’s children, or it may handle it
bodyText ||| itself, perhaps changing the graphical scene in some way.
bodyText ||| DistAnim-3D is a direct descendant of Anim-3D. In addition to
bodyText ||| the objects being distributed, it has many additional facilities that
bodyText ||| are needed for general-purpose 3D graphical applications, such as
bodyText ||| texture mapping, indexed line and polygon sets, choice groups,
bodyText ||| projection and transformation callbacks, and picking. Since
bodyText ||| DistAnim-3D is embedded in Repo instead of Obliq (see
bodyText ||| Section 4.3), the resulting library is called Repo-3D.
subsectionHeader ||| 4.3 Obliq and Repo
bodyText ||| Obliq [8] is a lexically-scoped, untyped, interpreted language for
bodyText ||| distributed object-oriented computation. It is implemented in, and
bodyText ||| tightly integrated with, Modula-3. An Obliq computation may
bodyText ||| involve multiple threads of control within an address space, multi-
bodyText ||| ple address spaces on a machine, heterogeneous machines over a
bodyText ||| local network, and multiple networks over the Internet. Obliq uses,
bodyText ||| and supports, the Modula-3 thread, exception, and garbage-collec-
bodyText ||| tion facilities. Its distributed-computation mechanism is based on
bodyText ||| Network Objects, allowing transparent support for multiple
bodyText ||| processes on heterogeneous machines. Objects are local to a site,
bodyText ||| while computations can roam over the network. Repo [23] is a
bodyText ||| descendant of Obliq that extends the Obliq object model to include
bodyText ||| replicated objects. Therefore, Repo objects have state that may be
bodyText ||| local to a site (as in Obliq) or replicated across multiple sites.
sectionHeader ||| 5 DESIGN OF REPO-3D
bodyText ||| Repo-3D’s design has two logical parts: the basic design and local
bodyText ||| variations. The basic design encompasses the changes to Obliq-3D
bodyText ||| to carry it into a distributed context, and additional enhancements
bodyText ||| that are not particular to distributed graphics (and are therefore not
bodyText ||| discussed here). Local variations are introduced to handle two
bodyText ||| issues mentioned in Section 1: transient local changes and respon-
bodyText ||| sive local editing.
figure ||| . . .
figure ||| Name
figure ||| Property
figure ||| Value	Behavior
figure ||| Request
figure ||| Request
figure ||| GroupGO
figure ||| CameraGO
figure ||| LightGO
figure ||| SurfaceGO
figure ||| LineGO
figure ||| MarkerGO
figure ||| TextGO
subsectionHeader ||| 5.1 Basic Repo-3D Design
bodyText ||| The Anim-3D scene-graph model is well suited for adaptation to a
bodyText ||| distributed environment. First, in Anim-3D, properties are attached
bodyText ||| to nodes, not inserted into the graph, and the property and child
bodyText ||| lists are unordered (i.e., the order in which properties are assigned
bodyText ||| to a node, or children are added to a group, does not affect the final
bodyText ||| result). In libraries that insert properties and nodes in the graph and
bodyText ||| execute the graph in a well-defined order (such as Inventor), the
bodyText ||| siblings of a node (or subtree) can affect the attributes of that node
bodyText ||| (or subtree). In Anim-3D, and similar libraries (such as Java 3D),
bodyText ||| properties are only inherited down the graph, so a node’s properties
bodyText ||| are a function of the node itself and its ancestors—its siblings do
bodyText ||| not affect it. Therefore, subtrees can be added to different scene
bodyText ||| graphs, perhaps in different processes, with predictable results.
bodyText ||| Second, the interface (both compiled Anim-3D and interpreted
bodyText ||| Obliq-3D) is programmatical and declarative. There is no “graphi-
bodyText ||| cal scene” file format per se: graphical scenes are created as the
bodyText ||| side effect of executing programs that explicitly create objects and
bodyText ||| manipulate them via the object methods. Thus, all graphical
bodyText ||| objects are stored as the Repo-3D programs that are executed to
bodyText ||| create them. This is significant, because by using the Replicated
bodyText ||| Object library described in Section 4.1 to make the graphical
bodyText ||| objects distributed, the “file format” (i.e., a Repo-3D program) is
bodyText ||| updated for free.
bodyText ||| Converting Anim-3D objects to Replicated Objects involved
bodyText ||| three choices: what objects to replicate, what methods update the
bodyText ||| object state, and what the global, replicated state of each object is.
bodyText ||| Since replicated objects have more overhead (e.g., method execu-
bodyText ||| tion time, memory usage, and latency when passed between
bodyText ||| processes), not every category of object in Repo-3D is replicated.
bodyText ||| We will consider each of the object categories described in
bodyText ||| Figure 4.2 in turn: graphical objects (GOs), properties (values,
bodyText ||| names, behaviors, animation handles) and callbacks. For each of
bodyText ||| these objects, the obvious methods are designated as update meth-
bodyText ||| ods, and, as discussed in Section 4. 1, the global state of each object
bodyText ||| is implicitly determined by those update methods. Therefore, we
bodyText ||| will not go into excessive detail about either the methods or the
bodyText ||| state. Finally, Repo-3D’s support for change notification will be
bodyText ||| discussed.
subsubsectionHeader ||| 5.1.1 Graphical Objects
bodyText ||| GOs are the most straightforward. There are currently twenty-one
bodyText ||| different types of GOs, and all but the RootGOs are replicated.
bodyText ||| Since RootGOs are associated with an onscreen window, they are
bodyText ||| not replicated—window creation remains an active decision of the
bodyText ||| local process. Furthermore, if replicated windows are needed, the
bodyText ||| general-purpose programming facilities of Repo can be used to
bodyText ||| support this in a relatively straightforward manner, outside the
bodyText ||| scope of Repo-3D. A GO’s state is comprised of the properties
bodyText ||| attached to the object, its name, and some other non-inherited
bodyText ||| property attributes.5 The methods that modify the property list are
bodyText ||| update methods. Group GOs also contain a set of child nodes, and
bodyText ||| have update methods that modify that set.
subsubsectionHeader ||| 5.1.2 Properties
bodyText ||| Properties are more complex. There are far more properties in a
bodyText ||| graphical scene than there are graphical objects, they change much
bodyText ||| more rapidly, and each property is constructed from a set of
bodyText ||| Modula-3 objects. There are currently 101 different properties of
footnote ||| 5. Some attributes of a GO, such as the arrays of Point3D properties that
footnote ||| define the vertices of a polygon set, are not attached to the object, but
footnote ||| are manipulated through method calls.
bodyText ||| seventeen different types in Repo-3D, and any of them can be
bodyText ||| attached to any GO. A typical GO would have anywhere from two
bodyText ||| or three (e.g., a BoxGO would have at least two properties to
bodyText ||| define its corners) to a dozen or more. And, each of these proper-
bodyText ||| ties could be complex: in the example in Section 6, a single
bodyText ||| synchronous property for a long animation could have hundreds of
bodyText ||| requests enqueued within it.
bodyText ||| Consider again the object structure illustrated in Figure 4. A
bodyText ||| property is defined by a name and a value, with the value being a
bodyText ||| container for a behavior. Only one of the Modula-3 objects is
bodyText ||| replicated, the property value. Property values serve as the repli-
bodyText ||| cated containers for property behaviors. To change a property, a
bodyText ||| new behavior is assigned to its value. The state of the value is the
bodyText ||| current behavior.
bodyText ||| Animation handles are also replicated. They tie groups of related
bodyText ||| synchronous properties together, and are the basis for the interac-
bodyText ||| tion in the example in Section 6. In Anim-3D, handles have one
bodyText ||| animate method, which starts an animation and blocks until it
bodyText ||| finishes. Since update methods are executed everywhere, and block
bodyText ||| access to the object while they are being executed, they should not
bodyText ||| take an extended period of time. In creating Repo-3D, the
bodyText ||| animate method was changed to call two new methods: an update
bodyText ||| method that starts the animation, and a non-update method that
bodyText ||| waits for the animation to finish. We also added methods to pause
bodyText ||| and resume an animation, to retrieve and change the current rela-
bodyText ||| tive time of an animation handle, and to stop an animation early.
bodyText ||| The state of an Animation handle is a boolean value that says if it is
bodyText ||| active or not, plus the start, end, and current time (if the handle is
bodyText ||| paused).
bodyText ||| Most of the Modula-3 objects that comprise a property are not
bodyText ||| replicated, for a variety of reasons:
listItem ||| •	Properties represent a permanent binding between a property
listItem ||| value and a name. Since they are immutable, they have no syn-
listItem ||| chronization requirements and can simply be copied between
listItem ||| processes.
listItem ||| •	Names represent simple constant identifiers, and are therefore
listItem ||| not replicated either.
listItem ||| •	Behaviors and requests are not replicated. While they can be
listItem ||| modified after being created, they are treated as immutable
listItem ||| data types for two reasons. First, the vast majority of behaviors,
listItem ||| even complex synchronous ones, are not changed once they
listItem ||| have been created and initialized. Thus, there is some justifica-
listItem ||| tion for classifying the method calls that modify them as part
listItem ||| of their initialization process. The second reason is practical
listItem ||| and much more significant. Once a scene has been created and
listItem ||| is being “used” by the application, the bulk of the time-critical
listItem ||| changes to it tend to be assignments of new behaviors to the
listItem ||| existing property values. For example, an object is moved by
listItem ||| assigning a new (often constant) behavior to its
listItem ||| GO _T rans fo rm property value. Therefore, the overall perfor-
listItem ||| mance of the system depends heavily on the performance of
listItem ||| property value behavior changes. By treating behaviors as
listItem ||| immutable objects, they can simply be copied between
listItem ||| processes without incurring the overhead of the replicated
listItem ||| object system.
subsubsectionHeader ||| 5.1.3 Input Callbacks
bodyText ||| In Repo-3D, input event callbacks are not replicated. As discussed
bodyText ||| in Section 4.2, input events are delivered to the callback stacks of a
bodyText ||| RootGO. Callbacks attached to any other object receive input
bodyText ||| events only if they are delivered to that object by the programmer,
bodyText ||| perhaps recursively from another input event callback (such as the
bodyText ||| one attached to the RootGO). Therefore, the interactive behavior of
bodyText ||| a root window is defined not only by the callbacks attached to its
bodyText ||| RootGO, but also by the set of callbacks associated with the graph
bodyText ||| rooted at that RootGO. Since the RootGOs are not replicated, the
figure ||| (a)	(b)
figure ||| (c) (d)
figureCaption ||| Figure 5: Simultaneous images from a session with the distributed CATHI animation viewer, running on four machines, showing an anima-
figureCaption ||| tion of an engine. (a) Plain animation viewer, running on Windows NT. (b) Overview window, running on Windows 95. (c) Animation viewer
figureCaption ||| with local animation meter, running on IRIX. (d) Animation viewer with local transparency to expose hidden parts, running on Solaris.
bodyText ||| callbacks that they delegate event handling to are not replicated
bodyText ||| either. If a programmer wants to associate callbacks with objects as
bodyText ||| they travel between processes, Repo’s general-purpose program-
bodyText ||| ming facilities can be used to accomplish this in a straightforward
bodyText ||| manner.
subsubsectionHeader ||| 5.1.4 Change Notification
bodyText ||| The final component of the basic design is support for notification
bodyText ||| of changes to distributed objects. For example, when an object’s
bodyText ||| position changes or a new child is added to a group, some of the
bodyText ||| processes containing replicas may wish to react in some way. For-
bodyText ||| tunately, as discussed in Section 4.1, the Replicated Object
bodyText ||| package automatically generates Notification Object types for all
bodyText ||| replicated object types, which provide exactly the required
bodyText ||| behavior. The Notification Objects for property values allow a
bodyText ||| programmer to be notified of changes to the behavior of a property,
bodyText ||| and the Notification Objects for the various GOs likewise allow
bodyText ||| notification of updates to them.
subsectionHeader ||| 5.2 Local Variations
bodyText ||| Repo-3D’s local variations solve a set of problems particular to the
bodyText ||| distributed context in which Repo-3D lives: maintaining interactiv-
bodyText ||| ity and supporting local modifications to the shared scene graph.
bodyText ||| If the graphical objects and their properties were always strictly
bodyText ||| replicated, programmers would have to create local variations by
bodyText ||| copying the objects to be modified, creating a set of Notification
bodyText ||| Objects on the original objects, the copies of those objects, and all
bodyText ||| their properties (to be notified when either change), and reflecting
bodyText ||| the appropriate changes between the instances. Unfortunately,
bodyText ||| while this process could be automated somewhat, it would still be
bodyText ||| extremely tedious and error prone. More seriously, the overhead of
bodyText ||| creating this vast array of objects and links between them would
bodyText ||| make this approach impractical for short transient changes, such as
bodyText ||| highlighting an object under the mouse.
bodyText ||| To overcome this problem, Repo-3D allows the two major
bodyText ||| elements of the shared state of the graphical object scene—the
bodyText ||| properties attached to a GO and the children of a group—to have
bodyText ||| local variations applied to them. (Local variations on property
bodyText ||| values or animation handles are not supported, although we are
bodyText ||| considering adding support for the latter.)
bodyText ||| Conceptually, local state is the state added to each object (the
bodyText ||| additions, deletions, and replacements to the properties or
bodyText ||| children) that is only accessible to the local copies and is not
bodyText ||| passed to remote processes when the object is copied to create a
bodyText ||| new replica. The existence of local state is possible because, as
bodyText ||| discussed in Section 4. 1, the shared state of a replicated object is
bodyText ||| implicitly defined by the methods that update it 6. Therefore, the
bodyText ||| new methods that manipulate the local variations are added to the
bodyText ||| GOs as non-update methods. Repo-3D combines both the global
bodyText ||| and local state when creating the graphical scene using the under-
bodyText ||| lying graphics package.
bodyText ||| As mentioned above, local variations come in two flavors:
listItem ||| •	Property variations. There are three methods to set, unset, and
listItem ||| get the global property list attached to a GO. We added the
listItem ||| following methods to manipulate local variations: add or
listItem ||| remove local properties (overriding the value normally used for
listItem ||| the object), hide or reveal properties (causing the property
listItem ||| value of the parent node to be inherited), and flush the set of
listItem ||| local variations (removing them in one step) or atomically
listItem ||| apply them to the global state of the object.
listItem ||| •	Child variations. There are five methods to add, remove,
listItem ||| replace, retrieve, and flush the set of children contained in a
listItem ||| group node. We added the following ones: add a local node,
listItem ||| remove a global node locally, replace a global node with some
listItem ||| other node locally, remove each of these local variations, flush
listItem ||| the local variations (remove them all in one step), and atomi-
listItem ||| cally apply the local variations to the global state.
bodyText ||| This set of local operations supports the problems local variations
bodyText ||| were designed to solve, although some possible enhancements are
bodyText ||| discussed in Section 7.
sectionHeader ||| 6 EXAMPLE: AN ANIMATION EXAMINER
bodyText ||| As an example of the ease of prototyping distributed applications
bodyText ||| with Repo-3D, we created a distributed animation examiner for the
bodyText ||| CATHI [6] animation generation system. CATHI generates short
bodyText ||| informational animation clips to explain the operation of technical
bodyText ||| devices. It generates full-featured animation scripts, including
bodyText ||| camera and object motion, color and opacity effects, and lighting
bodyText ||| setup.
bodyText ||| It was reasonably straightforward to modify CATHI to generate
bodyText ||| Repo-3D program files, in addition to the GeomView and Render-
bodyText ||| Man script files it already generated. The resulting output is a
bodyText ||| Repo-3D program that creates two scene DAGs: a camera graph
bodyText ||| and a scene graph. The objects in these DAGs have synchronous
bodyText ||| behaviors specified for their surface and transformation properties.
bodyText ||| An entire animation is enqueued in the requests of these behaviors,
bodyText ||| lasting anywhere from a few seconds to a few minutes.
bodyText ||| We built a distributed, multi-user examiner over the course of a
bodyText ||| weekend. The examiner allows multiple users to view the same
bodyText ||| animation while discussing it (e.g., via electronic chat or on the
bodyText ||| phone). Figure 5 shows images of the examiner running on four
footnote ||| 6. The local state is not copied when a replicated object is first passed to a
footnote ||| new process because the Repo-3D objects have custom serialization
footnote ||| routines (or Picklers, in Modula-3 parlance). These routines only pass
footnote ||| the global state, and initialize the local state on the receiving side to
footnote ||| reasonable default values corresponding to the empty local state.
bodyText ||| machines, each with a different view of the scene. The first step
bodyText ||| was to build a simple “loader” that reads the animation file, creates
bodyText ||| a window, adds the animation scene and camera to it, and exports
bodyText ||| the animation on the network, requiring less than a dozen lines of
bodyText ||| Repo-3D code. A “network” version, that imports the animation
bodyText ||| from the network instead of reading it from disk, replaced the lines
bodyText ||| of code to read and export the animation with a single line to
bodyText ||| import it. Figure 5(a) shows an animation being viewed by one of
bodyText ||| these clients.
bodyText ||| The examiner program is loaded by both these simple clients, and
bodyText ||| is about 450 lines long. The examiner supports:
listItem ||| •	Pausing and continuing the animation, and changing the
listItem ||| current animation time using the mouse. Since this is done by
listItem ||| operating on the shared animation handle, changes performed
listItem ||| by any viewer are seen by all. Because of the consistency guar-
listItem ||| antees, all users can freely attempt to change the time, and the
listItem ||| system will maintain all views consistently.
listItem ||| •	A second “overview” window (Figure 5(b)), where a new
listItem ||| camera watches the animation scene and camera from a distant
listItem ||| view. A local graphical child (representing a portion of the
listItem ||| animation camera’s frustum) was added to the shared anima-
listItem ||| tion camera group to let the attributes of the animation camera
listItem ||| be seen in the overview window.
listItem ||| •	A local animation meter (bottom of Figure 5(c)), that can be
listItem ||| added to any window by pressing a key, and which shows the
listItem ||| current time offset into the animation both graphically and
listItem ||| numerically. It was added in front of the camera in the anima-
listItem ||| tion viewer window, as a local child of a GO in the camera
listItem ||| graph, so that it would be fixed to the screen in the animation
listItem ||| viewer.
listItem ||| •	Local editing (Figure 5(d)), so that users can select objects and
listItem ||| make them transparent (to better see what was happening in the
listItem ||| animation) or hide them completely (useful on slow machines,
listItem ||| to speed up rendering). Assorted local feedback (highlighting
listItem ||| the object under the mouse and flashing the selected object)
listItem ||| was done with local property changes to the shared GOs in the
listItem ||| scene graph.
bodyText ||| Given the attention paid to the design of Repo-3D, it was not
bodyText ||| necessary to be overly concerned with the distributed behavior of
bodyText ||| the application (we spent no more than an hour or so). Most of that
bodyText ||| time was spent deciding if a given operation should be global or a
bodyText ||| local variation. The bulk of programming and debugging time was
bodyText ||| spent implementing application code. For example, in the overview
bodyText ||| window, the representation of the camera moves dynamically,
bodyText ||| based on the bounding values of the animation’s scene and camera
bodyText ||| graphs. In editing mode, the property that flashes the selected node
bodyText ||| bases its local color on the current global color (allowing a user
bodyText ||| who is editing while an animation is in progress to see any color
bodyText ||| changes to the selected node.)
sectionHeader ||| 7 CONCLUSIONS AND FUTURE WORK
bodyText ||| We have presented the rationale for, and design of, Repo-3D, a
bodyText ||| general-purpose, object-oriented library for developing distributed,
bodyText ||| interactive 3D graphics applications across a range of heteroge-
bodyText ||| neous workstations. By presenting the programmer with the
bodyText ||| illusion of a large shared memory, using the Shared Data-Object
bodyText ||| model of DSM, Repo-3D makes it easy for programmers to rapidly
bodyText ||| prototype distributed 3D graphics applications using a familiar
bodyText ||| object-oriented programming paradigm. Both graphical and
bodyText ||| general-purpose, non-graphical data can be shared, since Repo-3D
bodyText ||| is embedded in Repo, a general-purpose, lexically-scoped, distrib-
bodyText ||| uted programming language.
bodyText ||| Repo-3D is designed to directly support the distribution of graph-
bodyText ||| ical objects, circumventing the “duplicate database” problem and
bodyText ||| allowing programmers to concentrate on the application function-
bodyText ||| ality of a system, rather than its communication or synchronization
bodyText ||| components. We have introduced a number of issues that must be
bodyText ||| considered when building a distributed 3D graphics library, espe-
bodyText ||| cially concerning efficient and clean support for data distribution
bodyText ||| and local variations of shared graphical scenes, and discussed how
bodyText ||| Repo-3D addresses them.
bodyText ||| There are a number of ways in which Repo-3D could be
bodyText ||| improved. The most important is the way the library deals with
bodyText ||| time. By default, the library assumes all machines are running a
bodyText ||| time-synchronization rotocol, such as NTP, and uses an internal
bodyText ||| animation time offset�(instead of the system-specific time offset)
bodyText ||| because different OSs (e.g., NT vs. UNIX) start counting time at
bodyText ||| different dates. Hooks have been provided to allow a programmer
bodyText ||| to specify their own function to compute the “current” animation
bodyText ||| time offset within a process. Using this facility, it is possible to
bodyText ||| build inter-process time synchronization protocols (which we do),
bodyText ||| but this approach is not entirely satisfactory given our stated goal
bodyText ||| of relieving the programmer of such tedious chores. Future
bodyText ||| systems should integrate more advanced solutions, such as adjust-
bodyText ||| ing time values as they travel between machines, so that users of
bodyText ||| computers with unsynchronized clocks can collaborate8. This will
bodyText ||| become more important as mobile computers increase in popular-
bodyText ||| ity, as it may not be practical to keep their clocks synchronized.
bodyText ||| The specification of local variations in Repo-3D could benefit
bodyText ||| from adopting the notion of paths (as used in Java 3D and Inventor,
bodyText ||| for example). A path is an array of objects leading from the root of
bodyText ||| the graph to an object; when an object occurs in multiple places in
bodyText ||| one or more scene graphs, paths allow these instances to be differ-
bodyText ||| entiated. By specifying local variations using paths, nodes in the
bodyText ||| shared scene graphs could have variations within a process as well
bodyText ||| as between processes. One other limitation of Repo-3D, arising
bodyText ||| from our use of the Replicated Object package, is that there is no
bodyText ||| way to be notified when local variations are applied to an object.
bodyText ||| Recall that the methods of an automatically generated Notification
bodyText ||| Object correspond to the update methods of the corresponding
bodyText ||| Replicated Object. Since the methods that manipulate the local
bodyText ||| variations are non-update methods (i.e., they do not modify the
bodyText ||| replicated state), there are no corresponding methods for them in
bodyText ||| the Notification Objects. Of course, it would be relatively straight-
bodyText ||| forward to modify the Replicated Object package to support this,
bodyText ||| but we have not yet found a need for these notifiers.
bodyText ||| A more advanced replicated object system would also improve
bodyText ||| the library. Most importantly, support for different consistency
bodyText ||| semantics would be extremely useful. If we could specify
bodyText ||| semantics such as “all updates completely define the state of an
bodyText ||| object, and only the last update is of interest,” the efficiency of the
bodyText ||| distribution of property values would improve significantly; in this
bodyText ||| case, updates could be applied (or discarded) when they arrive,
bodyText ||| without waiting for all previous updates to be applied, and could be
bodyText ||| applied locally without waiting for the round trip to the sequencer.
bodyText ||| There are also times when it would be useful to have support for
bodyText ||| consistency across multiple objects, either using causal ordering
bodyText ||| (as provided by systems such as ISIS and Visual-Obliq), or some
bodyText ||| kind of transaction protocol to allow large groups of changes to be
bodyText ||| applied either as a unit, or not at all. It is not clear how one would
bodyText ||| provide these features with a replicated object system such as the
bodyText ||| one used here.
bodyText ||| While a library such as Repo-3D could be built using a variety of
bodyText ||| underlying platforms, the most likely one for future work is Java.
bodyText ||| Java shares many of the advantages of Modula-3 (e.g., threads and
bodyText ||| garbage collection are common across all architectures) and the
footnote ||| 7. Computed as an offset from January 1, 1997.
footnote ||| 8. Implementation details of the combination of Network and Replicated
footnote ||| Objects made it difficult for us to adopt a more advanced solution.
bodyText ||| packages needed to create a Repo-3D-like toolkit are beginning to
bodyText ||| appear. While Java does not yet have a replicated object system as
bodyText ||| powerful as the Replicated Object package, a package such as
bodyText ||| JSDT [36] (which focuses more on data communication than high-
bodyText ||| level object semantics) may be a good starting point. Work is also
bodyText ||| being done on interpreted, distributed programming languages on
bodyText ||| top of Java (e.g., Ambit [9]). Finally, Java 3D is very similar to
bodyText ||| Anim-3D, even though its design leans toward efficiency instead of
bodyText ||| generality when there are trade-offs to be made. For example, the
bodyText ||| designers chose to forgo Anim-3D’s general property inheritance
bodyText ||| mechanism because it imposes computational overhead. By com-
bodyText ||| bining packages such as Java 3D, JSDT, and Ambit, it should be
bodyText ||| possible to build a distributed graphics library such as Repo-3D in
bodyText ||| Java.
sectionHeader ||| Acknowledgments
bodyText ||| We would like to thank the reviewers for their helpful comments,
bodyText ||| as well as the many other people who have contributed to this
bodyText ||| project. Andreas Butz ported CATHI to use Repo-3D and helped
bodyText ||| with the examples and the video. Clifford Beshers participated in
bodyText ||| many lively discussions about the gamut of issues dealing with
bodyText ||| language-level support for 3D graphics. Tobias Höllerer and
bodyText ||| Steven Dossick took part in many other lively discussions. Xinshi
bodyText ||| Sha implemented many of the extensions to Obliq-3D that went
bodyText ||| into Repo-3D. Luca Cardelli and Marc Najork of DEC SRC
bodyText ||| created Obliq and Obliq-3D, and provided ongoing help and
bodyText ||| encouragement over the years that Repo and Repo-3D have been
bodyText ||| evolving.
bodyText ||| This research was funded in part by the Office of Naval Research
bodyText ||| under Contract N00014-97-1-0838 and the National Tele-Immer-
bodyText ||| sion Initiative, and by gifts of software from Critical Mass and
bodyText ||| Microsoft.
sectionHeader ||| References
reference ||| [1] D. B. Anderson, J. W. Barrus, J. H. Howard, C. Rich, C. Shen, and
reference ||| R. C. Waters. Building Multi-User Interactive Multimedia Environ-
reference ||| ments at MERL. Technical Report Research Report TR95-17, Mit-
reference ||| subishi Electric Research Laboratory, November 1995.
reference ||| [2] H. Bal, M. Kaashoek, and A. Tanenbaum. Orca: A Language for
reference ||| Parallel Programming of Distributed Systems. IEEE Transactions on
reference ||| Software Engineering, 18(3):190–205, March 1992.
reference ||| [3] K. Bharat and L. Cardelli. Migratory Applications. In ACM UIST '95,
reference ||| pages 133-142, November 1995.
reference ||| [4] K. P. Birman. The Process Group Approach to Reliable Distributed
reference ||| Computing. CACM, 36(12):36–53, Dec 1993.
reference ||| [5] A. Birrell, G. Nelson, S. Owicki, and E. Wobber. Network Objects.
reference ||| In Proc. 14th ACM Symp. on Operating Systems Principles, 1993.
reference ||| [6] A Butz, Animation with CATHI, In Proceedings ofAAAI/IAAI '97,
reference ||| pages 957–962, 1997.
reference ||| [7]	J. Calvin, A. Dickens, B. Gaines, P. Metzger, D. Miller, and
reference ||| D. Owen. The SIMNET Virtual World Architecture. In Proc. IEEE
reference ||| VRAIS ’93, pages 450–455, Sept 1993.
reference ||| [8] L. Cardelli. A Language with Distributed Scope. Computing Sys-
reference ||| tems, 8(1):27–59, Jan 1995.
reference ||| [9] L. Cardelli and A. Gordon. Mobile Ambients. In Foundations of
reference ||| Software Science and Computational Structures, Maurice Nivat
reference ||| (Ed.), LNCE 1378, Springer, 140–155. 1998.
reference ||| [10] R. Carey and G. Bell. The Annotated VRML 2.0 Reference Manual.
reference ||| Addison-Wesley, Reading, MA, 1997.
reference ||| [11] C. Carlsson and O. Hagsand. DIVE—A Multi-User Virtual Reality
reference ||| System. In Proc. IEEE VRAIS ’93, pages 394–400, Sept 1993.
reference ||| [12] C. F. Codella, R. Jalili, L. Koved, and J. B. Lewis. A Toolkit for
reference ||| Developing Multi-User, Distributed Virtual Environments. In Proc.
reference ||| IEEE VRAIS ’93, pages 401–407, Sept 1993.
reference ||| [13] C. Elliott, G. Schechter, R. Yeung and S. Abi-Ezzi. TBAG: A High
reference ||| Level Framework for Interactive, Animated 3D Graphics
reference ||| Applications, In Proc. ACM SIGGRAPH 94, pages 421–434, August,
reference ||| 1994.
reference ||| [14] M. Fairen and A. Vinacua, ATLAS, A Platform for Distributed
reference ||| Graphics Applications, In Proc. VI Eurographics Workshop on Pro-
reference ||| gramming Paradigms in Graphics, pages 91–102, September, 1997.
reference ||| [15] S. Feiner, B. MacIntyre, M. Haupt, and E. Solomon. Windows on the
reference ||| World: 2D Windows for 3D Augmented Reality. In Proc. ACM UIST
reference ||| ’93, pages 145–155, 1993.
reference ||| [16] T. A. Funkhouser. RING: A Client-Server System for Multi-User
reference ||| Virtual Environments. In Proc. 1995 ACM Symp. on Interactive 3D
reference ||| Graphics, pages 85–92, March 1995.
reference ||| [17] G. Grimsdale. dVS—Distributed Virtual Environment System. In
reference ||| Proc. Computer Graphics ’91 Conference, 1991.
reference ||| [18] S. P. Harbison. Modula-3. Prentice-Hall, 1992.
reference ||| [19] H.W. Holbrook, S.K. Singhal and D.R. Cheriton, Log-Based
reference ||| Receiver-Reliable Multicast for Distributed Interactive Simulation,
reference ||| Proc. ACM SIGCOMM ’95, pages 328–341, 1995.
reference ||| [20] W. Levelt, M. Kaashoek, H. Bal, and A. Tanenbaum. A Comparison
reference ||| of Two Paradigms for Distributed Shared Memory. Software
reference ||| Practice and Experience, 22(11):985–1010, Nov 1992.
reference ||| [21] B. Lucas. A Scientific Visualization Renderer. In Proc. IEEE
reference ||| Visualization '92, pp. 227-233, October 1992.
reference ||| [22] V. Machiraju, A Framework for Migrating Objects in Distributed
reference ||| Graphics Applications, Masters Thesis, University of Utah, Depart-
reference ||| ment of Computer Science, Salt Lake City, UT, June, 1997.
reference ||| [23] B. MacIntyre. Repo: Obliq with Replicated Objects. Programmers
reference ||| Guide and Reference Manual. Columbia University Computer
reference ||| Science Department Research Report CUCS-023-97, 1997.}
reference ||| [24] B. MacIntyre, and S. Feiner. Language-level Support for Exploratory
reference ||| Programming of Distributed Virtual Environments. In Proc. ACM
reference ||| UIST ’96, pages 83–94, Seattle, WA, November 6–8, 1996.
reference ||| [25] M. A. Najork and M. H. Brown. Obliq-3D: A High-level, Fast-turn-
reference ||| around 3D Animation System. IEEE Transactions on Visualization
reference ||| and Computer Graphics, 1(2):175–145, June 1995.
reference ||| [26] R. Ben-Natan. CORBA: A Guide to the Common Object Request
reference ||| Broker Architecture, McGraw Hill, 1995.
reference ||| [27] D. Phillips, M. Pique, C. Moler, J. Torborg, D. Greenberg. Distribut-
reference ||| ed Graphics: Where to Draw the Lines? Panel Transcript,
reference ||| SIGGRAPH 89, available at:
reference ||| http://www.siggraph.org:443/publications/panels/siggraphi89/
reference ||| [28] A. Prakash and H. S. Shim. DistView: Support for Building Efficient
reference ||| Collaborative Applications Using Replicated Objects. In Proc. ACM
reference ||| CSCW ’94, pages 153–162, October 1994.
reference ||| [29] J. Rohlf and J. Helman, IRIS Performer: A High Performance
reference ||| Multiprocessing Toolkit for Real-Time {3D} Graphics, In Proc.
reference ||| ACM SIGGRAPH 94, pages 381–394, 1994.
reference ||| [30] M. Roseman and S. Greenberg. Building Real-Time Groupware with
reference ||| GroupKit, a Groupware Toolkit. ACM Transactions on Computer-
reference ||| Human Interaction, 3(1):66–106, March 1996.
reference ||| [31] C. Shaw and M. Green. The MR Toolkit Peers Package and
reference ||| Experiment. In Proc. IEEE VRAIS ’93, pages 18–22, Sept 1993.
reference ||| [32] G. Singh, L. Serra, W. Png, A. Wong, and H. Ng. BrickNet: Sharing
reference ||| Object Behaviors on the Net. In Proc. IEEE VRAIS ’95, pages 19–25,
reference ||| 1995.
reference ||| [33] H. Sowizral, K. Rushforth, and M. Deering. The Java 3D API
reference ||| Specification, Addison-Wesley, Reading, MA, 1998.
reference ||| [34] M. Stefik, G. Foster, D. G. Bobrow, K. Kahn, S. Lanning, and
reference ||| L. Suchman. Beyond The Chalkboard: Computer Support for
reference ||| Collaboration and Problem Solving in Meetings. CACM, 30(1):32–
reference ||| 47, January 1987.
reference ||| [35] P. S. Strauss and R. Carey, An Object-Oriented 3D Graphics Toolkit,
reference ||| In Computer Graphics (Proc. ACM SIGGRAPH 92), pages 341–349,
reference ||| Aug, 1992.
reference ||| [36] Sun Microsystems, Inc. The Java Shared Data Toolkit, 1998.
reference ||| Unsupported software, available at:
reference ||| http://developer.javasoft.com/developer/earlyAccess/jsdt/
reference ||| [37] I. Tou, S. Berson, G. Estrin, Y. Eterovic, and E. Wu. Prototyping
reference ||| Synchronous Group Applications. IEEE Computer, 27(5):48–56,
reference ||| May 1994.
reference ||| [38] R. Waters and D. Anderson. The Java Open Community Version 0.9
reference ||| Application Program Interface. Feb, 1997. Available online at:
reference ||| http://www.merl.com/opencom/opencom-java-api.html
reference ||| [39] A. Wollrath, R. Riggs, and J. Waldo. A Distributed Object Model for
reference ||| the Java System, In Proc. USENIX COOTS ’96, pages 219–231, July
reference ||| 1996.
reference ||| [40] R. Zeleznik, D. Conner, M. Wloka, D. Aliaga, N. Huang,
reference ||| P. Hubbard, B. Knep, H. Kaufman, J. Hughes, and A. van Dam. An
reference ||| Object-oriented Framework for the Integration of Interactive
reference ||| Animation Techniques. In Computer Graphics (SIGGRAPH '91
reference ||| Proceedings), pages 105–112, July, 1991.
reference ||| [41 ] M. J. Zyda, D. R. Pratt, J. G. Monahan, and K. P. Wilson. NPSNET:
reference ||| Constructing a 3D Virtual World. In Proc. 1992 ACM Symp. on
reference ||| Interactive 3D Graphics, pages 147–156, Mar. 1992.
