Bayesian Unsupervised Word Segmentation with |XML| xmlLoc_0 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_begin xmlFontSize_largest-1 xmlFontSizeChange_begin xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Nested Pitman-Yor Language Modeling |XML| xmlLoc_0 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-1 xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Daichi Mochihashi Takeshi Yamada Naonori Ueda |XML| xmlLoc_0 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_smaller xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
NTT Communication Science Laboratories |XML| xmlLoc_0 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Hikaridai 2-4, Keihanna Science City, Kyoto, Japan |XML| xmlLoc_0 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
{daichi,yamada,ueda}@cslab.kecl.ntt.co.jp |XML| xmlLoc_1 xmlAlign_centered xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Abstract |XML| xmlLoc_1 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_largest-2 xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In this paper, we propose a new Bayesian  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
model for fully unsupervised word seg- |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
mentation and an efficient blocked Gibbs  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
sampler combined with dynamic program- |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
ming for inference. Our model is a nested  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
hierarchical Pitman-Yor language model,  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
where Pitman-Yor spelling model is em- |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
bedded in the word model. We confirmed  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
that it significantly outperforms previous  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
reported results in both phonetic tran- |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
scripts and standard datasets for Chinese  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
and Japanese word segmentation. Our  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
model is also considered as a way to con- |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
struct an accurate word n-gram language  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
model directly from characters of arbitrary  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
language, without any “word” indications. |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
1 Introduction |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
“Word” is no trivial concept in many languages.  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Asian languages such as Chinese and Japanese  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
have no explicit word boundaries, thus word seg- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
mentation is a crucial first step when processing  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
them. Even in western languages, valid “words”  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
are often not identical to space-separated tokens.  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
For example, proper nouns such as “United King- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
dom” or idiomatic phrases such as “with respect  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
to” actually function as a single word, and we of- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ten condense them into the virtual words “UK”  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and “w.r.t.”. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In order to extract “words” from text streams,  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
unsupervised word segmentation is an important  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
research area because the criteria for creating su- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
pervised training data could be arbitrary, and will  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
be suboptimal for applications that rely on seg- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
mentations. It is particularly difficult to create  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
“correct” training data for speech transcripts, col- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
loquial texts, and classics where segmentations are  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
often ambiguous, let alone is impossible for un- |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
known languages whose properties computational  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
linguists might seek to uncover. |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
From a scientific point of view, it is also inter- |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
esting because it can shed light on how children  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
learn “words” without the explicitly given bound- |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
aries for every word, which is assumed by super- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
vised learning approaches. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Lately, model-based methods have been intro- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
duced for unsupervised segmentation, in particu- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
lar those based on Dirichlet processes on words  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(Goldwater et al., 2006; Xu et al., 2008). This  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
maximizes the probability of word segmentation  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
w given a string s : |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
w� = argmax p(w|s) • (1) |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
W |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
This approach often implicitly includes heuristic  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
criteria proposed so far&apos;, while having a clear sta- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tistical semantics to find the most probable word  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
segmentation that will maximize the probability of  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the data, here the strings. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
However, they are still naive with respect to  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word spellings, and the inference is very slow ow- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ing to inefficient Gibbs sampling. Crucially, since  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
they rely on sampling a word boundary between  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
two neighboring words, they can leverage only up  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
to bigram word dependencies. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In this paper, we extend this work to pro- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
pose a more efficient and accurate unsupervised  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word segmentation that will optimize the per- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
formance of the word n-gram Pitman-Yor (i.e.  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Bayesian Kneser-Ney) language model, with an  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
accurate character oc-gram Pitman-Yor spelling  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
model embedded in word models. Further- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
more, it can be viewed as a method for building  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a high-performance n-gram language model di- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
rectly from character strings of arbitrary language.  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
It is carefully smoothed and has no “unknown  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
words” problem, resulting from its model struc- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ture. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
This paper is organized as follows. In Section 2, |XML| xmlLoc_6 xmlAlign_right xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
&apos;For instance, TANGO algorithm (Ando and Lee, 2003) |XML| xmlLoc_7 xmlAlign_right xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
essentially finds segments such that character n-gram proba- |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
bilities are maximized blockwise, averaged over n. |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
100 |XML| xmlLoc_7 xmlAlign_none xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Proceedings of the 47th Annual Meeting of the ACL and the 4th IJCNLP of the AFNLP, pages 100–108, |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Suntec, Singapore, 2-7 August 2009. c�2009 ACL and AFNLP |XML| xmlLoc_7 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(a) Generating n-gram distributions G hierarchically (b) Equivalent representation using a hierarchical Chinese  |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
from the Pitman-Yor process. Here, n = 3.	Restaurant process. Each word in a training text is a “customer” |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
shown in italic, and added to the leaf of its two words context. |XML| xmlLoc_1 xmlAlign_right xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Figure 1: Hierarchical Pitman-Yor Language Model. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
we briefly describe a language model based on the  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Pitman-Yor process (Teh, 2006b), which is a gen- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
eralization of the Dirichlet process used in previ- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ous research. By embedding a character n-gram  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
in word n-gram from a Bayesian perspective, Sec- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tion 3 introduces a novel language model for word  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
segmentation, which we call the Nested Pitman- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Yor language model. Section 4 describes an ef- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ficient blocked Gibbs sampler that leverages dy- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
namic programming for inference. In Section 5 we  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
describe experiments on the standard datasets in  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Chinese and Japanese in addition to English pho- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
netic transcripts, and semi-supervised experiments  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
are also explored. Section 6 is a discussion and  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Section 7 concludes the paper. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
2 Pitman-Yor process and n-gram  |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
models |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
To compute a probability p(wIs) in (1), we adopt  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a Bayesian language model lately proposed by  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(Teh, 2006b; Goldwater et al., 2005) based on  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the Pitman-Yor process, a generalization of the  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Dirichlet process. As we shall see, this is a  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Bayesian theory of the best-performing Kneser- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Ney smoothing of n-grams (Kneser and Ney,  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
1995), allowing an integrated modeling from a  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Bayesian perspective as persued in this paper. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
The Pitman-Yor (PY) process is a stochastic  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
process that generates discrete probability distri- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
bution G that is similar to another distribution G0,  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
called a base measure. It is written as |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
G — PY(G0, d, 0) , (2) |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
where d is a discount factor and 0 controls how  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
similar G is to G0 on average. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Suppose we have a unigram word distribution  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
G1 = { p(•) } where • ranges over each word in the  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
lexicon. The bigram distribution G2 = { p(• Iv) }  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
given a word v is different from G1, but will be  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
similar to G1 especially for high frequency words.  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Therefore, we can generate G2 from a PY pro- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
cess of base measure G1, as G2 — PY(G1, d, 0).  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Similarly, trigram distribution G3 = { p(• Iv&apos;v) } |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
given an additional word v&apos; is generated as G3 — |XML| xmlLoc_2 xmlAlign_centered xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
PY(G2, d, 0), and G1, G2, G3 will form a tree  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
structure shown in Figure 1(a). |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In practice, we cannot observe G directly be- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
cause it will be infinite dimensional distribution  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
over the possible words, as we shall see in this  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
paper. However, when we integrate out G it is  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
known that Figure 1(a) can be represented by an  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
equivalent hierarchical Chinese Restaurant Pro- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
cess (CRP) (Aldous, 1985) as in Figure 1(b). |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In this representation, each n-gram context h  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(including the null context c for unigrams) is  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a Chinese restaurant whose customers are the  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
n-gram counts c(wIh) seated over the tables  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
1 • • • thw. The seatings has been incrementally  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
constructed by choosing the table k for each count  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
in c(wIh) with probability proportional to |XML| xmlLoc_5 xmlAlign_none xmlFontFace_different xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
�chwk − |XML| xmlLoc_5 xmlAlign_right xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
0+dt |XML| xmlLoc_5 xmlAlign_right xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
d (k = 1,•• • , thw) |XML| xmlLoc_5 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
h. (k = new) ,	(3) |XML| xmlLoc_5 xmlAlign_left xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_none xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
where chwk is the number of customers seated at  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
table k thus far and th. = Ew thw is the total num- |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
ber of tables in h. When k = new is selected,  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
thw is incremented, and this means that the count  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
was actually generated from the shorter context h&apos;.  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Therefore, in that case a proxy customer is sent to  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
the parent restaurant and this process will recurse.  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
For example, if we have a sentence “she will  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
sing” in the training data for trigrams, we add each  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
word “she” “will” “sing” “$” as a customer to its  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
two preceding words context node, as described  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
in Figure 1(b). Here, “$” is a special token rep- |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
resenting a sentence boundary in language model- |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_none xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
101 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
ing (Brown et al., 1992). |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
As a result, the n-gram probability of this hier- |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
archical Pitman-Yor language model (HPYLM) is  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
recursively computed as |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
p(wI h) = c(wB+c(h)thw + 0+c(h) p(wI h&apos;), |XML| xmlLoc_0 xmlAlign_centered xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(4)  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
where p(wIh&apos;) is the same probability using a  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
(n−1)-gram context h&apos;. When we set thw - 1, (4)  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
recovers a Kneser-Ney smoothing: thus a HPYLM  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
is a Bayesian Kneser-Ney language model as well  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
as an extension of the hierarchical Dirichlet Pro- |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
cess (HDP) used in Goldwater et al. (2006). 0, d  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
are hyperparameters that can be learned as Gamma  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
and Beta posteriors, respectively, given the data.  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
For details, see Teh (2006a). |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
The inference of this model interleaves adding  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and removing a customer to optimize thw, d, and  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
0 using MCMC. However, in our case “words”  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
are not known a priori: the next section describes  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
how to accomplish this by constructing a nested  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
HPYLM of words and characters, with the associ- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ated inference algorithm. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
3 Nested Pitman-Yor Language Model |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Thus far we have assumed that the unigram G1  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
is already given, but of course it should also be  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
generated as G1 — PY(G0, d, 0). |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Here, a problem occurs: What should we use for  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
G0, namely the prior probabilities over words2.  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
If a lexicon is finite, we can use a uniform prior  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
G0 (w) = 1/ I V I for every word w in lexicon V.  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
However, with word segmentation every substring  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
could be a word, thus the lexicon is not limited but  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
will be countably infinite. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Building an accurate G0 is crucial for word  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
segmentation, since it determines how the possi- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ble words will look like. Previous work using a  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Dirichlet process used a relatively simple prior for  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
G0, namely an uniform distribution over charac- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ters (Goldwater et al., 2006), or a prior solely de- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
pendent on word length with a Poisson distribution  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
whose parameter is fixed by hand (Xu et al., 2008). |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In contrast, in this paper we use a simple but  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
more elaborate model, that is, a character n-gram  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
language model that also employs HPYLM. This  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
is important because in English, for example,  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
words are likely to end in ‘–tion’ and begin with |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
2Note that this is different from unigrams, which are pos- |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
terior distribution given data. |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Figure 2: Chinese restaurant representation of our  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Nested Pitman-Yor Language Model (NPYLM). |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
‘re–’, but almost never end in ‘–tio’ nor begin with  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
‘sre–’ 3. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Therefore, we use |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
G0 (w) = p(c1 ••• ck)	(5) |XML| xmlLoc_2 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
p( ci I c1 ••• ci�1)	(6) |XML| xmlLoc_2 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
where string c1 • • • ck is a spelling of w, and |XML| xmlLoc_2 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
p(ciIc1 • • • ci�1) is given by the character HPYLM  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
according to (4). |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
This language model, which we call Nested  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Pitman-Yor Language Model (NPYLM) hereafter,  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
is the hierarchical language model shown in Fig- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ure 2, where the character HPYLM is embedded  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
as a base measure of the word HPYLM.4 As the  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
final base measure for the character HPYLM, we  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
used a uniform prior over the possible characters  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
of a given language. To avoid dependency on n-  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
gram order n, we actually used the oc-gram lan- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
guage model (Mochihashi and Sumita, 2007), a  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
variable order HPYLM, for characters. However,  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
for generality we hereafter state that we used the  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
HPYLM. The theory remains the same for oc- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
grams, except sampling or marginalizing over n  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
as needed. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Furthermore, we corrected (5) so that word  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
length will have a Poisson distribution whose pa- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
rameter can now be estimated for a given language  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and word type. We describe this in detail in Sec- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tion 4.3. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Chinese Restaurant Representation |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In our NPYLM, the word model and the charac- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ter model are not separate but connected through  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a nested CRP. When a word w is generated from  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
its parent at the unigram node, it means that w |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
3Imagine we try to segment an English character string  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
“itisrecognizedasthe• • • .” |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
4Strictly speaking, this is not “nested” in the sense of a  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Nested Dirichlet process (Rodriguez et al., 2008) and could  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
be called “hierarchical HPYLM”, which denotes another  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
model for domain adaptation (Wood and Teh, 2008). |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
= |XML| xmlLoc_2 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
�k  |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
i=1 |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
102 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
is drawn from the base measure, namely a char- |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
acter HPYLM. Then we divide w into characters  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
c1•••ck to yield a “sentence” of characters and  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
feed this into the character HPYLM as data. |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Conversely, when a table becomes empty, this  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
means that the data associated with the table are  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
no longer valid. Therefore we remove the corre- |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
sponding customers from the character HPYLM  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
using the inverse procedure of adding a customer  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
in Section 2. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
All these processes will be invoked when a  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
string is segmented into “words” and customers  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
are added to the leaves of the word HPYLM. To  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
segment a string into “words”, we used efficient  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
dynamic programming combined with MCMC, as  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
described in the next section. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
4 Inference |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
To find the hidden word segmentation w of a string  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
s = c1 • • • cN, which is equivalent to the vector of  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
binary hidden variables z = z1 • • • zN, the sim- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
plest approach is to build a Gibbs sampler that ran- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
domly selects a character ci and draw a binary de- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
cision zi as to whether there is a word boundary,  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and then update the language model according to  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the new segmentation (Goldwater et al., 2006; Xu  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
et al., 2008). When we iterate this procedure suf- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ficiently long, it becomes a sample from the true  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
distribution (1) (Gilks et al., 1996). |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
However, this sampler is too inefficient since  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
time series data such as word segmentation have a  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
very high correlation between neighboring words.  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
As a result, the sampler is extremely slow to con- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
verge. In fact, (Goldwater et al., 2006) reports that  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the sampler would not mix without annealing, and  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the experiments needed 20,000 times of sampling  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
for every character in the training data. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Furthermore, it has an inherent limitation that  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
it cannot deal with larger than bigrams, because it  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
uses only local statistics between directly contigu- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ous words for word segmentation. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
4.1 Blocked Gibbs sampler |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Instead, we propose a sentence-wise Gibbs sam- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
pler of word segmentation using efficient dynamic  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
programming, as shown in Figure 3. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In this algorithm, first we randomly select a  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
string, and then remove the “sentence” data of its  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word segmentation from the NPYLM. Sampling  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a new segmentation, we update the NPYLM by  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
adding a new “sentence” according to the new seg- |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
 1: for j=1 ••• Jdo |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
2:	for s in randperm (s 1 , • • • , sD) do |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
3:	if j &gt; 1 then |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
4:	Remove customers of w(s) from O |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
5:	end if |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
6:	Draw w(s) according to p(w1s, O) |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
7:	Add customers of w(s) to O |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
8:	end for |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
9: Sample hyperparameters of O |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
10: end for |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
Figure 3: Blocked Gibbs Sampler of NPYLM O. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
mentation. When we repeat this process, it is ex- |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
pected to mix rapidly because it implicitly consid- |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ers all possible segmentations of the given string  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
at the same time. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
This is called a blocked Gibbs sampler that sam- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ples z block-wise for each sentence. It has an ad- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ditional advantage in that we can accommodate  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
higher-order relationships than bigrams, particu- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
larly trigrams, for word segmentation. 5 |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
4.2 Forward-Backward inference |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Then, how can we sample a segmentation w for  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
each string s? In accordance with the Forward fil- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tering Backward sampling of HMM (Scott, 2002),  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
this is achieved by essentially the same algorithm  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
employed to sample a PCFG parse tree within  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
MCMC (Johnson et al., 2007) and grammar-based  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
segmentation (Johnson and Goldwater, 2009). |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Forward Filtering. For this purpose, we main- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tain a forward variable a[t] [k] in the bigram case.  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a[t][k] is the probability of a string c1 • • • ct with  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the final k characters being a word (see Figure 4).  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Segmentations before the final k characters are  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
marginalized using the following recursive rela- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tionship: |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
p(ctt—k+11 ct—k |XML| xmlLoc_5 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
t—k—j+1) •a[t—k] [j] (7) |XML| xmlLoc_5 xmlAlign_right xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
where a[0][0] =1 and we wrote cr,, • • • cm as cmn .6  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
The rationale for (7) is as follows. Since main- |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
taining binary variables z1, • • • , zN is equivalent  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
to maintaining a distance to the nearest backward |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
5In principle fourgrams or beyond are also possible, but  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
will be too complex while the gain will be small. For this  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
purpose, Particle MCMC (Doucet et al., 2009) is promising  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
but less efficient in a preliminary experiment. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
6As Murphy (2002) noted, in semi-HMM we cannot use a  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
standard trick to avoid underflow by normalizing a [t] [k] into |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
p(k�t), since the model is asynchronous. Instead we always |XML| xmlLoc_7 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
compute (7) using logsumexp () . |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a [t] [k] = �t—k |XML| xmlLoc_5 xmlAlign_right xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
j=1 |XML| xmlLoc_5 xmlAlign_right xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
103 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Figure 4: Forward filtering of a[t][k] to marginal- |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ize out possible segmentations j before t — k. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
1: fort= 1toNdo |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
2: for k = max(1, t—L) to t do |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
3:	Compute �[t] [k] according to (7). |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
4: end for |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
5: end for |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
6: Initialize t +— N, i +— 0, w0 +— $ |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
7: while t &gt; 0 do |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
8:	Draw k oc p(wi Ictt—k+1 , 0) • �[t] [k] |XML| xmlLoc_2 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
9:	Set wi +— ctt—k+1 |XML| xmlLoc_2 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
10:	Set t +— t — k, i +— i + 1 |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
11: end while |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
12: Return w = wi, wi—1, • • • , w1. |XML| xmlLoc_2 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_yes xmlIndent_no
Figure 5: Forward-Backward sampling of word  |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
segmentation w. (in bigram case) |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word boundary for each t as qt, we can write |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
�[t] [k] =p(ct1 , qt = k)	(8) |XML| xmlLoc_3 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
=p(ct1,qt=k,qt—k=j)	(9) |XML| xmlLoc_3 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
X9 |XML| xmlLoc_4 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
=t—k t |XML| xmlLoc_4 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
p(c1 , ct—k+1 , qt = k, qt—k = j) (10) |XML| xmlLoc_4 xmlAlign_right xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
9 |XML| xmlLoc_4 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
= X p(ctt—k+1 I c1 k)p(c1—k , qt—k = j)(11) |XML| xmlLoc_4 xmlAlign_right xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
9 |XML| xmlLoc_4 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
=Xp(ctt—k+1I c1 k)a[t—k][j] ,	(12) |XML| xmlLoc_4 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
9 |XML| xmlLoc_4 xmlAlign_left xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
where we used conditional independency of qt |XML| xmlLoc_5 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
given qt—k and uniform prior over qt in (11) above. |XML| xmlLoc_5 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Backward Sampling. Once the probability ta- |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ble �[t] [k] is obtained, we can sample a word seg- |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
mentation backwards. Since � [N] [k] is a marginal  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
probability of string c�1 with the last k charac- |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ters being a word, and there is always a sentence  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
boundary token $ at the end of the string, with |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
probability proportional to p($ I cN—k) • � [N] [k] we |XML| xmlLoc_6 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
can sample k to choose the boundary of the final  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word. The second final word is similarly sampled  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
using the probability of preceding the last word  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
just sampled: we continue this process until we  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
arrive at the beginning of the string (Figure 5). |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Trigram case. For simplicity, we showed the  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
algorithm for bigrams above. For trigrams, we |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
maintain a forward variable �[t] [k] [j], which rep- |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
resents a marginal probability of string c1 • • • ct  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
with both the final k characters and further j  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
characters preceding it being words. Forward-  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Backward algorithm becomes complicated thus  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
omitted, but can be derived following the extended  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
algorithm for second order HMM (He, 1988). |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Complexity This algorithm has a complexity of  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
O (NL2) for bigrams and O (NL3) for trigrams  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
for each sentence, where N is the length of the  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
sentence and L is the maximum allowed length of  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a word (&lt; N). |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
4.3 Poisson correction |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Po(kIA) = e—A �1 .	(13) |XML| xmlLoc_3 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
k |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
Since the appearance of c1 • • • ck is equivalent  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
to that of length k and the content, by making the  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
character n-gram model explicit as O we can set |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
p(c1 ••• ck) = p(c1 ••• ck, k)	(14) |XML| xmlLoc_3 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
p(c1 ••• ck, kI�) |XML| xmlLoc_4 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
p(kI �)	Po(kIA) (15) |XML| xmlLoc_4 xmlAlign_left xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
= |XML| xmlLoc_4 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
where p(c1 • • • ck, kI0) is an n-gram probabil- |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ity given by (6), and p(kI0) is a probability  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
that a word of length k will be generated from  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
O. While previous work used p(kI0) = (1 —  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
p($))k—1p($), this is only true for unigrams. In- |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
stead, we employed a Monte Carlo method that  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
generates words randomly from O to obtain the  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
empirical estimates of p(kI0). |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Estimating A. Of course, we do not leave A as a  |XML| xmlLoc_5 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
constant. Instead, we put a Gamma distribution |XML| xmlLoc_5 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a |XML| xmlLoc_5 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
p(A) =Ga(a, b) =  a F(a) A —1 e—ba	(16) |XML| xmlLoc_6 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
to estimate A from the data for given language  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and word type.7 Here, F(x) is a Gamma function  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and a, b are the hyperparameters chosen to give a  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
nearly uniform prior distribution.$ |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
7We used different A for different word types, such as dig- |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
its, alphabets, hiragana, CJK characters, and their mixtures.  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
W is a set of words of each such type, and (13) becomes a  |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
mixture of Poisson distributions in this case. |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
8In the following experiments, we set a = 0.2, b = 0.1. |XML| xmlLoc_7 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
As Nagata (1996) noted, when only (5) is used in- |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
adequately low probabilities are assigned to long  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
words, because it has a largely exponential dis- |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
tribution over length. To correct this, we assume  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
that word length k has a Poisson distribution with  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
a mean A: |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
104 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Denoting W as a set of “words” obtained from  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word segmentation, the posterior distribution of A  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
used for (13) is |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
p(AIW) a p(W I A)p(A) |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
1: |XML| xmlLoc_0 xmlAlign_right xmlFontFace_different xmlFontFaceChange_no xmlFontSize_largest0 xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
= Ga (a+ 1: t(w) I w I , b+ |XML| xmlLoc_0 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
wEW wEW |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_different xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_yes
where t(w) is the number of times word w is gen- |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
erated from the character HPYLM, i.e. the number  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
of tables tew for w in word unigrams. We sampled  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
A from this posterior for each Gibbs iteration. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
5 Experiments |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
To validate our model, we conducted experiments  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
on standard datasets for Chinese and Japanese  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
word segmentation that are publicly available, as  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
well as the same dataset used in (Goldwater et al.,  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
2006). Note that NPYLM maximizes the probabil- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ity of strings, equivalently, minimizes the perplex- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ity per character. Therefore, the recovery of the  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
“ground truth” that is not available for inference is  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a byproduct in unsupervised learning. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Since our implementation is based on Unicode  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and learns all hyperparameters from the data, we  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
also confirmed that NPYLM segments the Arabic  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Gigawords equally well. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
5.1 English phonetic transcripts |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In order to directly compare with the previously  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
reported result, we first used the same dataset  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
as Goldwater et al. (2006). This dataset con- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
sists of 9,790 English phonetic transcripts from  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
CHILDES data (MacWhinney and Snow, 1985). |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Since our algorithm converges rather fast, we  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ran the Gibbs sampler of trigram NPYLM for 200  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
iterations to obtain the results in Table 1. Among  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the token precision (P), recall (R), and F-measure  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(F), the recall is especially higher to outperform  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the previous result based on HDP in F-measure.  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Meanwhile, the same measures over the obtained  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
lexicon (LP, LR, LF) are not always improved.  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Moreover, the average length of words inferred  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
was surprisingly similar to ground truth: 2.88,  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
while the ground truth is 2.87. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Table 2 shows the empirical computational time  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
needed to obtain these results. Although the con- |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
vergence in MCMC is not uniquely identified, im- |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
provement in efficiency is also outstanding. |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
5.2 Chinese and Japanese word segmentation |XML| xmlLoc_7 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
To show applicability beyond small phonetic tran- |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
scripts, we used standard datasets for Chinese and |XML| xmlLoc_7 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Model	P	R	F	LP	LR	LF |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
NPY(3)	74.8	75.2	75.0	47.8	59.7	53.1 |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
NPY(2)	74.8	76.7	75.7	57.3	56.6	57.0 |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
HDP(2)	75.2	69.6	72.3	63.5	55.2	59.1 |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
Table 1: Segmentation accuracies on English pho- |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
netic transcripts. NPY(n) means n-gram NPYLM.  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Results for HDP(2) are taken from Goldwater et  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
al. (2009), which corrects the errors in Goldwater  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
et al. (2006). |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Model	time	iterations |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
NPYLM	17min	200 |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
HDP	10h 55min	20000 |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Table 2: Computations needed for Table 1. Itera- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tions for “HDP” is the same as described in Gold- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
water et al. (2009). Actually, NPYLM approxi- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
mately converged around 50 iterations, 4 minutes. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Japanese word segmentation, with all supervised  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
segmentations removed in advance. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Chinese For Chinese, we used a publicly avail- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
able SIGHAN Bakeoff 2005 dataset (Emerson,  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
2005). To compare with the latest unsupervised  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
results (using a closed dataset of Bakeoff 2006),  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
we chose the common sets prepared by Microsoft  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Research Asia (MSR) for simplified Chinese, and  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
by City University of Hong Kong (CITYU) for  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
traditional Chinese. We used a random subset of  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
50,000 sentences from each dataset for training,  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and the evaluation was conducted on the enclosed  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
test data. 9 |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Japanese For Japanese, we used the Kyoto Cor- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
pus (Kyoto) (Kurohashi and Nagao, 1998): we  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
used random subset of 1,000 sentences for evalua- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tion and the remaining 37,400 sentences for train- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ing. In all cases we removed all whitespaces to  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
yield raw character strings for inference, and set  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
L = 4 for Chinese and L = 8 for Japanese to run  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the Gibbs sampler for 400 iterations. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
The results (in token F-measures) are shown in  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Table 3. Our NPYLM significantly ourperforms  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the best results using a heuristic approach reported  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
in Zhao and Kit (2008). While Japanese accura- |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
cies appear lower, subjective qualities are much  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
higher. This is mostly because NPYLM segments  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
inflectional suffixes and combines frequent proper  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
names, which are inconsistent with the “correct” |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
9Notice that analyzing a test data is not easy for character-  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
wise Gibbs sampler of previous work. Meanwhile, NPYLM  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
easily finds the best segmentation using the Viterbi algorithm  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
once the model is learned. |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
t(w)) , (17) |XML| xmlLoc_0 xmlAlign_right xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
105 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Model	MSR		CITYU		Kyoto	 |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
NPY(2)	80.2	(51.9)	82.4	(126.5)	62.1	(23.1) |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
NPY(3)	80.7	(48.8)	81.7	(128.3)	66.6	(20.6) |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
ZK08	66.7	(—)	69.2	(—)		— |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
Table 3: Accuracies and perplexities per character  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(in parentheses) on actual corpora. “ZK08” are the  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
best results reported in Zhao and Kit (2008). We  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
used oc-gram for characters. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
	MSR		CITYU		Kyoto	 |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
Semi Sup	0.895	(48.8)	0.898	(124.7)	0.913	(20.3) |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
	0.945	(81.4)	0.941	(194.8)	0.971	(21.3) |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_yes xmlBullet_no xmlIndent_no
Table 4: Semi-supervised and supervised results.  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Semi-supervised results used only 10K sentences  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(1/5) of supervised segmentations. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
segmentations. Bigram and trigram performances  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
are similar for Chinese, but trigram performs bet- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ter for Japanese. In fact, although the difference  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
in perplexity per character is not so large, the per- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
plexity per word is radically reduced: 439.8 (bi- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
gram) to 190.1 (trigram). This is because trigram  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
models can leverage complex dependencies over  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
words to yield shorter words, resulting in better  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
predictions and increased tokens. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Furthermore, NPYLM is easily amenable to  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
semi-supervised or even supervised learning. In  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
that case, we have only to replace the word seg- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
mentation w(s) in Figure 3 to the supervised one,  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
for all or part of the training data. Table 4  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
shows the results using 10,000 sentences (1/5) or  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
complete supervision. Our completely generative  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
model achieves the performance of 94% (Chinese)  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
or even 97% (Japanese) in supervised case. The  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
result also shows that the supervised segmenta- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tions are suboptimal with respect to the perplex- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ity per character, and even worse than unsuper- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
vised results. In semi-supervised case, using only  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
10K reference segmentations gives a performance  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
of around 90% accuracy and the lowest perplexity,  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
thanks to a combination with unsupervised data in  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a principled fashion. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
5.3 Classics and English text |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Our model is particularly effective for spoken tran- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
scripts, colloquial texts, classics, or unknown lan- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
guages where supervised segmentation data is dif- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ficult or even impossible to create. For example,  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
we are pleased to say that we can now analyze (and  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
build a language model on) “The Tale of Genji”,  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the core of Japanese classics written 1,000 years  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ago (Figure 6). The inferred segmentations are |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Figure 6: Unsupervised segmentation result for  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
“The Tale of Genji”. (16,443 sentences, 899,668  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
characters in total) |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
mostly correct, with some inflectional suffixes be- |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ing recognized as words, which is also the case  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
with English. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Finally, we note that our model is also effective  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
for western languages: Figure 7 shows a training  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
text of “Alice in Wonderland ” with all whitespaces  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
removed, and the segmentation result. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
While the data is extremely small (only 1,431  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
lines, 115,961 characters), our trigram NPYLM  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
can infer the words surprisingly well. This is be- |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
cause our model contains both word and character  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
models that are combined and carefully smoothed,  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
from a Bayesian perspective. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
6 Discussion |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In retrospect, our NPYLM is essentially a hier- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
archical Markov model where the units (=words)  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
evolve as the Markov process, and each unit  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
has subunits (=characters) that also evolve as the  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Markov process. Therefore, for such languages  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
as English that have already space-separated to- |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
kens, we can also begin with tokens besides the  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
character-based approach in Section 5.3. In this  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
case, each token is a “character” whose code is the  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
integer token type, and a sentence is a sequence of  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
“characters.” Figure 8 shows a part of the result  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
computed over 100K sentences from Penn Tree-  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
bank. We can see that some frequent phrases are  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
identified as “words”, using a fully unsupervised  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
approach. Notice that this is only attainable with  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
NPYLM where each phrase is described as a n-  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
gram model on its own, here a word oc-gram lan- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
guage model. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
While we developed an efficient forward-  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
backward algorithm for unsupervised segmenta- |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tion, it is reminiscent of CRF in the discrimina- |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tive approach. Therefore, it is also interesting  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
to combine them in a discriminative way as per-  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
sued in POS tagging using CRF+HMM (Suzuki et  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
al., 2007), let alone a simple semi-supervised ap- |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
proach in Section 5.2. This paper provides a foun- |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
dation of such possibilities. |XML| xmlLoc_7 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
106 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
lastly,shepicturedtoherselfhowthissamelittlesisterofhersw  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ould,intheafter-time,beherselfagrownwoman;andhowshe  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
wouldkeep,throughallherriperyears,thesimpleandlovingh  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
eartofherchildhood:andhowshewouldgatheraboutherothe  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
rlittlechildren,andmaketheireyesbrightandeagerwithmany  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
astrangetale,perhapsevenwiththedreamofwonderlandoflo  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ngago:andhowshewouldfeelwithalltheirsimplesorrows,an  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
dfindapleasureinalltheirsimplej oys,rememberingherownc  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
hild-life,andthehappysummerdays. |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(a) Training data (in part). |XML| xmlLoc_0 xmlAlign_centered xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
last ly , she pictured to herself how this same little sis- |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ter of her s would , inthe after - time , be herself agrown  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
woman ; and how she would keep , through allher ripery  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ears , the simple and loving heart of her child hood : and  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
how she would gather about her other little children ,and  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
make theireyes bright and eager with many a strange tale  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
,perhaps even with the dream of wonderland of longago  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
:and how she would feel with all their simple sorrow s ,  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and find a pleasure in all their simple joys , remember ing  |XML| xmlLoc_1 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
her own child - life, and thehappy summerday s . |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(b) Segmentation result. Note we used no dictionary. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Figure 7: Word segmentation of “Alice in Wonder- |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
land ”. |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_larger xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
7 Conclusion |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In this paper, we proposed a much more efficient  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and accurate model for fully unsupervised word  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
segmentation. With a combination of dynamic  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
programming and an accurate spelling model from  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a Bayesian perspective, our model significantly  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
outperforms the previous reported results, and the  |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
inference is very efficient. |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
This model is also considered as a way to build  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a Bayesian Kneser-Ney smoothed word n-gram  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
language model directly from characters with no  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
“word” indications. In fact, it achieves lower per- |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
plexity per character than that based on supervised  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
segmentations. We believe this will be particu- |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
larly beneficial to build a language model on such  |XML| xmlLoc_4 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
texts as speech transcripts, colloquial texts or un- |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
known languages, where word boundaries are hard  |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
or even impossible to identify a priori. |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Acknowledgments |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
We thank Vikash Mansinghka (MIT) for a mo- |XML| xmlLoc_5 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tivating discussion leading to this research, and  |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Satoru Takabayashi (Google) for valuable techni- |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
cal advice. |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
References |XML| xmlLoc_6 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_largest-2 xmlFontSizeChange_bigger xmlBold_yes xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
David Aldous, 1985. Exchangeability and Related  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Topics, pages 1–198. Springer Lecture Notes in  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Math. 1117. |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Rie Kubota Ando and Lillian Lee. 2003. Mostly-  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Unsupervised Statistical Segmentation of Japanese |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
nevertheless , |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
he was admired |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
by many of his immediate subordinates  |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
for his long work hours |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
and dedication to building northwest  |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
into what he called a “ mega carrier |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
. ” |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
although |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
preliminary findings |XML| xmlLoc_0 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
were reported |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
more than a year ago , |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
the latest results |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
appear |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
in today ’s |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
new england journal of medicine, |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a forum |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
likely to bring new attention to the problem  |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
. |XML| xmlLoc_1 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
south korea |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
registered a trade deficit of $ 101 million |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
in october |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
,reflecting the country ’s economic sluggishness  |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
,according to government figures released wednesday  |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
. |XML| xmlLoc_2 xmlAlign_left xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Figure 8: Generative phrase segmentation of Penn  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Treebank text computed by NPYLM. Each line is  |XML| xmlLoc_2 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a “word” consisting of actual words. |XML| xmlLoc_3 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_common xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Kanji Sequences. Natural Language Engineering,  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
9(2):127–149. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Peter F. Brown, Vincent J. Della Pietra, Robert L. Mer- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
cer, Stephen A. Della Pietra, and Jennifer C. Lai.  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
1992. An Estimate of an Upper Bound for the En- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tropy of English. ComputationalLinguistics, 18:3 1–  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
40. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Arnaud Doucet, Christophe Andrieu, and Roman  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Holenstein. 2009. Particle Markov Chain Monte  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Carlo. in submission. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Tom Emerson. 2005. SIGHAN Bakeoff 2005.  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
http://www.sighan.org/bakeoff2005/. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
W. R. Gilks, S. Richardson, and D. J. Spiegelhalter.  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
1996. Markov Chain Monte Carlo in Practice.  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Chapman &amp; Hall / CRC. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Sharon Goldwater, Thomas L. Griffiths, and Mark  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Johnson. 2005. Interpolating Between Types and  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Tokens by Estimating Power-Law Generators. In  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
NIPS 2005. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Sharon Goldwater, Thomas L. Griffiths, and Mark  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Johnson. 2006. Contextual Dependencies in Un- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
supervised Word Segmentation. In Proceedings of  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ACL/COLING 2006, pages 673–680. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Sharon Goldwater, Thomas L. Griffiths, and Mark  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Johnson. 2009. A Bayesian framework for word  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
segmentation: Exploring the effects of context.  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Cognition, in press. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Yang He. 1988. Extended Viterbi algorithm for sec- |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ond order hidden Markov process. In Proceedings  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ofICPR 1988, pages 718–720. |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
107 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
Mark Johnson and Sharon Goldwater. 2009. Im- |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
proving nonparameteric Bayesian inference: exper- |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
iments on unsupervised word segmentation with  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
adaptor grammars. In NAACL 2009. |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Mark Johnson, Thomas L. Griffiths, and Sharon Gold- |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
water. 2007. Bayesian Inference for PCFGs via  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Markov Chain Monte Carlo. In Proceedings of  |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
HLT/NAACL 2007, pages 139–146. |XML| xmlLoc_0 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Reinhard Kneser and Hermann Ney. 1995. Improved  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
backing-off for m-gram language modeling. In Pro- |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ceedings ofICASSP, volume 1, pages 181–184. |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Sadao Kurohashi and Makoto Nagao. 1998. Building  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
a Japanese Parsed Corpus while Improving the Pars- |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ing System. In Proceedings of LREC 1998, pages  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
719–724. http://nlp.kuee.kyoto-u.ac.jp/nl-resource/  |XML| xmlLoc_1 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
corpus.html. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Brian MacWhinney and Catherine Snow. 1985. The  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Child Language Data Exchange System. Journal of  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Child Language, 12:271–296. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Daichi Mochihashi and Eiichiro Sumita. 2007. The  |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Infinite Markov Model. In NIPS 2007. |XML| xmlLoc_2 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Kevin Murphy. 2002. Hidden semi-Markov models  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
(segment models). http://www.cs.ubc.ca/˜murphyk/  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Papers/segment.pdf. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Masaaki Nagata. 1996. Automatic Extraction of  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
New Words from Japanese Texts using General- |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
ized Forward-Backward Search. In Proceedings of  |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
EMNLP 1996, pages 48–59. |XML| xmlLoc_3 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Abel Rodriguez, David Dunson, and Alan Gelfand.  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
2008. The Nested Dirichlet Process. Journal of the  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
American Statistical Association, 103:1131–1154. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Steven L. Scott. 2002. Bayesian Methods for Hidden  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Markov Models. Journal of the American Statistical  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Association, 97:337–351. |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Jun Suzuki, Akinori Fujino, and Hideki Isozaki. 2007.  |XML| xmlLoc_4 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Semi-Supervised Structured Output Learning Based  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
on a Hybrid Generative and Discriminative Ap- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
proach. In Proceedings of EMNLP-CoNLL 2007,  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
pages 791–800. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Yee Whye Teh. 2006a. A Bayesian Interpreta- |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
tion of Interpolated Kneser-Ney. Technical Report  |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
TRA2/06, School of Computing, NUS. |XML| xmlLoc_5 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Yee Whye Teh. 2006b. A Hierarchical Bayesian Lan- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
guage Model based on Pitman-Yor Processes. In  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Proceedings ofACL/COLING 2006, pages 985–992. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Frank Wood and Yee Whye Teh. 2008. A Hierarchical,  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Hierarchical Pitman-Yor Process Language Model.  |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
In ICML 2008 Workshop on Nonparametric Bayes. |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_yes xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Jia Xu, Jianfeng Gao, Kristina Toutanova, and Her- |XML| xmlLoc_6 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
mann Ney. 2008. Bayesian Semi-Supervised Chi- |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
nese Word Segmentation for Statistical Machine  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Translation. In Proceedings of COLING 2008,  |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
pages 1017–1024. |XML| xmlLoc_7 xmlAlign_none xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Hai Zhao and Chunyu Kit. 2008. An Empirical Com- |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
parison of Goodness Measures for Unsupervised  |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
Chinese Word Segmentation with a Unified Frame- |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_no xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
work. In Proceedings ofIJCNLP 2008. |XML| xmlLoc_0 xmlAlign_justified xmlFontFace_common xmlFontFaceChange_no xmlFontSize_smaller xmlFontSizeChange_bigger xmlBold_no xmlItalic_no xmlDd_no xmlCell_no xmlBullet_no xmlIndent_no
108 |XML| xmlLoc_7 xmlAlign_left xmlFontFace_different xmlFontFaceChange_yes xmlFontSize_smaller xmlFontSizeChange_smaller xmlBold_no xmlItalic_no xmlDd_yes xmlCell_no xmlBullet_no xmlIndent_no
