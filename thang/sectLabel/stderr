# Copyright 2009 © by Luong Minh Thang

# tmp/1.txt
title		2-Source Dispersers for Sub-Polynomial Entropy and
title	title	Ramsey Graphs Beating the Frankl-Wilson Construction
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 3.
none	title	‚àó
author	none	Boaz Barak
affiliation	author	Department of Computer Science
affiliation	affiliation	Princeton University
email	affiliation	boaz@cs.princeton.edu
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 8.
author	email	Ronen Shaltiel ‚Ä°
affiliation	author	University of Haifa
address	affiliation	Mount Carmel
address	address	Haifa, Israel
email	address	ronen@cs.haifa.ac.il
sectionHeader	email	ABSTRACT
bodyText	sectionHeader	The main result of this paper is an explicit disperser for two
bodyText	bodyText	independent sources on n bits, each of entropy k = no(1).
bodyText	bodyText	Put differently, setting N = 2n and K = 2k, we construct
bodyText	bodyText	explicit N ◊ N Boolean matrices for which no K ◊ K sub-
bodyText	bodyText	matrix is monochromatic. Viewed as adjacency matrices of
bodyText	bodyText	bipartite graphs, this gives an explicit construction of K-
bodyText	bodyText	Ramsey bipartite graphs of size N.
bodyText	bodyText	This greatly improves the previous bound of k = o(n) of
bodyText	bodyText	Barak, Kindler, Shaltiel, Sudakov and Wigderson [4]. It also
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 23.
bodyText	bodyText	significantly improves the 25-year record of k = ~O(‚àön) on
bodyText	bodyText	the special case of Ramsey graphs, due to Frankl and Wilson
bodyText	bodyText	[9].
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 26.
bodyText	bodyText	The construction uses (besides ‚Äùclassical‚Äù extractor ideas)
bodyText	bodyText	almost all of the machinery developed in the last couple of
bodyText	bodyText	years for extraction from independent sources, including:
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 29.
bodyText	bodyText	‚Ä¢	Bourgain‚Äôs extractor for 2 independent sources of some
bodyText	bodyText	entropy rate < 1/2 [5]
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 31.
bodyText	bodyText	‚Ä¢	Raz‚Äôs extractor for 2 independent sources, one of which
bodyText	bodyText	has any entropy rate > 1/2 [18]
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 33.
footnote	bodyText	‚àóSupported by a Princeton University startup grant.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 34.
footnote	footnote	‚Ä†Most of this work was done while the author was visiting
footnote	footnote	Princeton University and the Institute for Advanced Study.
footnote	footnote	Supported in part by an MCD fellowship from UT Austin
footnote	footnote	and NSF Grant CCR-0310960.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 38.
footnote	footnote	‚Ä°This research was supported by the United States-Israel
footnote	footnote	Binational Science Foundation (BSF) grant 2004329.
footnote	footnote	ßThis research was supported by NSF Grant CCR-0324906.
copyright	footnote	Permission to make digital or hard copies of all or part of this work for
copyright	copyright	personal or classroom use is granted without fee provided that copies are
copyright	copyright	not made or distributed for profit or commercial advantage and that copies
copyright	copyright	bear this notice and the full citation on the first page. To copy otherwise, to
copyright	copyright	republish, to post on servers or to redistribute to lists, requires prior specific
copyright	copyright	permission and/or a fee.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 47.
note	copyright	STOC‚Äô06, May 21‚Äì23, 2006, Seattle, Washington, USA.
copyright	note	Copyright 2006 ACM 1-59593-134-1/06/0005 ...$5.00.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 49.
author	copyright	Anup Rao ‚Ä†
affiliation	author	Department of Computer Science
affiliation	affiliation	University of Texas at Austin
email	affiliation	arao@cs.utexas.edu
author	email	Avi Wigderson ß
affiliation	author	Institute for Advanced Study
address	affiliation	Princeton
address	address	New Jersey
email	address	avi@math.ias.edu
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 58.
bodyText	email	‚Ä¢	Rao‚Äôs extractor for 2 independent block-sources of en-
bodyText	bodyText	tropy no(1) [17]
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 60.
bodyText	bodyText	‚Ä¢	The ‚ÄúChallenge-Response‚Äù mechanism for detecting
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 61.
bodyText	bodyText	‚Äúentropy concentration‚Äù of [4].
bodyText	bodyText	The main novelty comes in a bootstrap procedure which
bodyText	bodyText	allows the Challenge-Response mechanism of [4] to be used
bodyText	bodyText	with sources of less and less entropy, using recursive calls
bodyText	bodyText	to itself. Subtleties arise since the success of this mecha-
bodyText	bodyText	nism depends on restricting the given sources, and so re-
bodyText	bodyText	cursion constantly changes the original sources. These are
bodyText	bodyText	resolved via a new construct, in between a disperser and
bodyText	bodyText	an extractor, which behaves like an extractor on sufficiently
bodyText	bodyText	large subsources of the given ones.
note	bodyText	This version is only an extended abstract, please see the
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 72.
note	note	full version, available on the authors‚Äô homepages, for more
note	note	details.
sectionHeader	note	Categories and Subject Descriptors
category	sectionHeader	G.2.2 [Mathematics of Computing]: Discrete Mathe-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 76.
category	category	matics‚ÄîGraph algorithms
sectionHeader	category	General Terms
keyword	sectionHeader	Theory, Algorithms
sectionHeader	keyword	Keywords
keyword	sectionHeader	Dispersers, Ramsey Graphs, Independent Sources, Extrac-
keyword	keyword	tors
sectionHeader	keyword	1. INTRODUCTION
bodyText	sectionHeader	This paper deals with randomness extraction from weak
bodyText	bodyText	random sources. Here a weak random source is a distribu-
bodyText	bodyText	tion which contains some entropy. The extraction task is to
bodyText	bodyText	design efficient algorithms (called extractors) to convert this
bodyText	bodyText	entropy into useful form, namely a sequence of independent
bodyText	bodyText	unbiased bits. Beyond the obvious motivations (potential
bodyText	bodyText	use of physical sources in pseudorandom generators and in
bodyText	bodyText	derandomization), extractors have found applications in a
page	bodyText	671
bodyText	page	variety of areas in theoretical computer science where ran-
bodyText	bodyText	domness does not seem an issue, such as in efficient con-
bodyText	bodyText	structions of communication networks [24, 7], error correct-
bodyText	bodyText	ing codes [22, 12], data structures [14] and more.
bodyText	bodyText	Most work in this subject over the last 20 years has fo-
bodyText	bodyText	cused on what is now called seeded extraction, in which the
bodyText	bodyText	extractor is given as input not only the (sample from the)
bodyText	bodyText	defective random source, but also a few truly random bits
bodyText	bodyText	(called the seed). A comprehensive survey of much of this
bodyText	bodyText	body of work is [21].
bodyText	bodyText	Another direction, which has been mostly dormant till
bodyText	bodyText	about two years ago, is (seedless, deterministic) extraction
bodyText	bodyText	from a few independent weak sources. This kind of extrac-
bodyText	bodyText	tion is important in several applications where it is unrealis-
bodyText	bodyText	tic to have a short random seed or deterministically enumer-
bodyText	bodyText	ate over its possible values. However, it is easily shown to be
bodyText	bodyText	impossible when only one weak source is available. When at
bodyText	bodyText	least 2 independent sources are available extraction becomes
bodyText	bodyText	possible in principle. The 2-source case is the one we will
bodyText	bodyText	focus on in this work.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 112.
bodyText	bodyText	The rest of the introduction is structured as follows. We‚Äôll
bodyText	bodyText	start by describing our main result in the context of Ramsey
bodyText	bodyText	graphs. We then move to the context of extractors and dis-
bodyText	bodyText	perser, describing the relevant background and stating our
bodyText	bodyText	result in this language. Then we give an overview of the
bodyText	bodyText	construction of our dispersers, describing the main building
bodyText	bodyText	blocks we construct along the way. As the construction is
bodyText	bodyText	quite complex and its analysis quite subtle, in this proceed-
bodyText	bodyText	ings version we try to abstract away many of the technical
bodyText	bodyText	difficulties so that the main ideas, structure and tools used
bodyText	bodyText	are highlighted. For that reason we also often state defini-
bodyText	bodyText	tions and theorems somewhat informally.
subsectionHeader	bodyText	1.1 Ramsey Graphs
construct	subsectionHeader	DefInItIOn 1.1. A graph on N vertices is called a K-
construct	construct	Ramsey Graph if it contains no clique or independent set of
construct	construct	size K.
bodyText	construct	In 1947 Erd}os published his paper inaugurating the Prob-
bodyText	bodyText	abilistic Method with a few examples, including a proof that
bodyText	bodyText	most graphs on N = 2n vertices are 2n-Ramsey. The quest
bodyText	bodyText	for constructing such graphs explicitly has existed ever since
bodyText	bodyText	and lead to some beautiful mathematics.
bodyText	bodyText	The best record to date was obtained in 1981 by Frankl
bodyText	bodyText	and Wilson [9], who used intersection theorems for set sys-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 135.
bodyText	bodyText	tems to construct N-vertex graphs which are 21ÔøΩn log n-Ramsey.
bodyText	bodyText	This bound was matched by Alon [1] using the Polynomial
bodyText	bodyText	Method, by Grolmusz [11] using low rank matrices over rings,
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 138.
bodyText	bodyText	and also by Barak [2] boosting Abbot‚Äôs method with almost
bodyText	bodyText	k-wise independent random variables (a construction that
bodyText	bodyText	was independently discovered by others as well). Remark-
bodyText	bodyText	ably all of these different approaches got stuck at essentially
bodyText	bodyText	the same bound. In recent work, Gopalan [10] showed that
bodyText	bodyText	other than the last construction, all of these can be viewed
bodyText	bodyText	as coming from low-degree symmetric representations of the
bodyText	bodyText	OR function. He also shows that any such symmetric rep-
bodyText	bodyText	resentation cannot be used to give a better Ramsey graph,
bodyText	bodyText	which gives a good indication of why these constructions
bodyText	bodyText	had similar performance. Indeed, as we will discuss in a
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 149.
bodyText	bodyText	later section, the ‚àön entropy bound initially looked like a
bodyText	bodyText	natural obstacle even for our techniques, though eventually
bodyText	bodyText	we were able to surpass it.
bodyText	bodyText	The analogous question for bipartite graphs seemed much
bodyText	bodyText	harder.
construct	bodyText	DefInItIOn 1.2. A bipartite graph on two sets of N ver-
construct	construct	tices is a K-Ramsey Bipartite Graph if it has no K ◊ K
construct	construct	complete or empty bipartite subgraph.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 157.
bodyText	construct	While Erd}os‚Äô result on the abundance of 2n-Ramsey graphs
bodyText	bodyText	holds as is for bipartite graphs, until recently the best ex-
bodyText	bodyText	plicit construction of bipartite Ramsey graphs was 2n/2-
bodyText	bodyText	Ramsey, using the Hadamard matrix. This was improved
bodyText	bodyText	last year, first to o(2n/2) by Pudlak and R}odl [16] and then
bodyText	bodyText	to 2o(n) by Barak, Kindler, Shaltiel, Sudakov and Wigderson
bodyText	bodyText	[4] .
bodyText	bodyText	It is convenient to view such graphs as functions f :
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 165.
bodyText	bodyText	({0, 1}n)2 ‚Üí {0, 1}. This then gives exactly the definition
bodyText	bodyText	of a disperser.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 167.
construct	bodyText	DefInItIOn 1.3. A function f : ({0, 1}n)2 ‚Üí {0, 1} is
construct	construct	called a 2-source disperser for entropy k if for any two sets
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 169.
construct	construct	X, Y ‚äÇ {0, 1}n with | X | = |Y| = 2k, we have that the image
construct	construct	f (X, Y) is {0, 1}.
bodyText	construct	This allows for a more formal definition of explicitness: we
bodyText	bodyText	simply demand that the function f is computable in polyno-
bodyText	bodyText	mial time. Most of the constructions mentioned above are
bodyText	bodyText	explicit in this sense.'
bodyText	bodyText	Our main result (stated informally) significantly improves
bodyText	bodyText	the bounds in both the bipartite and non-bipartite settings:
construct	bodyText	TheOrem 1.4. For every N we construct polynomial time
construct	construct	computable bipartite graphs which are 2n'(1)-Ramsey. A stan-
construct	construct	dard transformation of these graphs also yields polynomial
construct	construct	time computable ordinary Ramsey Graphs with the same pa-
construct	construct	rameters.
subsectionHeader	construct	1.2 Extractors and Dispersers from indepen-
subsectionHeader	subsectionHeader	dent sources
bodyText	subsectionHeader	Now we give a brief review of past relevant work (with the
bodyText	bodyText	goal of putting this paper in proper context) and describe
bodyText	bodyText	some of the tools from these past works that we will use.
bodyText	bodyText	We start with the basic definitions of k-sources by Nisan
bodyText	bodyText	and Zuckerman [15] and of extractors and dispersers for in-
bodyText	bodyText	dependent sources by Santha and Vazirani [20].
construct	bodyText	DefInItIOn 1.5 ([15], See alSO [8]). The min-entropy
construct	construct	of a distribution X is the maximum k such that for every
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 192.
construct	construct	element x in its support, Pr[X = x] ‚â§ 2-k. If X is a dis-
construct	construct	tribution on strings with min-entropy at least k, we will call
construct	construct	X a k-source 2.
bodyText	construct	To simplify the presentation, in this version of the paper
bodyText	bodyText	we will assume that we are working with entropy as opposed
bodyText	bodyText	to min-entropy.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 198.
construct	bodyText	DefInItIOn 1.6 ([20]). A function f : ({0,1}n)c ‚Üí
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 199.
construct	construct	{0, 1}m is a c-source (k, «´) extractor if for every family of c
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 200.
construct	construct	independent k-sources X', ‚Ä¢ ‚Ä¢ ‚Ä¢ , Xc, the output f (X', ‚Ä¢ ‚Ä¢ ‚Ä¢ , Xc)
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 201.
footnote	construct	'The Abbot‚Äôs product based Ramsey-graph construction of
footnote	footnote	[3] and the bipartite Ramsey construction of [16] only satisfy
footnote	footnote	a weaker notion of explicitness.
footnote	footnote	2It is no loss of generality to imagine that X is uniformly
footnote	footnote	distributed over some (unknown) set of size 2k.
page	footnote	672
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 207.
bodyText	page	is a «´-close 3 to uniformly distributed on m bits. f is a dis-
bodyText	bodyText	perser for the same parameters if the output is simply re-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 209.
bodyText	bodyText	quired to have a support of relative size (1 ‚àí «´).
bodyText	bodyText	To simplify the presentation, in this version of the paper,
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 211.
bodyText	bodyText	we will assume that «´ = 0 for all of our constructions.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 212.
bodyText	bodyText	In this language, Erd}os‚Äô theorem says that most functions
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 213.
bodyText	bodyText	f : ({0, 1}n)2 ‚Üí {0, 1} are dispersers for entropy 1 + logn
bodyText	bodyText	(treating f as the characteristic function for the set of edges
bodyText	bodyText	of the graph). The proof easily extends to show that indeed
bodyText	bodyText	most such functions are in fact extractors. This naturally
bodyText	bodyText	challenges us to find explicit functions f that are 2-source
bodyText	bodyText	extractors.
bodyText	bodyText	Until one year ago, essentially the only known explicit
bodyText	bodyText	construction was the Hadamard extractor Had defined by
bodyText	bodyText	Had(x,y)
bodyText	bodyText	k > n/2 as observed by Chor and Goldreich [8] and can
bodyText	bodyText	be extended to give m = Q(n) output bits as observed by
bodyText	bodyText	Vazirani [23]. Over 20 years later, a recent breakthrough
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 225.
bodyText	bodyText	of Bourgain [5] broke this ‚Äú1/2 barrier‚Äù and can handle 2
bodyText	bodyText	sources of entropy .4999n, again with linear output length
bodyText	bodyText	m = 0(n). This seemingly minor improvement will be cru-
bodyText	bodyText	cial for our work!
construct	bodyText	TheOrem 1.7 ([5] ). There is a polynomial time com-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 230.
construct	construct	putable 2-source extractor f : ({0, 1}n)2 ‚Üí {0, 1}m for en-
construct	construct	tropy .4999n and m = 0(n).
bodyText	construct	No better bounds are known for 2-source extractors. Now
bodyText	bodyText	we turn our attention to 2-source dispersers. It turned out
bodyText	bodyText	that progress for building good 2-source dispersers came via
bodyText	bodyText	progress on extractors for more than 2 sources, all happening
bodyText	bodyText	in fast pace in the last 2 years. The seminal paper of Bour-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 237.
bodyText	bodyText	gain, Katz and Tao [6] proved the so-called ‚Äùsum-product
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 238.
bodyText	bodyText	theorem‚Äù in prime fields, a result in arithmetic combina-
bodyText	bodyText	torics. This result has already found applications in diverse
bodyText	bodyText	areas of mathematics, including analysis, number theory,
bodyText	bodyText	group theory and ... extractor theory. Their work implic-
bodyText	bodyText	itly contained dispersers for c = O(log(n/k)) independent
bodyText	bodyText	sources of entropy k (with output m = Q(k)). The use of
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 244.
bodyText	bodyText	the ‚Äùsum-product‚Äù theorem was then extended by Barak et
bodyText	bodyText	al. [3] to give extractors with similar parameters. Note that
bodyText	bodyText	for linear entropy k = 0(n), the number of sources needed
bodyText	bodyText	for extraction c is a constant!
bodyText	bodyText	Relaxing the independence assumptions via the idea of
bodyText	bodyText	repeated condensing, allowed the reduction of the number
bodyText	bodyText	of independent sources to c = 3, for extraction from sources
bodyText	bodyText	of any linear entropy k = 0(n), by Barak et al. [4] and
bodyText	bodyText	independently by Raz [18].
bodyText	bodyText	For 2 sources Barak et al. [4] were able to construct dis-
bodyText	bodyText	persers for sources of entropy o(n). To do this, they first
bodyText	bodyText	showed that if the sources have extra structure (block-source
bodyText	bodyText	structure, defined below), even extraction is possible from 2
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 257.
bodyText	bodyText	sources. The notion of block-sources, capturing ‚Äùsemi inde-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 258.
bodyText	bodyText	pendence‚Äù of parts of the source, was introduced by Chor
bodyText	bodyText	and Goldreich [8]. It has been fundamental in the develop-
bodyText	bodyText	ment of seeded extractors and as we shall see, is essential
bodyText	bodyText	for us as well.
construct	bodyText	DefInItIOn 1.8 ([8] ). A distribution X = X1, ... , Xc
construct	construct	is a c-block-source of (block) entropy k if every block Xi
construct	construct	has entropy k even conditioned on fixing the previous blocks
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 265.
construct	construct	X1, ‚Ä¢ ‚Ä¢ ‚Ä¢ , Xi_1 to arbitrary constants.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 266.
footnote	construct	3The error is usually measured in terms of ‚Ñì1 distance or
footnote	footnote	variation distance.
bodyText	footnote	This definition allowed Barak et al. [4] to show that their
bodyText	bodyText	extractor for 4 independent sources, actually performs as
bodyText	bodyText	well with only 2 independent sources, as long as both are
bodyText	bodyText	2-block-sources.
construct	bodyText	TheOrem 1.9 ([4] ). There exists a polynomial time com-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 273.
construct	construct	putable extractor f : ({0, 1}n)2 ‚Üí {0, 1} for 2 independent
construct	construct	2-block-sources with entropy o(n).
bodyText	construct	There is no reason to assume that the given sources are
bodyText	bodyText	block-sources, but it is natural to try and reduce to this
bodyText	bodyText	case. This approach has been one of the most successful in
bodyText	bodyText	the extractor literature. Namely try to partition a source
bodyText	bodyText	X into two blocks X = X1, X2 such that X1, X2 form a
bodyText	bodyText	2-block-source. Barak et al. introduced a new technique to
bodyText	bodyText	do this reduction called the Challenge-Response mechanism,
bodyText	bodyText	which is crucial for this paper. This method gives a way to
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 283.
bodyText	bodyText	‚Äúfind‚Äù how entropy is distributed in a source X, guiding the
bodyText	bodyText	choice of such a partition. This method succeeds only with
bodyText	bodyText	small probability, dashing the hope for an extractor, but still
bodyText	bodyText	yielding a disperser.
construct	bodyText	TheOrem 1.10 ([4] ). There exists a polynomial time
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 288.
construct	construct	computable 2-source disperser f : ({0, 1}n)2 ‚Üí {0, 1} for
construct	construct	entropy o(n).
bodyText	construct	Reducing the entropy requirement of the above 2-source
bodyText	bodyText	disperser, which is what we achieve in this paper, again
bodyText	bodyText	needed progress on achieving a similar reduction for extrac-
bodyText	bodyText	tors with more independent sources. A few months ago Rao
bodyText	bodyText	[?] was able to significantly improve all the above results
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 295.
bodyText	bodyText	for c ‚â• 3 sources. Interestingly, his techniques do not use
bodyText	bodyText	arithmetic combinatorics, which seemed essential to all the
bodyText	bodyText	papers above. He improves the results of Barak et al. [3] to
bodyText	bodyText	give c = O((logn)/(logk))-source extractors for entropy k.
bodyText	bodyText	Note that now the number c of sources needed for extraction
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 300.
bodyText	bodyText	is constant, even when the entropy is as low as nŒ¥ for any
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 301.
bodyText	bodyText	constant Œ¥!
bodyText	bodyText	Again, when the input sources are block-sources with suf-
bodyText	bodyText	ficiently many blocks, Rao proves that 2 independent sources
bodyText	bodyText	suffice (though this result does rely on arithmetic combina-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 305.
bodyText	bodyText	torics, in particular, on Bourgain‚Äôs extractor).
construct	bodyText	TheOrem 1.11 ([?] ). There is a polynomial time com-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 307.
construct	construct	putable extractor f : ({0, 1}n)2 ‚Üí {0, 1}m for 2 independent
construct	construct	c-block-sources with block entropy k and m = 0(k), as long
construct	construct	as c = O((log n)/(log k)).
bodyText	construct	In this paper (see Theorem 2.7 below) we improve this
bodyText	bodyText	result to hold even when only one of the 2 sources is a c-
bodyText	bodyText	block-source. The other source can be an arbitrary source
bodyText	bodyText	with sufficient entropy. This is a central building block in
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 314.
bodyText	bodyText	our construction. This extractor, like Rao‚Äôs above, critically
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 315.
bodyText	bodyText	uses Bourgain‚Äôs extractor mentioned above. In addition it
bodyText	bodyText	uses a theorem of Raz [18] allowing seeded extractors to have
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 317.
bodyText	bodyText	‚Äùweak‚Äù seeds, namely instead of being completely random
bodyText	bodyText	they work as long as the seed has entropy rate > 1/2.
sectionHeader	bodyText	2. MAIN NOTIONS AND NEW RESULTS
bodyText	sectionHeader	The main result of this paper is a polynomial time com-
bodyText	bodyText	putable disperser for 2 sources of entropy no(1), significantly
bodyText	bodyText	improving both the results of Barak et al. [4] (o(n) entropy).
bodyText	bodyText	It also improves on Frankl and Wilson [9], who only built
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 324.
bodyText	bodyText	Ramsey Graphs and only for entropy ~O(‚àön).
bodyText	bodyText	= (x, y)( mod 2). It is an extractor for entropy
page	bodyText	673
construct	page	ThEOREm 2.1 (MaIn thEOREm, REStatEd). There ex-
construct	construct	ists a polynomial time computable 2-source disperser D :
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 329.
construct	construct	({0, 1}n)2 ‚Üí {0, 1} for entropy no(1).
bodyText	construct	The construction of this disperser will involve the con-
bodyText	bodyText	struction of an object which in some sense is stronger and
bodyText	bodyText	in another weaker than a disperser: a subsource somewhere
bodyText	bodyText	extractor. We first define a related object: a somewhere ex-
bodyText	bodyText	tractor, which is a function producing several outputs, one of
bodyText	bodyText	which must be uniform. Again we will ignore many technical
bodyText	bodyText	issues such as error, min-entropy vs. entropy and more, in
bodyText	bodyText	definitions and results, which are deferred to the full version
bodyText	bodyText	of this paper.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 339.
construct	bodyText	DEfInItIOn 2.2. A function f : ({0, 1}n)2 ‚Üí ({0,1}m)‚Ñì
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 340.
construct	construct	is a 2-source somewhere extractor with ‚Ñì outputs, for entropy
construct	construct	k, if for every 2 independent k-sources X, Y there exists an
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 342.
construct	construct	i ‚àà [‚Ñì] such the ith output f (X, Y)i is a uniformly distributed
construct	construct	string of m bits.
bodyText	construct	Here is a simple construction of such a somewhere extrac-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 345.
bodyText	bodyText	tor with ‚Ñì as large as poly(n) (and the p in its name will
bodyText	bodyText	stress the fact that indeed the number of outputs is that
bodyText	bodyText	large). It will nevertheless be useful to us (though its de-
bodyText	bodyText	scription in the next sentence may be safely skipped). Define
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 349.
bodyText	bodyText	pSE(x, y)i = V(E(x, i), E(y, i)) where E is a ‚Äùstrong‚Äù loga-
bodyText	bodyText	rithmic seed extractor, and V is the Hadamard/Vazirani 2-
bodyText	bodyText	source extractor. Using this construction, it is easy to see
bodyText	bodyText	that:
construct	bodyText	PROPOSItIOn 2.3. For every n, k there is a polynomial
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 354.
construct	construct	time computable somewhere extractor pSE : ({0, 1}n)2 ‚Üí
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 355.
construct	construct	({0, 1}m)‚Ñì with ‚Ñì = poly(n) outputs, for entropy k, and m =
construct	construct	Q(k).
bodyText	construct	Before we define subsource somewhere extractor, we must
bodyText	bodyText	first define a subsource.
construct	bodyText	DEfInItIOn 2.4 (SUBSOURCES). Given random variables
construct	construct	Z and Z^ on {0, 1}n we say that Z^ is a deficiency d subsource
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 361.
construct	construct	of Z and write Z^ ‚äÜ Z if there exists a set A ‚äÜ {0,1}n such
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 362.
construct	construct	that (Z|Z ‚àà A) = Z^ and Pr[Z ‚àà A] ‚â• 2-d.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 363.
bodyText	construct	A subsource somewhere extractor guarantees the ‚Äùsome-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 364.
bodyText	bodyText	where extractor‚Äù property only on subsources X', Y' of the
bodyText	bodyText	original input distributions X, Y (respectively). It will be
bodyText	bodyText	extremely important for us to make these subsources as large
bodyText	bodyText	as possible (i.e. we have to lose as little entropy as possible).
bodyText	bodyText	Controlling these entropy deficiencies is a major technical
bodyText	bodyText	complication we have to deal with. However we will be in-
bodyText	bodyText	formal with it here, mentioning it only qualitatively when
bodyText	bodyText	needed. We discuss this issue a little more in Section 6.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 372.
construct	bodyText	DEfInItIOn 2.5. A function f : ({0, 1}n)2 ‚Üí ({0,1}m)‚Ñì
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 373.
construct	construct	is a 2-source subsource somewhere extractor with ‚Ñì outputs
construct	construct	for entropy k, if for every 2 independent k-sources X, Y there
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 375.
construct	construct	exists a subsource X^ of X, a subsource Y^ of Y and an i ‚àà [‚Ñì]
construct	construct	such the ith output f (^X, Y^)i is a uniformly distributed string
construct	construct	of m bits.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 378.
bodyText	construct	A central technical result for us is that with this ‚Äùsub-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 379.
bodyText	bodyText	source‚Äù relaxation, we can have much fewer outputs ‚Äì in-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 380.
bodyText	bodyText	deed we‚Äôll replace poly(n) outputs in our first construction
bodyText	bodyText	above with no(1) outputs.
construct	bodyText	ThEOREm 2.6 (SUBSOURCE SOmEWhERE ExtRaCtOR).
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 383.
construct	construct	For every Œ¥ > 0 there is a polynomial time computable sub-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 384.
construct	construct	source somewhere extractor SSE : ({0, 1}n)2 ‚Üí ({0, 1}m)‚Ñì
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 385.
construct	construct	with ‚Ñì = no(1) outputs, for entropy k = nŒ¥, with output
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 386.
construct	construct	m=‚àök.
bodyText	construct	We will describe the ideas used for constructing this im-
bodyText	bodyText	portant object and analyzing it in the next section, where
bodyText	bodyText	we will also indicate how it is used in the construction of
bodyText	bodyText	the final disperser. Here we state a central building block,
bodyText	bodyText	mentioned in the previous section (as an improvement of the
bodyText	bodyText	work of Rao [?]). We construct an extractor for 2 indepen-
bodyText	bodyText	dent sources one of which is a block-sources with sufficient
bodyText	bodyText	number of blocks.
construct	bodyText	ThEOREm 2.7 (BlOCK SOURCE ExtRaCtOR). There is
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 396.
construct	construct	a polynomial time computable extractor B : ({0, 1}n)2 ‚Üí
construct	construct	{0,1}m for 2 independent sources, one of which is a c-block-
construct	construct	sources with block entropy k and the other a source of en-
construct	construct	tropy k, with m = 0(k), and c = O((log n)/(log k)).
bodyText	construct	A simple corollary of this block-source extractor B, is the
bodyText	bodyText	following weaker (though useful) somewhere block-source
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 402.
bodyText	bodyText	extractor SB. A source Z = Z1, Z2, ‚Ä¢ ‚Ä¢ ‚Ä¢ , Zt is a somewhere
bodyText	bodyText	c-block-source of block entropy k if for some c indices i1 <
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 404.
bodyText	bodyText	i2 < ‚Ä¢ ‚Ä¢ ‚Ä¢ < ic the source Zi1, Zi2, ‚Ä¢ ‚Ä¢ ‚Ä¢ , Zic is a c-block-source.
bodyText	bodyText	Collecting the outputs of B on every c-subset of blocks re-
bodyText	bodyText	sults in that somewhere extractor.
construct	bodyText	COROllaRY 2.8. There is a polynomial time computable
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 408.
construct	construct	somewhere extractorSB : ({0, 1}n)2 ‚Üí ({0, 1}m)‚Ñì for2 inde-
construct	construct	pendent sources, one of which is a somewhere c-block-sources
construct	construct	with block entropy k and t blocks total and the other a source
construct	construct	of entropy k, with m = 0(k), c = O((log n)/(log k)), and
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 412.
construct	construct	‚Ñì ‚â§ tc.
bodyText	construct	In both the theorem and corollary above, the values of
bodyText	bodyText	entropy k we will be interested in are k = no(1). It follows
bodyText	bodyText	that a block-source with a constant c = O(1) suffices.
sectionHeader	bodyText	3. THE CHALLENGE-RESPONSE MECH-
sectionHeader	sectionHeader	ANISM
bodyText	sectionHeader	We now describe abstractly a mechanism which will be
bodyText	bodyText	used in the construction of the disperser as well as the sub-
bodyText	bodyText	source somewhere extractor. Intuitively, this mechanism al-
bodyText	bodyText	lows us to identify parts of a source which contain large
bodyText	bodyText	amounts of entropy. One can hope that using such a mech-
bodyText	bodyText	anism one can partition a given source into blocks in a way
bodyText	bodyText	which make it a block-source, or alternatively focus on a part
bodyText	bodyText	of the source which is unusually condensed with entropy -
bodyText	bodyText	two cases which may simplify the extraction problem.
bodyText	bodyText	The reader may decide, now or in the middle of this
bodyText	bodyText	section, to skip ahead to the next section which describes
bodyText	bodyText	the construction of the subsource somewhere extractor SSE,
bodyText	bodyText	which extensively uses this mechanism. Then this section
bodyText	bodyText	may seem less abstract, as it will be clearer where this mech-
bodyText	bodyText	anism is used.
bodyText	bodyText	This mechanism was introduced by Barak et al. [4], and
bodyText	bodyText	was essential in their 2-source disperser. Its use in this paper
bodyText	bodyText	is far more involved (in particular it calls itself recursively,
bodyText	bodyText	a fact which creates many subtleties). However, at a high
bodyText	bodyText	level, the basic idea behind the mechanism is the same:
bodyText	bodyText	Let Z be a source and Z' a part of Z (Z projected on a
bodyText	bodyText	subset of the coordinates). We know that Z has entropy k,
page	bodyText	674
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 441.
bodyText	page	and want to distinguish two possibilities: Z‚Ä≤ has no entropy
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 442.
bodyText	bodyText	(it is fixed) or it has at least k‚Ä≤ entropy. Z‚Ä≤ will get a pass
bodyText	bodyText	or fail grade, hopefully corresponding to the cases of high or
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 444.
bodyText	bodyText	no entropy in Z‚Ä≤.
bodyText	bodyText	Anticipating the use of this mechanism, it is a good idea
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 446.
bodyText	bodyText	to think of Z as a ‚Äùparent‚Äù of Z‚Ä≤, which wants to check if
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 447.
bodyText	bodyText	this ‚Äùchild‚Äù has sufficient entropy. Moreover, in the context
bodyText	bodyText	of the initial 2 sources X, Y we will operate on, think of Z
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 449.
bodyText	bodyText	as a part of X, and thus that Y is independent of Z and Z‚Ä≤.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 450.
bodyText	bodyText	To execute this ‚Äùtest‚Äù we will compute two sets of strings
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 451.
bodyText	bodyText	(all of length m, say): the Challenge C = C(Z‚Ä≤,Y) and
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 452.
bodyText	bodyText	the Response R = R(Z, Y). Z‚Ä≤ fails if C C R and passes
bodyText	bodyText	otherwise.
bodyText	bodyText	The key to the usefulness of this mechanism is the follow-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 455.
bodyText	bodyText	ing lemma, which states that what ‚Äùshould‚Äù happen, indeed
bodyText	bodyText	happens after some restriction of the 2 sources Z and Y.
bodyText	bodyText	We state it and then explain how the functions C and R are
bodyText	bodyText	defined to accommodate its proof.
construct	bodyText	Lemma 3.1. Assume Z, Y are sources of entropy k.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 460.
listItem	construct	1. If Z‚Ä≤ has entropy k‚Ä≤+O(m), then there are subsources
listItem	listItem	Z^ of Z and Y^ of Y, such that
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 462.
listItem	listItem	Pr[^Z‚Ä≤ passes] = Pr[C(^Z‚Ä≤, Y^) C R(^Z, Y^)] > 1‚ÄînO(1)2‚àím
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 463.
listItem	listItem	2. If Z‚Ä≤ is fixed (namely, has zero entropy), then for some
listItem	listItem	subsources Z^ of Z and Y^ of Y, we have
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 465.
listItem	listItem	Pr[Z‚Ä≤ fails] = Pr[C(^Z‚Ä≤, Y^) C R(^Z, Y^)] = 1
bodyText	listItem	Once we have such a mechanism, we will design our dis-
bodyText	bodyText	perser algorithm assuming that the challenge response mech-
bodyText	bodyText	anism correctly identifies parts of the source with high or
bodyText	bodyText	low levels of entropy. Then in the analysis, we will ensure
bodyText	bodyText	that our algorithm succeeds in making the right decisions,
bodyText	bodyText	at least on subsources of the original input sources.
bodyText	bodyText	Now let us explain how to compute the sets C and R. We
bodyText	bodyText	will use some of the constructs above with parameters which
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 474.
bodyText	bodyText	don‚Äôt quite fit.
bodyText	bodyText	The response set R(Z, Y) = pSE(Z, Y) is chosen to be the
bodyText	bodyText	output of the somewhere extractor of Proposition 2.3. The
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 477.
bodyText	bodyText	challenge set C(Z‚Ä≤, Y) = SSE(Z‚Ä≤, Y) is chosen to be the out-
bodyText	bodyText	put of the subsource somewhere extractor of Theorem 2.6.
bodyText	bodyText	Why does it work? We explain each of the two claims
bodyText	bodyText	in the lemma in turn (and after each comment on the im-
bodyText	bodyText	portant parameters and how they differ from Barak et al.
bodyText	bodyText	[4]).
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 483.
listItem	bodyText	1. Z‚Ä≤ has entropy. We need to show that Z‚Ä≤ passes the
listItem	listItem	test with high probability. We will point to the out-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 485.
listItem	listItem	put string in C(^Z‚Ä≤, Y^‚Ä≤) which avoids R(^Z, Y^) with high
listItem	listItem	probability as follows. In the analysis we will use the
listItem	listItem	union bound on several events, one associated with
listItem	listItem	each (poly(n) many) string in pSE(^Z, Y^). We note
listItem	listItem	that by the definition of the response function, if we
listItem	listItem	want to fix a particular element in the response set to
listItem	listItem	a particular value, we can do this by fixing E(Z, i) and
listItem	listItem	E(Y, i). This fixing keeps the restricted sources inde-
listItem	listItem	pendent and loses only O(m) entropy. In the subsource
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 494.
listItem	listItem	of Z‚Ä≤ guaranteed to exist by Theorem 2.6 we can afford
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 495.
listItem	listItem	to lose this entropy in Z‚Ä≤. Thus we conclude that one
listItem	listItem	of its outputs is uniform. The probability that this
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 497.
listItem	listItem	output will equal any fixed value is thus 2‚àím, com-
listItem	listItem	pleting the argument. We note that we can handle
listItem	listItem	the polynomial output size of pSE, since the uniform
listItem	listItem	string has length m = no(1) (something which could
listItem	listItem	not be done with the technology available to Barak et
listItem	listItem	al. [4]).
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 503.
listItem	listItem	2. Z‚Ä≤ has no entropy. We now need to guarantee that
listItem	listItem	in the chosen subsources (which we choose) ^Z, Y^, all
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 505.
listItem	listItem	strings in C = C(^Z‚Ä≤, Y^) are in R(^Z, Y^). First notice
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 506.
listItem	listItem	that as Z‚Ä≤ is fixed, C is only a function of Y. We
listItem	listItem	set Y~ to be the subsource of Y that fixes all strings
listItem	listItem	in C = C(Y) to their most popular values (losing
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 509.
listItem	listItem	only ‚Ñìm entropy from Y). We take care of includ-
listItem	listItem	ing these fixed strings in R(Z, Y~) one at a time, by
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 511.
listItem	listItem	restricting to subsources assuring that. Let œÉ be any
listItem	listItem	m-bit string we want to appear in R(Z, Y~). Recall that
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 513.
listItem	listItem	R(z, y) = V(E(z, i), E(y, i)). We pick a ‚Äùgood‚Äù seed i,
listItem	listItem	and restrict Z, Y~ to subsources with only O(m) less
listItem	listItem	entropy by fixing E(Z, i) = a and E(Y~, i) = b to values
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 516.
listItem	listItem	(a, b) for which V(a, b) = œÉ. This is repeated suc-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 517.
listItem	listItem	cessively ‚Ñì times, and results in the final subsources
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 518.
listItem	listItem	^Z, Y^ on which ^Z‚Ä≤ fails with probability 1. Note that
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 519.
listItem	listItem	we keep reducing the entropy of our sources ‚Ñì times,
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 520.
listItem	listItem	which necessitates that this ‚Ñì be tiny (here we could
listItem	listItem	not tolerate poly(n), and indeed can guarantee no(1),
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 522.
listItem	listItem	at least on a subsource ‚Äì this is one aspect of how cru-
listItem	listItem	cial the subsource somewhere extractor SSE is to the
listItem	listItem	construction.
bodyText	listItem	We note that initially it seemed like the Challenge-Response
bodyText	bodyText	mechanism as used in [4] could not be used to handle en-
bodyText	bodyText	tropy that is significantly less than -,/n (which is approxi-
bodyText	bodyText	mately the bound that many of the previous constructions
bodyText	bodyText	got stuck at). The techniques of [4] involved partitioning
bodyText	bodyText	the sources into t pieces of length n/t each, with the hope
bodyText	bodyText	that one of those parts would have a significant amount of
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 532.
bodyText	bodyText	entropy, yet there‚Äôd be enough entropy left over in the rest
bodyText	bodyText	of the source (so that the source can be partitioned into a
bodyText	bodyText	block source).
bodyText	bodyText	However it is not clear how to do this when the total
bodyText	bodyText	entropy is less than -,/n. On the one hand we will have
bodyText	bodyText	to partition our sources into blocks of length significantly
bodyText	bodyText	more than -,/n (or the adversary could distribute a negligible
bodyText	bodyText	fraction of entropy in all blocks). On the other hand, if
bodyText	bodyText	our blocks are so large, a single block could contain all the
bodyText	bodyText	entropy. Thus it was not clear how to use the challenge
bodyText	bodyText	response mechanism to find a block source.
sectionHeader	bodyText	4. THE SUBSOURCE SOMEWHERE
sectionHeader	sectionHeader	EXTRACTOR SSE
bodyText	sectionHeader	We now explain some of the ideas behind the construction
bodyText	bodyText	of the subsource somewhere extractor SSE of Theorem 2.6.
bodyText	bodyText	Consider the source X. We are seeking to find in it a some-
bodyText	bodyText	where c-block-source, so that we can use it (together with Y)
bodyText	bodyText	in the block-source extractor of Theorem 2.8. Like in previ-
bodyText	bodyText	ous works in the extractor literature (e.g. [19, 13]) we use a
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 551.
bodyText	bodyText	‚Äùwin-win‚Äù analysis which shows that either X is already a
bodyText	bodyText	somewhere c-block-source, or it has a condensed part which
bodyText	bodyText	contains a lot of the entropy of the source. In this case we
bodyText	bodyText	proceed recursively on that part. Continuing this way we
bodyText	bodyText	eventually reach a source so condensed that it must be a
bodyText	bodyText	somewhere block source. Note that in [4], the challenge re-
bodyText	bodyText	sponse mechanism was used to find a block source also, but
bodyText	bodyText	there the entropy was so high that they could afford to use
page	bodyText	675
figure	page	Not Somewhere block source	n bits total
figure	figure			t blocks			Outputs
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 562.
figure	figure	< k‚Äô
figure	figure	Challenge Challenge
figure	figure	responded responded
figure	figure	X
figure	figure	low
figure	figure	med
figure	figure	high
figure	figure	n/t bits total
figure	figure	t blocks
figure	figure	Challenge Unresponded
figure	figure	SB
figure	figure	Somewhere Block Source!
figure	figure	med
figure	figure	med
figure	figure	low
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 577.
figure	figure	0< low < k‚Äô/t
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 578.
figure	figure	k‚Äô/t < med < k‚Äô/c
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 579.
figure	figure	k‚Äô/c < high < k‚Äô
figure	figure	high
figure	figure	med
figure	figure	Random Row
figure	figure	med
figure	figure	SB
figureCaption	figure	Figure 1: Analysis of the subsource somewhere extractor.
figureCaption	figureCaption	a tree of depth 1. They did not need to recurse or condense
figureCaption	figureCaption	the sources.
bodyText	figureCaption	Consider the tree of parts of the source X evolved by
bodyText	bodyText	such recursion. Each node in the tree corresponds to some
bodyText	bodyText	interval of bit locations of the source, with the root node
bodyText	bodyText	corresponding to the entire source. A node is a child of an-
bodyText	bodyText	other if its interval is a subinterval of the parent. It can be
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 593.
bodyText	bodyText	shown that some node in the tree is ‚Äùgood‚Äù; it corresponds
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 594.
bodyText	bodyText	to a somewhere c-source, but we don‚Äôt know which node is
bodyText	bodyText	good. Since we only want a somewhere extractor, we can
bodyText	bodyText	apply to each node the somewhere block-source extractor of
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 597.
bodyText	bodyText	Corollary 2.8 ‚Äì this will give us a random output in every
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 598.
bodyText	bodyText	‚Äùgood‚Äù node of the tree. The usual idea is output all these
bodyText	bodyText	values (and in seeded extractors, merge them using the ex-
bodyText	bodyText	ternally given random seed). However, we cannot afford to
bodyText	bodyText	do that here as there is no external seed and the number of
bodyText	bodyText	these outputs (the size of the tree) is far too large.
bodyText	bodyText	Our aim then will be to significantly prune this number
bodyText	bodyText	of candidates and in fact output only the candidates on one
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 605.
bodyText	bodyText	path to a canonical‚Äùgood‚Äù node. First we will give a very in-
bodyText	bodyText	formal description of how to do this (Figure 1). Before call-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 607.
bodyText	bodyText	ing SSE recursively on a subpart of a current part of X, we‚Äôll
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 608.
bodyText	bodyText	use the ‚ÄùChallenge-Response‚Äù mechanism described above
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 609.
bodyText	bodyText	to check if ‚Äùit has entropy‚Äù.4 We will recurse only with the
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 610.
bodyText	bodyText	first (in left-to-right order) part which passes the ‚Äùentropy
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 611.
bodyText	bodyText	test‚Äù. Thus note that we will follow a single path on this
bodyText	bodyText	tree. The algorithm SSE will output only the sets of strings
bodyText	bodyText	produced by applying the somewhere c-block-extractor SB
bodyText	bodyText	on the parts visited along this path.
bodyText	bodyText	Now let us describe the algorithm for SSE. SSE will be
bodyText	bodyText	initially invoked as SSE(x, y), but will recursively call itself
bodyText	bodyText	with different inputs z which will always be substrings of x.
footnote	bodyText	4We note that we ignore the additional complication that
footnote	footnote	SSE will actually use recursion also to compute the challenge
footnote	footnote	in the challenge-response mechanism.
construct	footnote	Algorithm: SSE(z, y)
bodyText	construct	Let pSE(., .) be the somewhere extractor with a polyno-
bodyText	bodyText	mial number of outputs of Proposition 2.3.
bodyText	bodyText	Let SB be the somewhere block source extractor of Corol-
bodyText	bodyText	lary 2.8.
bodyText	bodyText	Global Parameters: t, the branching factor of the tree. k
bodyText	bodyText	the original entropy of the sources.
bodyText	bodyText	Output will be a set of strings.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 629.
listItem	bodyText	1. If z is shorter than ‚àök, return the empty set, else
listItem	listItem	continue.
listItem	listItem	2. Partition z into t equal parts z = z1, z2, ... ,zt.
listItem	listItem	3. Compute the response set R(z, y) which is the set of
listItem	listItem	strings output by pSE(z, y).
listItem	listItem	4. For i E [t], compute the challenge set C(zi, y), which
listItem	listItem	is the set of outputs of SSE(zi, y).
listItem	listItem	5. Let h be the smallest index for which the challenge set
listItem	listItem	C(zh, y) is not contained in the response set (set h = t
listItem	listItem	if no such index exists).
listItem	listItem	6. Output SB(z, y) concatenated with SSE(zh, y).
listItem	listItem	Proving that indeed there are subsources on which SSE
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 641.
listItem	listItem	will follow a path to a ‚Äùgood‚Äù (for these subsources) node,
listItem	listItem	is the heart of the analysis. It is especially complex due
listItem	listItem	to the fact that the recursive call to SSE on subparts of
listItem	listItem	the current part is used to generate the Challenges for the
listItem	listItem	Challenge-Response mechanism. Since SSE works only on
listItem	listItem	a subsources we have to guarantee that restriction to these
listItem	listItem	does not hamper the behavior of SSE in past and future calls
listItem	listItem	to it.
listItem	listItem	Let us turn to the highlights of the analysis, for the proof
listItem	listItem	of Theorem 2.6. Let k' be the entropy of the source Z at
listItem	listItem	some place in this recursion. Either one of its blocks Zi has
page	listItem	676
bodyText	page	entropy k'/c, in which case it is very condensed, since its
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 654.
bodyText	bodyText	size is n/t for t ‚â´ c), or it must be that c of its blocks form
bodyText	bodyText	a c-block source with block entropy k'/t (which is sufficient
bodyText	bodyText	for the extractor B used by SB). In the 2nd case the fact
bodyText	bodyText	that SB(z, y) is part of the output of of our SSE guarantees
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 658.
bodyText	bodyText	that we are somewhere random. If the 2nd case doesn‚Äôt hold,
bodyText	bodyText	let Zi be the leftmost condensed block. We want to ensure
bodyText	bodyText	that (on appropriate subsources) SSE calls itself on that ith
bodyText	bodyText	subpart. To do so, we fix all Zj for j < i to constants zj. We
bodyText	bodyText	are now in the position described in the Challenge-Response
bodyText	bodyText	mechanism section, that (in each of the first i parts) there
bodyText	bodyText	is either no entropy or lots of entropy. We further restrict
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 665.
bodyText	bodyText	to subsources as explained there which make all first i ‚àí 1
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 666.
bodyText	bodyText	blocks fail the ‚Äùentropy test‚Äù, and the fact that Zi still has
bodyText	bodyText	lots of entropy after these restrictions (which we need to
bodyText	bodyText	prove) ensures that indeed SSE will be recursively applied
bodyText	bodyText	to it.
bodyText	bodyText	We note that while the procedure SSE can be described re-
bodyText	bodyText	cursively, the formal analysis of fixing subsources is actually
bodyText	bodyText	done globally, to ensure that indeed all entropy requirements
bodyText	bodyText	are met along the various recursive calls.
bodyText	bodyText	Let us remark on the choice of the branching parameter t.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 675.
bodyText	bodyText	On the one hand, we‚Äôd like to keep it small, as it dominates
bodyText	bodyText	the number of outputs tc of SB, and thus the total number of
bodyText	bodyText	outputs (which is tc logt n). For this purpose, any t = no(1)
bodyText	bodyText	will do. On the other hand, t should be large enough so that
bodyText	bodyText	condensing is faster than losing entropy. Here note that if
bodyText	bodyText	Z is of length n, its child has length n/t, while the entropy
bodyText	bodyText	shrinks only from k' to k'/c. A simple calculation shows that
bodyText	bodyText	if k(lo9t)/lo9c) > n2 then a c block-source must exist along
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 683.
bodyText	bodyText	such a path before the length shrinks to ‚àök. Note that for
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 684.
bodyText	bodyText	k = nŒ©(1) a (large enough) constant t suffices (resulting in
bodyText	bodyText	only logarithmic number of outputs of SSE). This analysis
bodyText	bodyText	is depicted pictorially in Figure 1.
sectionHeader	bodyText	5. THE FINAL DISPERSER D
bodyText	sectionHeader	Following is a rough description of our disperser D proving
bodyText	bodyText	Theorem 2.1. The high level structure of D will resemble the
bodyText	bodyText	structure of SSE - we will recursively split the source X and
bodyText	bodyText	look for entropy in the parts. However now we must output
bodyText	bodyText	a single value (rather than a set) which can take both values
bodyText	bodyText	0 and 1. This was problematic in SSE, even knowing where
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 694.
bodyText	bodyText	the ‚Äùgood‚Äù part (containing a c-block-source) was! How can
bodyText	bodyText	we do so now?
bodyText	bodyText	We now have at our disposal a much more powerful tool
bodyText	bodyText	for generating challenges (and thus detecting entropy), namely
bodyText	bodyText	the subsource somewhere disperser SSE. Note that in con-
bodyText	bodyText	structing SSE we only had essentially the somewhere c-block-
bodyText	bodyText	source extractor SB to (recursively) generate the challenges,
bodyText	bodyText	but it depended on a structural property of the block it was
bodyText	bodyText	applied on. Now SSE does not assume any structure on its
bodyText	bodyText	input sources except sufficient entropy 5.
bodyText	bodyText	Let us now give a high level description of the disperser
bodyText	bodyText	D. It too will be a recursive procedure. If when processing
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 706.
bodyText	bodyText	some part Z of X it ‚Äùrealizes‚Äù that a subpart Zi of Z has
bodyText	bodyText	entropy, but not all the entropy of Z (namely Zi, Z is a
bodyText	bodyText	2-block-source) then we will halt and produce the output
bodyText	bodyText	of D. Intuitively, thinking about the Challenge-Response
bodyText	bodyText	mechanism described above, the analysis implies that we
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 711.
footnote	bodyText	5There is a catch ‚Äì it only works on subsources of them!
footnote	footnote	This will cause us a lot of head ache; we will elaborate on it
footnote	footnote	later.
footnote	footnote	can either pass or fail Zi (on appropriate subsources). But
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 715.
footnote	footnote	this means that the outcome of this ‚Äùentropy test‚Äù is a 1-bit
footnote	footnote	disperser!
footnote	footnote	To capitalize on this idea, we want to use SSE to identify
footnote	footnote	such a block-source in the recursion tree. As before, we scan
footnote	footnote	the blocks from left to right, and want to distinguish three
footnote	footnote	possibilities.
footnote	footnote	low Zi has low entropy. In this case we proceed to i + 1.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 722.
footnote	footnote	medium Zi has ‚Äùmedium‚Äù entropy (Zi, Z is a block-source).
footnote	footnote	In which case we halt and produce an output (zero or
footnote	footnote	one).
footnote	footnote	high Zi has essentially all entropy of Z. In this case we
footnote	footnote	recurse on the condensed block Zi.
footnote	footnote	As before, we use the Challenge-Response mechanism (with
footnote	footnote	a twist). We will compute challenges C(Zi, Y) and responses
footnote	footnote	R(Z, Y), all strings of length m. The responses are computed
footnote	footnote	exactly as before, using the somewhere extractor pSE. The
footnote	footnote	Challenges are computed using our subsource somewhere
footnote	footnote	extractor SSE.
footnote	footnote	We really have 4 possibilities to distinguish, since when we
footnote	footnote	halt we also need to decide which output bit we give. We will
footnote	footnote	do so by deriving three tests from the above challenges and
footnote	footnote	responses: (CH, RH), (CM, RM), (CL, RL) for high, medium
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 737.
footnote	footnote	and low respectively, as follows. Let m ‚â• mH >> mM >>
footnote	footnote	mL be appropriate integers: then in each of the tests above
footnote	footnote	we restrict ourselves to prefixes of all strings of the appro-
footnote	footnote	priate lengths only. So every string in CM will be a prefix
footnote	footnote	of length mM of some string in CH. Similarly, every string
footnote	footnote	in RL is the length mL prefix of some string in RH. Now
footnote	footnote	it is immediately clear that if CM is contained in RM, then
footnote	footnote	CL is contained in RL. Thus these tests are monotone, if
footnote	footnote	our sample fails the high test, it will definitely fail all tests.
construct	footnote	Algorithm: D(z, y)
bodyText	construct	Let pSE(., .) be the somewhere extractor with a polyno-
bodyText	bodyText	mial number of outputs of Proposition 2.3.
bodyText	bodyText	Let SSE(.,.) be the subsource somewhere extractor of The-
bodyText	bodyText	orem 2.6.
bodyText	bodyText	Global Parameters: t, the branching factor of the tree. k
bodyText	bodyText	the original entropy of the sources.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 753.
bodyText	bodyText	Local Parameters for recursive level: mL ‚â™ mM ‚â™ mH.
bodyText	bodyText	Output will be an element of {0, 1}.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 755.
listItem	bodyText	1. If z is shorter than ‚àök, return 0.
listItem	listItem	2. Partition z into t equal parts z = z1, z2, ... , zt.
listItem	listItem	3. Compute three response sets RL, RM, RH using pSE(z, y).
listItem	listItem	Rj will be the prefixes of length mj of the strings in
listItem	listItem	pSE(z, y).
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 760.
listItem	listItem	4. For each i ‚àà [t], compute three challenge sets CiL, CiM, CiH
listItem	listItem	using SSE(zi, y). Cij will be the prefixes of length mj
listItem	listItem	of the strings in SSE(zi, y).
listItem	listItem	5. Let h be the smallest index for which the challenge set
listItem	listItem	CL is not contained in the response set RL, if there is
listItem	listItem	no such index, output 0 and halt.
listItem	listItem	6. If ChH is contained in RH and ChH is contained in RM,
listItem	listItem	output 0 and halt. If ChH is contained in RH but ChH
listItem	listItem	is not contained in RM, output 1 and halt.
page	listItem	677
figure	page	t blocks
figure	figure	X
figure	figure	low
figure	figure	fail
figure	figure	fail
figure	figure	fail
figure	figure	X_3
figure	figure	(X_3)_4
figure	figure	low
figure	figure	low
figure	figure	fail
figure	figure	fail
figure	figure	fail
figure	figure	fail
figure	figure	fail
figure	figure	fail
figure	figure	low
figure	figure	low
figure	figure	pass
figure	figure	pass
figure	figure	pass
figure	figure	high
figure	figure	low
figure	figure	low
figure	figure	t blocks
figure	figure	low
figure	figure	high
figure	figure	t blocks
figure	figure	med
figure	figure	n bits total
figure	figure	n/t bits total
figure	figure	n/t^2 bits total
figure	figure	fail
figure	figure	fail
figure	figure	fail
figure	figure	fail
figure	figure	fail
figure	figure	fail
figure	figure	pass
figure	figure	pass
figure	figure	fail
figure	figure	pass
figure	figure	fail
figure	figure	fail
figure	figure	Output 0	Output 1
figureCaption	figure	Figure 2: Analysis of the disperser.
listItem	figureCaption	7. Output D(zh, y),
bodyText	listItem	First note the obvious monotonicity of the tests. If Zi fails
bodyText	bodyText	one of the tests it will certainly fail for shorter strings. Thus
bodyText	bodyText	there are only four outcomes to the three tests, written in the
bodyText	bodyText	order (low, medium, high): (pass, pass, pass), (pass, pass, fail),
bodyText	bodyText	(pass, fail, fail) and (fail, fail, fail). Conceptually, the algo-
bodyText	bodyText	rithm is making the following decisions using the four tests:
listItem	bodyText	1. (fail, fail, fail): Assume Zi has low entropy and proceed
listItem	listItem	to block i + 1.
listItem	listItem	2. (pass, fail, fail): Assume Zi is medium, halt and output
listItem	listItem	0.
listItem	listItem	3. (pass, pass, fail): Assume Zi is medium, halt and out-
listItem	listItem	put 1.
listItem	listItem	4. (pass, pass, pass): Assume Zi is high and recurse on Zi.
bodyText	listItem	The analysis of this idea (depicted in Figure 2).turns out
bodyText	bodyText	to be more complex than it seems. There are two reasons for
bodyText	bodyText	that. Now we briefly explain them and the way to overcome
bodyText	bodyText	them in the construction and analysis.
bodyText	bodyText	The first reason is the fact mentioned above, that SSE
bodyText	bodyText	which generates the challenges, works only on a subsources
bodyText	bodyText	of the original sources. Restricting to these subsources at
bodyText	bodyText	some level of the recursion (as required by the analysis of of
bodyText	bodyText	the test) causes entropy loss which affects both definitions
bodyText	bodyText	(such as these entropy thresholds for decisions) and correct-
bodyText	bodyText	ness of SSE in higher levels of recursion. Controlling this en-
bodyText	bodyText	tropy loss is achieved by calling SSE recursively with smaller
bodyText	bodyText	and smaller entropy requirements, which in turn limits the
bodyText	bodyText	entropy which will be lost by these restrictions. In order not
bodyText	bodyText	to lose all the entropy for this reason alone, we must work
bodyText	bodyText	with special parameters of SSE, essentially requiring that at
bodyText	bodyText	termination it has almost all the entropy it started with.
bodyText	bodyText	The second reason is the analysis of the test when we are
bodyText	bodyText	in a medium block. In contrast with the above situation, we
bodyText	bodyText	cannot consider the value of Zi fixed when we need it to fail
bodyText	bodyText	on the Medium and Low tests. We need to show that for
bodyText	bodyText	these two tests (given a pass for High), they come up both
bodyText	bodyText	(pass, fail) and (fail, fail) each with positive probability.
bodyText	bodyText	Since the length of Medium challenges and responses is
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 854.
bodyText	bodyText	mM, the probability of failure is at least exp(‚àíQ(mM)) (this
bodyText	bodyText	follows relatively easily from the fact that the responses are
bodyText	bodyText	somewhere random). If the Medium test fails so does the
bodyText	bodyText	Low test, and thus (fail, fail) has a positive probability and
bodyText	bodyText	our disperser D outputs 0 with positive probability.
bodyText	bodyText	To bound (pass, fail) we first observe (with a similar
bodyText	bodyText	reasoning) that the low test fails with probability at least
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 861.
bodyText	bodyText	exp(‚àíQ(mL)). But we want the medium test to pass at the
bodyText	bodyText	same time. This probability is at least the probability that
bodyText	bodyText	low fails minus the probability that medium fails. We already
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 864.
bodyText	bodyText	have a bound on the latter: it is at most poly(n)exp(‚àí‚ÑìmM).
bodyText	bodyText	Here comes our control of the different length into play - we
bodyText	bodyText	can make the mL sufficiently smaller than mM to yield this
bodyText	bodyText	difference positive. We conclude that our disperser D out-
bodyText	bodyText	puts 1 with positive probability as well.
bodyText	bodyText	Finally, we need to take care of termination: we have to
bodyText	bodyText	ensure that the recurrence always arrives at a medium sub-
bodyText	bodyText	part, but it is easy to chose entropy thresholds for low, medium
bodyText	bodyText	and high to ensure that this happens.
page	bodyText	678
sectionHeader	page	6. RESILIENCY AND DEFICIENCY
bodyText	sectionHeader	In this section we will breifly discuss an issue which arises
bodyText	bodyText	in our construction that we glossed over in the previous sec-
bodyText	bodyText	tions. Recall our definition of subsources:
construct	bodyText	DEfInItIOn 6.1 (SUBSOURCES). Given random variables
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 879.
construct	construct	Z and ZÀÜ on {0,1}n we say that ZÀÜ is a deficiency d subsource
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 880.
construct	construct	of Z and write ZÀÜ ‚äÜ Z if there exists a set A ‚äÜ {0,1}n such
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 881.
construct	construct	that (Z|A) = ZÀÜ and Pr[Z ‚àà A] ‚â• 2‚Äîd.
bodyText	construct	Recall that we were able to guarantee that our algorithms
bodyText	bodyText	made the right decisions only on subsources of the original
bodyText	bodyText	source. For example, in the construction of our final dis-
bodyText	bodyText	perser, to ensure that our algorithms correctly identify the
bodyText	bodyText	right high block to recurse on, we were only able to guar-
bodyText	bodyText	antee that there are subsources of the original sources in
bodyText	bodyText	which our algorithm makes the correct decision with high
bodyText	bodyText	probability. Then, later in the analysis we had to further
bodyText	bodyText	restrict the source to even smaller subsources. This leads to
bodyText	bodyText	complications, since the original event of picking the correct
bodyText	bodyText	high block, which occurred with high probability, may be-
bodyText	bodyText	come an event which does not occur with high probability
bodyText	bodyText	in the current subsource. To handle these kinds of issues,
bodyText	bodyText	we will need to be very careful in measuring how small our
bodyText	bodyText	subsources are.
bodyText	bodyText	In the formal analysis we introduce the concept of re-
bodyText	bodyText	siliency to deal with this. To give an idea of how this works,
bodyText	bodyText	here is the actual definition of somewhere subsource extrac-
bodyText	bodyText	tor that we use in the formal analysis.
construct	bodyText	DEfInItIOn 6.2 (SUBSOURCE SOmEWhERE ExtRaCtOR).
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 902.
bodyText	construct	A function SSE : {0, 1}n √ó {0, 1}n ‚Üí ({0, 1}m)‚Ñì is a sub-
bodyText	bodyText	source somewhere extractor with nrows output rows, entropy
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 904.
bodyText	bodyText	threshold k, deficiency def, resiliency res and error «´ if for
bodyText	bodyText	every (n, k)-sources X, Y there exist a deficiency def sub-
bodyText	bodyText	source Xgood of X and a deficiency def subsource Ygood of
bodyText	bodyText	Y such that for every deficiency res subsource X' of Xgood
bodyText	bodyText	and deficiency res subsource Y' of Ygood, the random vari-
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 909.
bodyText	bodyText	able SSE(X',Y') is «´-close to a ‚Ñì √ó m somewhere random
bodyText	bodyText	distribution.
bodyText	bodyText	It turns out that our subsource somewhere extractor does
bodyText	bodyText	satisfy this stronger definition. The advantage of this defi-
bodyText	bodyText	nition is that it says that once we restrict our attention to
bodyText	bodyText	the good subsources Xgood, Ygood, we have the freedom to fur-
bodyText	bodyText	ther restrict these subsources to smaller subsources, as long
bodyText	bodyText	as our final subsources do not lose more entropy than the
bodyText	bodyText	resiliency permits.
bodyText	bodyText	This issue of managing the resiliency for the various ob-
bodyText	bodyText	jects that we construct is one of the major technical chal-
bodyText	bodyText	lenges that we had to overcome in our construction.
sectionHeader	bodyText	7. OPEN PROBLEMS
bodyText	sectionHeader	Better Independent Source Extractors A bottleneck to
bodyText	bodyText	improving our disperser is the block versus general
bodyText	bodyText	source extractor of Theorem 2.7. A good next step
bodyText	bodyText	would be to try to build an extractor for one block
bodyText	bodyText	source (with only a constant number of blocks) and
bodyText	bodyText	one other independent source which works for polylog-
bodyText	bodyText	arithmic entropy, or even an extractor for a constant
bodyText	bodyText	number of sources that works for sub-polynomial en-
bodyText	bodyText	tropy.
bodyText	bodyText	Simple Dispersers While our disperser is polynomial time
bodyText	bodyText	computable, it is not as explicit as one might have
bodyText	bodyText	hoped. For instance the Ramsey Graph construction
bodyText	bodyText	of Frankl-Wilson is extremely simple: For a prime p,
bodyText	bodyText	let the vertices of the graph be all subsets of [p3] of
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 936.
bodyText	bodyText	size p2 ‚àí 1. Two vertices S, T are adjacent if and only
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 937.
bodyText	bodyText	if |S ‚à© T | ‚â° ‚àí1 mod p. It would be nice to find a good
bodyText	bodyText	disperser that beats the Frankl-Wilson construction,
bodyText	bodyText	yet is comparable in simplicity.
sectionHeader	bodyText	8. REFERENCES
reference	sectionHeader	[1] N. Alon. The shannon capacity of a union.
reference	reference	Combinatorica, 18, 1998.
reference	reference	[2] B. Barak. A simple explicit construction of an
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 944.
reference	reference	nÀúo(logn )-ramsey graph. Technical report, Arxiv, 2006.
reference	reference	http://arxiv.org/abs/math.CO/0601651.
reference	reference	[3] B. Barak, R. Impagliazzo, and A. Wigderson.
reference	reference	Extracting randomness using few independent sources.
reference	reference	In Proceedings of the 45th Annual IEEE Symposium
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 949.
reference	reference	on Foundations of Computer Science, pages 384‚Äì393,
reference	reference	2004.
reference	reference	[4] B. Barak, G. Kindler, R. Shaltiel, B. Sudakov, and
reference	reference	A. Wigderson. Simulating independence: New
reference	reference	constructions of condensers, Ramsey graphs,
reference	reference	dispersers, and extractors. In Proceedings of the 37th
reference	reference	Annual ACM Symposium on Theory of Computing,
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 956.
reference	reference	pages 1‚Äì10, 2005.
reference	reference	[5] J. Bourgain. More on the sum-product phenomenon in
reference	reference	prime fields and its applications. International Journal
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 959.
reference	reference	of Number Theory, 1:1‚Äì32, 2005.
reference	reference	[6] J. Bourgain, N. Katz, and T. Tao. A sum-product
reference	reference	estimate in finite fields, and applications. Geometric
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 962.
reference	reference	and Functional Analysis, 14:27‚Äì57, 2004.
reference	reference	[7] M. Capalbo, O. Reingold, S. Vadhan, and
reference	reference	A. Wigderson. Randomness conductors and
reference	reference	constant-degree lossless expanders. In Proceedings of
reference	reference	the 34th Annual ACM Symposium on Theory of
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 967.
reference	reference	Computing, pages 659‚Äì668, 2002.
reference	reference	[8] B. Chor and O. Goldreich. Unbiased bits from sources
reference	reference	of weak randomness and probabilistic communication
reference	reference	complexity. SIAM Journal on Computing,
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 971.
reference	reference	17(2):230‚Äì261, 1988.
reference	reference	[9] P. Frankl and R. M. Wilson. Intersection theorems
reference	reference	with geometric consequences. Combinatorica,
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 974.
reference	reference	1(4):357‚Äì368, 1981.
reference	reference	[10] P. Gopalan. Constructing ramsey graphs from boolean
reference	reference	function representations. In Proceedings of the 21th
reference	reference	Annual IEEE Conference on Computational
reference	reference	Complexity, 2006.
reference	reference	[11] V. Grolmusz. Low rank co-diagonal matrices and
reference	reference	ramsey graphs. Electr. J. Comb, 7, 2000.
reference	reference	[12] V. Guruswami. Better extractors for better codes?
reference	reference	Electronic Colloquium on Computational Complexity
reference	reference	(ECCC), (080), 2003.
reference	reference	[13] C. J. Lu, O. Reingold, S. Vadhan, and A. Wigderson.
reference	reference	Extractors: Optimal up to constant factors. In
reference	reference	Proceedings of the 35th Annual ACM Symposium on
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 987.
reference	reference	Theory of Computing, pages 602‚Äì611, 2003.
reference	reference	[14] P. Miltersen, N. Nisan, S. Safra, and A. Wigderson.
reference	reference	On data structures and asymmetric communication
reference	reference	complexity. Journal of Computer and System
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 991.
reference	reference	Sciences, 57:37‚Äì49, 1 1998.
page	reference	679
reference	page	[15] N. Nisan and D. Zuckerman. More deterministic
reference	reference	simulation in logspace. In Proceedings of the 25th
reference	reference	Annual ACM Symposium on Theory of Computing,
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 996.
reference	reference	pages 235‚Äì244, 1993.
reference	reference	[16] P. Pudlak and V. Rodl. Pseudorandom sets and
reference	reference	explicit constructions of ramsey graphs. Submitted for
reference	reference	publication, 2004.
reference	reference	[17] A. Rao. Extractors for a constant number of
reference	reference	polynomially small min-entropy independent sources.
reference	reference	In Proceedings of the 38th Annual ACM Symposium
reference	reference	on Theory of Computing, 2006.
reference	reference	[18] R. Raz. Extractors with weak random seeds. In
reference	reference	Proceedings of the 37th Annual ACM Symposium on
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 1006.
reference	reference	Theory of Computing, pages 11‚Äì20, 2005.
reference	reference	[19] O. Reingold, R. Shaltiel, and A. Wigderson.
reference	reference	Extracting randomness via repeated condensing. In
reference	reference	Proceedings of the 41st Annual IEEE Symposium on
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 1010.
reference	reference	Foundations of Computer Science, pages 22‚Äì31, 2000.
reference	reference	[20] M. Santha and U. V. Vazirani. Generating
reference	reference	quasi-random sequences from semi-random sources.
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 1013.
reference	reference	Journal of Computer and System Sciences, 33:75‚Äì87,
reference	reference	1986.
reference	reference	[21] R. Shaltiel. Recent developments in explicit
reference	reference	constructions of extractors. Bulletin of the European
reference	reference	Association for Theoretical Computer Science,
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 1018.
reference	reference	77:67‚Äì95, 2002.
reference	reference	[22] A. Ta-Shma and D. Zuckerman. Extractor codes.
reference	reference	IEEE Transactions on Information Theory, 50, 2004.
reference	reference	[23] U. Vazirani. Towards a strong communication
reference	reference	complexity theory or generating quasi-random
reference	reference	sequences from two communicating slightly-random
reference	reference	sources (extended abstract). In Proceedings of the 17th
reference	reference	Annual ACM Symposium on Theory of Computing,
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 1026.
reference	reference	pages 366‚Äì378, 1985.
reference	reference	[24] A. Wigderson and D. Zuckerman. Expanders that
reference	reference	beat the eigenvalue bound: Explicit construction and
Wide character in print at ../bin/prepareTagData.pl line 107, <IF> line 1029.
reference	reference	applications. Combinatorica, 19(1):125‚Äì138, 1999.
page	reference	680
