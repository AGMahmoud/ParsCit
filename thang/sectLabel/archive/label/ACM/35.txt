title ||| An Intensional Approach to the Specification of Test Cases
title ||| for Database Applications
author ||| David Willmor
affiliation ||| School of Computer Science
affiliation ||| University of Manchester
address ||| Oxford Road, Manchester, UK
email ||| d.willmor@cs.manchester.ac.uk
email ||| ABSTRACT
bodyText ||| When testing database applications, in addition to creating
bodyText ||| in-memory fixtures it is also necessary to create an initial
bodyText ||| database state that is appropriate for each test case. Cur-
bodyText ||| rent approaches either require exact database states to be
bodyText ||| specified in advance, or else generate a single initial state
bodyText ||| (under guidance from the user) that is intended to be suit-
bodyText ||| able for execution of all test cases. The first method allows
bodyText ||| large test suites to be executed in batch, but requires con-
bodyText ||| siderable programmer effort to create the test cases (and
bodyText ||| to maintain them). The second method requires less pro-
bodyText ||| grammer effort, but increases the likelihood that test cases
bodyText ||| will fail in non-fault situations, due to unexpected changes
bodyText ||| to the content of the database. In this paper, we propose a
bodyText ||| new approach in which the database states required for test-
bodyText ||| ing are specified intensionally, as constrained queries, that
bodyText ||| can be used to prepare the database for testing automati-
bodyText ||| cally. This technique overcomes the limitations of the other
bodyText ||| approaches, and does not appear to impose significant per-
bodyText ||| formance overheads.
sectionHeader ||| Categories and Subject Descriptors
category ||| D.2.5 [Software Engineering]: Testing and Debugging—
category ||| Testing tools
sectionHeader ||| General Terms
keyword ||| Experimentation, Verification
sectionHeader ||| Keywords
keyword ||| databases, software testing, database testing
sectionHeader ||| 1. INTRODUCTION
bodyText ||| Modern information systems are typically organised as
bodyText ||| collections of independent application programs that com-
bodyText ||| municate with one another by means of a central database.
bodyText ||| The database records the state of the organisation that the
copyright ||| Permission to make digital or hard copies of all or part of this work for
copyright ||| personal or classroom use is granted without fee provided that copies are
copyright ||| not made or distributed for profit or commercial advantage and that copies
copyright ||| bear this notice and the full citation on the first page. To copy otherwise, to
copyright ||| republish, to post on servers or to redistribute to lists, requires prior specific
copyright ||| permission and/or a fee.
note ||| ICSE’06, May 20–28, 2006, Shanghai, China.
copyright ||| Copyright 2006 ACM 1-59593-085-X/06/0005 ...$5.00.
author ||| Suzanne M. Embury
affiliation ||| School of Computer Science
affiliation ||| University of Manchester
address ||| Oxford Road, Manchester, UK
email ||| s.m.embury@cs.manchester.ac.uk
bodyText ||| information system supports, while the application programs
bodyText ||| implement the business processes that manipulate the state.
bodyText ||| To take a simple but ubiquitous example, a database sys-
bodyText ||| tem might record details of customers, products and sales,
bodyText ||| while the application programs associated with it handle op-
bodyText ||| erations such as new product purchases and update of the
bodyText ||| product catalogue, as well as supporting decision making
bodyText ||| by generating reports regarding the most profitable product
bodyText ||| lines, names and addresses of loss-making customers, etc.
bodyText ||| In order to test such application programs, it is necessary
bodyText ||| to create test fixtures that simulate the presence of the rest
bodyText ||| of the information system. Fixtures for traditional test cases
bodyText ||| typically consist of in-memory objects and data structures
bodyText ||| that provide the inputs to the program being tested. This
bodyText ||| kind of fixture is also needed when testing database appli-
bodyText ||| cations (especially when performing unit testing); however,
bodyText ||| since it is unrealistic (and often incorrect) to execute test
bodyText ||| cases against an empty database, we need to create addi-
bodyText ||| tional fixture elements within the database itself.
bodyText ||| Current practice in the software industry is to maintain
bodyText ||| one or more test databases that can be used for testing in-
bodyText ||| dividual programs. These databases can be artificially gen-
bodyText ||| erated (e.g., using tools such as DBMonster1 and DataFac-
bodyText ||| tory2) or they may be subsets of the live database, taken
bodyText ||| as a snapshot at some recent point in time. Copies of the
bodyText ||| live data sets have the advantage that they are more likely
bodyText ||| to be representative of the patterns of data encountered in
bodyText ||| practice, while artificial data sets have the advantage that
bodyText ||| they can be made to embody specific characteristics (such
bodyText ||| as particular data skew patterns or volumes), which may be
bodyText ||| useful for load and stress testing.
bodyText ||| Both approaches, however, suffer from several disadvan-
bodyText ||| tages. The most significant problem occurs when none of
bodyText ||| the available test databases are suitable starting points for a
bodyText ||| particular test case. For example, suppose a particular test
bodyText ||| case executes a program which purges inactive customers,
bodyText ||| with the aim of verifying that the business rule forbidding
bodyText ||| deletion of customers with negative balances is correctly en-
bodyText ||| forced. If none of the test databases contains any inactive
bodyText ||| customers with negative balances, then the test case can-
bodyText ||| not be executed successfully. For a one-off test run, testing
bodyText ||| personnel can choose a database that is close to what is re-
bodyText ||| quired, and manually update it so that it is suitable for use
bodyText ||| with the test case. But if a complete test suite is to be exe-
bodyText ||| cuted (possibly including test cases which themselves make
bodyText ||| modifications to the database state) then in the worst case
footnote ||| 1http://DBMonster.kernelpanic.pl
footnote ||| 2http://www.quest.com/datafactory
page ||| 102
bodyText ||| this manual intervention will be required in between every
bodyText ||| test case execution. This is clearly undesirable if test suites
bodyText ||| are large or time-consuming to execute, or if the test suite
bodyText ||| is to be run in batch (as in the case of overnight regression
bodyText ||| testing, for example).
bodyText ||| Current research in testing for database systems proposes
bodyText ||| two approaches to this problem. One of these is to include
bodyText ||| within the test case description a full (extensional) specifica-
bodyText ||| tion of the database state against which it is to be run (and
bodyText ||| of the database state that should be produced if the test has
bodyText ||| executed successfully) [13, 14]. This solution is exemplified
bodyText ||| by DBUnit3, an extension of the JUnit testing framework4
bodyText ||| that is designed for testing database applications written in
bodyText ||| Java. Each DBUnit test case is accompanied by an XML
bodyText ||| file describing the data set required for the test. Before each
bodyText ||| test run, DBUnit clears the database state and inserts the
bodyText ||| data described by the XML file.
bodyText ||| This approach has the advantage of simplicity, but it places
bodyText ||| a considerable burden on testing personnel, especially when
bodyText ||| complex database states are required. It is also inefficient,
bodyText ||| since the database must be continually destroyed and recre-
bodyText ||| ated between tests, even when significant parts of the database
bodyText ||| might have been reused by the succeeding tests. Moreover,
bodyText ||| maintenance of a large suite of such tests is extremely chal-
bodyText ||| lenging, since any small change to the database schema may
bodyText ||| require corresponding changes to many test cases.
bodyText ||| The second approach that has been explored in the liter-
bodyText ||| ature is more efficient in that it requires the creation of only
bodyText ||| one database state per test suite (rather than one per test
bodyText ||| case). It is exemplified by the AGENDA database testing
bodyText ||| toolkit [6, 7], which can automatically generate a database
bodyText ||| state given information about the schema, some data gen-
bodyText ||| eration functions for individual attributes and some user-
bodyText ||| selected heuristics describing the kind of database state re-
bodyText ||| quired. The AGENDA tool also generates test cases from a
bodyText ||| simple analysis of the program being verified. The user must
bodyText ||| then add preconditions to each test case that are checked
bodyText ||| just before it is executed and that will prevent a case from
bodyText ||| being executed against an inappropriate database state. This
bodyText ||| approach successfully relieves the user of the need to specify
bodyText ||| complete database states in full detail, but at a cost. The
bodyText ||| user must accept that some of the test cases may not be
bodyText ||| executed because the database state fails the precondition,
bodyText ||| even when it would require only a small change to bring the
bodyText ||| database into a suitable state for the test. Since only one
bodyText ||| database state is created per test suite, this problem of failed
bodyText ||| tests is likely to become more severe as the size of the test
bodyText ||| suite grows. There is also a potential inefficiency involved
bodyText ||| in generating test descriptions and inputs, and in creating
bodyText ||| the additional log tables and constraints/triggers needed by
bodyText ||| the AGENDA tool, for test cases that are not in fact going
bodyText ||| to be executed.
bodyText ||| Ideally, we would prefer to be able to combine the advan-
bodyText ||| tages of both these approaches, to give a form of database
bodyText ||| test case that is quick and natural to specify, and which
bodyText ||| maximises the number of cases within the suite that can be
bodyText ||| executed while minimising the number of full test databases
bodyText ||| that need to be maintained. Our thesis is that this can
bodyText ||| be achieved by allowing testing personnel to describe the
bodyText ||| database states involved in their test cases intensionally, in
footnote ||| 3http://www.dbunit.org
footnote ||| 4http://www.junit.org
bodyText ||| the form of declarative conditions that the input database
bodyText ||| must satisfy, and by providing a testing harness that can
bodyText ||| automatically adjust the input database so that the test
bodyText ||| conditions are satisfied [19].
bodyText ||| In this paper, we present a language for specifying such
bodyText ||| intensional database tests, and describe its semantics and
bodyText ||| operational behaviour (Section 2). We present an algorithm
bodyText ||| for automatically modifying database states so that test pre-
bodyText ||| conditions are satisfied (Section 3), thus ensuring that all
bodyText ||| test cases can be executed without requiring any human
bodyText ||| intervention. We further describe how we have extended the
bodyText ||| JUnit testing framework to allow intensional database tests
bodyText ||| to be specified and executed in practice (Section 4). Finally,
bodyText ||| we present the results of an evaluation of the performance
bodyText ||| of the techniques (Section 5) and conclude (Section 6).
sectionHeader ||| 2. SPECIFYING INTENSIONAL TESTS
bodyText ||| A conventional test case is typically modelled as a triple
bodyText ||| &lt; p, i, o &gt;, which denotes a test that executes program p
bodyText ||| with inputs (e.g., parameters) denoted by i. If no faults are
bodyText ||| encountered during the test execution, the output that will
bodyText ||| be produced is o. In the case of test cases for database ap-
bodyText ||| plications, we must add two further elements—the specifica-
bodyText ||| tion of the database state against which p is to be executed,
bodyText ||| and some statement of the database state that should result
bodyText ||| from the execution of p if it is operating correctly according
bodyText ||| to its specification.
bodyText ||| For example, consider the example program mentioned
bodyText ||| in Section 1 that prunes inactive customer details from the
bodyText ||| database. For this test case, we require a database state that
bodyText ||| contains at least one inactive customer. This could easily
bodyText ||| be stated as a predicate logic condition over the database,
bodyText ||| assuming the obvious mapping between stored relations and
bodyText ||| predicates, e.g.:
construct ||| (3custNo, lastOrderOn, a, b, c)
construct ||| customer(custNo, a, b, c, lastOrderOn) n
construct ||| lastOrderOn &lt; today — 90
bodyText ||| The program in question does not access any parts of the
bodyText ||| database other than the customer table. Therefore, we do
bodyText ||| not care what values the other tables contain and need not
bodyText ||| mention them in the intensional specification of the test.
bodyText ||| This approach works equally well for observing the results
bodyText ||| of the test. For example, when testing the customer pruning
bodyText ||| behaviour, we might require that no inactive customer with
bodyText ||| a non-negative balance should exist in the database after
bodyText ||| the test:
construct ||| -((3custNum, lastOrderDate, a, b, c)
construct ||| customer(custNum, a, bal, c, lastOrderDate) n
construct ||| lastOrderDate &lt; today — 90 n bal &gt; 0)
bodyText ||| Effectively, the test case describes a set of valid (i.e., fault-
bodyText ||| free) state transition for the database, as a classic pre/post-
bodyText ||| condition pair.
bodyText ||| This first-order-logic style of database specification does
bodyText ||| not work so well when we consider the testing problem in
bodyText ||| more depth, however. The problem is that we need to do
bodyText ||| more than test the input database for compliance with the
bodyText ||| requirements of the test case; we also need to extract in-
bodyText ||| formation from it to be used to instantiate other elements
page ||| 103
bodyText ||| of the test case. For example, suppose we wish to test a
bodyText ||| program that deletes details of individual customers. Such
bodyText ||| programs typically require some input from the user, identi-
bodyText ||| fying the specific customer record that is to be deleted (e.g.,
bodyText ||| by supplying the relevant customer code as a parameter).
bodyText ||| This could be achieved by requiring the tester to embed the
bodyText ||| customer code into the test case elements, as literal values.
bodyText ||| Alternatively, we could search for a suitable customer that
bodyText ||| already exists in the database, using a standard database
bodyText ||| query, and use the values from that in specifying the inputs
bodyText ||| for the test case. This would minimise the amount of work
bodyText ||| required to prepare the database for test execution (since we
bodyText ||| would be using data already present in the database), and it
bodyText ||| would also mean that test cases can be written very quickly,
bodyText ||| since the user does not need to specify every last detail of
bodyText ||| the data to be used.
bodyText ||| Under this approach, the specification of the input database
bodyText ||| state now has a dual role: it must state the condition that
bodyText ||| determines whether the database state is suitable for execu-
bodyText ||| tion of the test case and it must also return bindings for the
bodyText ||| free variables that appear in the remaining components of
bodyText ||| the test case. For the latter purpose, we would prefer to use
bodyText ||| a straightforward query language, while for the former we
bodyText ||| require the ability to place conditions on the data. With a
bodyText ||| simple extension of a standard query language such as SQL,
bodyText ||| we can combine both these purposes in a single statement.
bodyText ||| For example, the following statement:
construct ||| ANY :cn GENERATED BY
construct ||| SELECT custNo FROM customer
construct ||| WHERE lastOrderDate &lt; today() - 90
construct ||| AND balance &lt; 0
bodyText ||| retrieves the customer code of some record that meets the
bodyText ||| given conditions (an inactive customer with negative bal-
bodyText ||| ance) from the database, and binds it to the variable : cn.
bodyText ||| It also places a cardinality constraint on the result of the
bodyText ||| query, that at least one such binding must exist (implied by
bodyText ||| the use of the keyword ANY).
bodyText ||| The variable : cn can then be used to specify other ele-
bodyText ||| ments of the test case. The obvious usage in this example is
bodyText ||| in specifying the inputs to the program being tested, but it
bodyText ||| can also be used in describing the expected outputs of the
bodyText ||| program. In this example test case, the correct behaviour
bodyText ||| of the DeleteCustomer program is to reject the deletion
bodyText ||| of : cn, since customers with a negative balance cannot be
bodyText ||| purged from the database. We might therefore give the fol-
bodyText ||| lowing specification of the desired output database state:
construct ||| AT LEAST 1 :cn2 GENERATED BY
construct ||| SELECT custNo FROM customer
construct ||| WHERE custNo = :cn
bodyText ||| Of course, not all test cases are best specified in terms of
bodyText ||| values retrieved from the database. For example, suppose
bodyText ||| that we wish to write test cases for a program that adds new
bodyText ||| customers to the database. The inputs to this program are
bodyText ||| the details of the new customer, and the precondition for one
bodyText ||| particular test case states that no customer should exist that
bodyText ||| has the same customer code as that of the customer being
bodyText ||| created. We cannot retrieve the customer details from the
bodyText ||| database in this case, as they have not yet been stored in it.
bodyText ||| Again, we could force the user to include the required values
bodyText ||| as literals in the test case, but ideally we would like to give
figure ||| &lt;CONDITION&gt;::= &lt;TYPE&gt; &lt;BINDINGLIST&gt;
figure ||| GENERATED BY &lt;SELECT&gt;
figure ||| &lt;TYPE&gt;::= ANY I NO I AT LEAST &lt;i&gt; I
figure ||| AT MOST &lt;i&gt; EXACTLY &lt;i&gt; |
figure ||| ALL I FIRST
figure ||| &lt;i&gt;::= {0-9}
figure ||| &lt;BINDINGLIST&gt;
figure ||| ::=&lt;BINDING&gt; { ‘,’ &lt;BINDINGLIST&gt; }
figure ||| &lt;BINDING&gt;::= {A-Z I a-z}
figure ||| &lt;SELECT&gt; ::= ...
figureCaption ||| Figure 1: Simplified BNF Grammar for SQL Exten-
figureCaption ||| sions
bodyText ||| more support to the process of test case generation. One
bodyText ||| way to achieve this is to allow user-defined data generator
bodyText ||| functions to be incorporated within queries as though they
bodyText ||| were relations. For example, the following expression states
bodyText ||| our requirements for this test case, while also binding the
bodyText ||| variables needed for input to the program:
construct ||| ANY :cn, :name, :addr, :bal GENERATED BY
construct ||| SELECT gc.custno, gc.name, gc.addr, 0
construct ||| FROM genCustomerDetails() AS gc
construct ||| WHERE gc.custno NOT IN (
construct ||| SELECT custno
construct ||| FROM customer
construct ||| WHERE balance &gt; 0)
bodyText ||| Here, the data generator function getCustomerDetails ( )
bodyText ||| is used as if it were a normal relation, whereas in fact the
bodyText ||| results it returns are computed on the fly. In fact, several
bodyText ||| of the main commercial database management systems al-
bodyText ||| ready allow user-defined functions to be embedded in queries
bodyText ||| in this way, so this does not require a further extension of
bodyText ||| SQL. Figure 1 shows the minimal extensions that are needed
bodyText ||| to support all the kinds of constrained query shown above
bodyText ||| using the SQL99 standard [17].
subsectionHeader ||| 2.1 Test Case Semantics
bodyText ||| Clearly, the semantics of these intensional database test
bodyText ||| cases is more complex than for traditional extensional tests.
bodyText ||| However, we can define their semantics formally in terms
bodyText ||| of a mapping from intensional tests to sets of equivalent
bodyText ||| extensional database test cases. We first present a formal
bodyText ||| definition of the structure of our intensional test cases:
construct ||| DefInItIOn 1. An intensional database test case is a quin-
construct ||| tuple &lt; p, i, DBi, o, DBo &gt;, where:
listItem ||| •	p is the program to be executed in the test,
listItem ||| •	i is a tuple of n variables and literals that describes the
listItem ||| inputs to be given to program p, where n is the number
listItem ||| of parameters expected by p,
listItem ||| •	DBi is a set of constrained queries that together specify
listItem ||| the initial database state.
listItem ||| •	o is a tuple of m variables and literal that describes the
listItem ||| expected outputs from the program p.
listItem ||| •	DBo is a set of constrained queries that together specify
listItem ||| the conditions that must hold in the database state after
listItem ||| execution of p if no fault has been encountered.
page ||| 104
bodyText ||| A constrained query has the form &lt; Q, min, max, vars &gt;,
bodyText ||| where Q is a standard relational algebra query, min and
bodyText ||| max describe the constraints on the cardinality of the query
bodyText ||| result set, and vars is the list of variables bound by the
bodyText ||| query result.
bodyText ||| A database test case is well-formed for use with a partic-
bodyText ||| ular database schema Σ iff:
listItem ||| 9 for every variable v that occurs free in i, DBi, o and
listItem ||| DBo, there exists a query in DBi that provides a bind-
listItem ||| ing for v,
listItem ||| 9 for every query &lt; q, n, m, vs &gt; in DBi U DBo, q is a
listItem ||| well-formed query over Σ that returns k-tuples, where
listItem ||| IvsI = k, and
listItem ||| 9 there are no circular variable dependencies amongst
listItem ||| the queries in DBi.
bodyText ||| We can now define a semantics for the intensional database
bodyText ||| test cases as follows. Every intensional test case is equivalent
bodyText ||| to a set of extensional test cases. An extensional test case
bodyText ||| defines a specific test run, in terms of actual inputs and
bodyText ||| outputs, rather than expressions denoting sets of inputs and
bodyText ||| outputs. The set of all possible extensional test cases is
bodyText ||| given by:
equation ||| PxGnxDBxGxDB
bodyText ||| where P is the set of all programs, G is the set of all lit-
bodyText ||| erals, Gn is the set of all n-tuples formed from G and DB
bodyText ||| is the set of all database states (relative to all schemas)5.
bodyText ||| The components of each extensional test are the program
bodyText ||| to be tested, the input values, the initial database state,
bodyText ||| the expected output and the expected final database state,
bodyText ||| respectively.
bodyText ||| An intensional test case is effectively a shorthand expres-
bodyText ||| sion for a set of extensional test cases that are all derived
bodyText ||| from the same equivalence partition of the test case inputs.
bodyText ||| An intensional database test &lt; p, i, DBi, o, DBo &gt;, where
bodyText ||| DBi = {&lt; qi, ni, mi, vi &gt;} and DBo = {&lt; qo, no, mo, vo &gt;},
bodyText ||| is equivalent to the following set of extensional tests:
equation ||| {&lt; p, i[vi/v], dbi, o[vi/v], dbo &gt; I
equation ||| dbi E DB n
equation ||| (ni &lt;_ Iqi(dbi)I &lt;_ mi) n
equation ||| v E qi(dbi) n
equation ||| dbo E DB n
equation ||| (no &lt;_ I (qo [vi /v])(dbo)I &lt;_ mo)}
bodyText ||| We use the notation exp[01/02] to express the substitution of
bodyText ||| the values in 01 by the corresponding values in 02 whereever
bodyText ||| they occur in exp. Therefore, this expression denotes the set
bodyText ||| of extensional tests where the input database satisfies the
bodyText ||| constraints imposed by the initial constrained query, and
bodyText ||| where the bindings from execution of that query (here ex-
bodyText ||| pressed as the tuple of variables v) are substituted into the
footnote ||| 5For simplicity of presentation, we assume that all programs
footnote ||| require the same number of inputs (n). In practice, n can
footnote ||| be the largest number of inputs required by any program,
footnote ||| and the unused values can be filled with nulls.
bodyText ||| expressions defining the inputs, expected output and ex-
bodyText ||| pected final database state before they too are evaluated 6.
bodyText ||| The idea underlying this notion of an intensional test is
bodyText ||| that when any of its corresponding extensional sets are ex-
bodyText ||| ecuted, the intensional test is itself deemed to have been
bodyText ||| executed. Thus, the use of intensional tests allows much
bodyText ||| greater freedom at test execution time, since we may choose
bodyText ||| any of the possible extensional tests, depending on which is
bodyText ||| closest to our starting environment. In the next section, we
bodyText ||| will consider the practical ramifications of this approach to
bodyText ||| testing, and describe how the semantics just described can
bodyText ||| be implemented in practice.
sectionHeader ||| 3. DATABASE PREPARATION
bodyText ||| The execution of an intensional database test case con-
bodyText ||| sists of three distinct phases: 1) preparation of the environ-
bodyText ||| ment for test execution; 2) execution of the test with the
bodyText ||| prepared inputs; and 3) capture and storage of the results,
bodyText ||| for later analysis. Since all the work of finding bindings
bodyText ||| for the variables in the test case specification is done in the
bodyText ||| preparation phase, the final two phases are straightforward
bodyText ||| and differ little from standard testing procedures. When
bodyText ||| program execution is complete, the constrained query that
bodyText ||| determines whether the test has been successful or not is
bodyText ||| evaluated against the database, and the output from the
bodyText ||| program is checked against what is expected. In the case
bodyText ||| of test failure, the details of the actual extensional test that
bodyText ||| was executed are recorded, for diagnosis purposes.
bodyText ||| The first phase, however, is more complex. If we were
bodyText ||| content to execute only those test cases which happen to
bodyText ||| be suitable for use with the initial database state, then the
bodyText ||| preparation phase would simply be a matter of executing
bodyText ||| the input constrained queries against the database and, if
bodyText ||| they are all successful, using the bindings thus produced
bodyText ||| to instantiate the remaining components of the test case.
bodyText ||| However, thanks to the declarative nature of our test case
bodyText ||| specifications, the testing framework can be pro-active in
bodyText ||| cases where the given database is not suitable for use by
bodyText ||| the test case, and can automatically generate a sequence of
bodyText ||| updates that will cause the constrained queries to produce
bodyText ||| the required number of bindings.
bodyText ||| In fact, this problem is similar (though not identical) to
bodyText ||| one that has been studied by the database and artificial in-
bodyText ||| telligence communities for many years. It is known variously
bodyText ||| as the view update problem [9], the knowledge base update
bodyText ||| problem [12], and the transaction repair problem [10]. Many
bodyText ||| database systems have the capability to define views on top
bodyText ||| of the basic database. A view is a kind of virtual relation.
bodyText ||| To the user, it appears to be a normal relation, but it con-
bodyText ||| tains no stored data. Instead, the contents of the view are
bodyText ||| defined by a expression over other relations, and attempts
bodyText ||| to retrieve data from the view are converted into queries
bodyText ||| over these relations. To take a simple example for illustra-
bodyText ||| tion, we might create a view called Debtors which appears
bodyText ||| to be a relation of the same name containing all customers
bodyText ||| with a negative balance. Attempts to retrieve Debtors is
footnote ||| 6For simplicity of presentation, we assume here that there
footnote ||| is only one query in each of DBi and DBo. In practice,
footnote ||| it may be necessary to include several queries, each pro-
footnote ||| ducing different bindings and imposing different cardinality
footnote ||| constraints. In this case, the constraints must be conjoined,
footnote ||| and the full set of bindings can be retrieved by performing
footnote ||| a natural join of all the queries, with join condition true.
page ||| 105
bodyText ||| converted into a query against the customer table with an
bodyText ||| added constraint on the balance.
bodyText ||| If views are truly to act as normal relations then it should
bodyText ||| be possible to update them as well query them. But what
bodyText ||| does it mean to update a virtual relation? In this case, the
bodyText ||| view update must be converted into a sequence of updates
bodyText ||| on the stored relations that will cause the desired change in
bodyText ||| the contents of the view itself. This is a non-trivial problem
bodyText ||| for realistic view languages, and becomes even more difficult
bodyText ||| when we move into the context of knowledge bases, where
bodyText ||| virtual relations can be defined using rules over other rela-
bodyText ||| tions, and when we add integrity constraints that must be
bodyText ||| maintained by all updates [1, 2, 3, 4, 5, 8, 11].
bodyText ||| Only in very narrow circumstances does a view update
bodyText ||| have a single translation into real updates [15, 18]. Various
bodyText ||| heuristics for selecting from amongst the possible transla-
bodyText ||| tions have been proposed (of which the most common is to
bodyText ||| choose the update that results in the smallest change to the
bodyText ||| existing data set [2]), but in real applications user input is
bodyText ||| needed in order to identify the translation that corresponds
bodyText ||| most closely to the real world state that the database should
bodyText ||| reflect [10].
bodyText ||| In the case of intensional database tests, we have a query
bodyText ||| (the constrained query that describes our requirements for
bodyText ||| the test) that does not produce the correct number of an-
bodyText ||| swers when executed against the test database. We need to
bodyText ||| find a sequence of updates to the base data that will cause
bodyText ||| our query to produce the number of answers we need. How-
bodyText ||| ever, in this case, there is no requirement to find the set of
bodyText ||| updates that matches the state of reality — any sensible up-
bodyText ||| date that satisfies the query conditions will be acceptable.
bodyText ||| This simplifies the problem considerably, removing the need
bodyText ||| for complex search procedures and for any user input.
subsectionHeader ||| 3.1 The Preparation Algorithm
bodyText ||| One of the advantages of using a query-based language
bodyText ||| for test specification (as opposed to a predicate calculus-
bodyText ||| based language) is that we can make use of a very common
bodyText ||| and easy-to-analyse internal form for (relational) database
bodyText ||| queries, called relational algebra. This form provides a small
bodyText ||| number of operations on relations that can be combined to
bodyText ||| form complex queries. For example, the three most basic
bodyText ||| (and useful) relational algebra operators are:
listItem ||| 9 The projection operator, πAttsR, which creates a re-
listItem ||| lation from R by deleting all attributes not in Atts.
listItem ||| For example, π[Country]Customer produces a relation
listItem ||| that contains just the countries that appear in the
listItem ||| Customer relation.
listItem ||| 9 The selection operator, QcR, which creates a relation
listItem ||| that contains all the rows from relation R that satisfy
listItem ||| the condition c. For example, Qbal&lt;0 Customer returns
listItem ||| a relation containing details of all customers with neg-
listItem ||| ative balances.
listItem ||| 9 The join operator, R ✶c S, which creates a relation
listItem ||| containing rows from the cross product of R and S that
listItem ||| satisfy the join condition c. The query Debtor ✶dNo=WNo
listItem ||| Inactive returns details of all debtors who are also in-
listItem ||| active.
bodyText ||| Since the result of each relational algebra operator is itself
bodyText ||| a relation, together they form a closed algebra. This means
bodyText ||| that we can form arbitrarily complex queries by applying
bodyText ||| operators to the results of other operators. For example, a
bodyText ||| query which retrieves the customer number of all customers
bodyText ||| with a negative balance would be written as:
equation ||| π[custNo] (Qbalance&lt;0 Customer)
bodyText ||| A common way to visualise such expressions is as a tree of
bodyText ||| operators. The tree for the above query is shown in Figure 2.
figureCaption ||| Figure 2: Relational Algebra Tree for Negative Bal-
figureCaption ||| ance Query.
bodyText ||| Our algorithm for preparing a database for testing is based
bodyText ||| around this notion of a relational algebra tree. We take the
bodyText ||| cardinality constraints from the test specification, and push
bodyText ||| them down through the nodes of the input database query
bodyText ||| tree, collecting up additional conditions as we go. When we
bodyText ||| reach a leaf node (i.e. a base relation), we make updates
bodyText ||| to the database so that the pushed-down constraints are
bodyText ||| satisfied for that relation.
bodyText ||| At each stage, we collect up the different kinds of con-
bodyText ||| straint and push them further down into the tree. These
bodyText ||| constraint types are:
listItem ||| 9 Min and Max, the upper and lower bounds on the de-
listItem ||| sired cardinality of the result set.
listItem ||| 9 SelC, the selection conditions on the relations that we
listItem ||| are interested in.
listItem ||| 9 UAtts, the collection of attributes that are used in the
listItem ||| constrained query, and that must be populated in any
listItem ||| new data that we insert.
bodyText ||| We also build up a collection of queries that describe the
bodyText ||| data that has been prepared for testing so far, as we progress
bodyText ||| through the tree. We call these queries “bindings” (Bgs),
bodyText ||| since they give us values for the variables that occur within
bodyText ||| the selection and join conditions. At each stage, the bindings
bodyText ||| should contain one query for each leaf node that has so far
bodyText ||| been prepared.
bodyText ||| It is easiest to see how this works by considering a simple
bodyText ||| example, such as that shown in Figure 2. Let us assume we
bodyText ||| have a constrained query that requires at least one customer
bodyText ||| with negative balance to exist, and that our database does
bodyText ||| not currently contain any such customers. We begin at the
bodyText ||| root node of the tree, with only the cardinality constraints
bodyText ||| extracted from the test specification:
equation ||| Min = 1, Max = null, SelC = true,
equation ||| UAtts = 0, Bgs = 0
bodyText ||| The top node is a projection operator. Projection does not
bodyText ||| affect the cardinality of the result set, nor impose any condi-
bodyText ||| tions, but it does tell us something about the attributes used
page ||| 106
figureCaption ||| Figure 3: Relational Algebra Tree Showing Multiple
figureCaption ||| Joins
bodyText ||| by the query. We therefore add the projection attributes to
bodyText ||| UAtts and push the constraints down to the next node:
equation ||| Min = 1, Max = null, SelC = true,
equation ||| UAtts = {custNo}, Bgs = 0
bodyText ||| Next we must deal with the selection node. Selection nodes
bodyText ||| reduce the cardinality of their input, so we need to push
bodyText ||| down the selection conditions to ensure that any updates
bodyText ||| we may make affect the correct tuples. We also need to add
bodyText ||| any attributes appearing in the selection condition to UAtts:
equation ||| Min = 1, Max = null, SelC = balance &lt; 0,
equation ||| UAtts = {custNo, balance}, Bgs = 0
bodyText ||| The final node is the leaf node, representing the Customer
bodyText ||| relation. We construct a query from the conditions on that
bodyText ||| relation and execute it, to find out how many answers are
bodyText ||| currently in the database. In this case, there are none, so
bodyText ||| we need to insert a new Customer record with at least
bodyText ||| the custNo and balance attributes populated, and with
bodyText ||| a negative balance. If there are any integrity constraints
bodyText ||| on this relation, then we need to make sure they are also
bodyText ||| satisfied by the new data.
bodyText ||| We use the DBMonster data generator mentioned earlier
bodyText ||| to create the new data. It allows generation functions to
bodyText ||| be specified for attributes, and additional constraints to be
bodyText ||| placed on them. It will also maintain primary key, foreign
bodyText ||| key, non-null and domain constraints if configured appro-
bodyText ||| priately using the information present in the pushed-down
bodyText ||| constraints.
bodyText ||| Of course, this is a very simple example. In general, we
bodyText ||| can expect to have to deal with more complicated queries
bodyText ||| involving several joins, such as that shown in Figure 3. This
bodyText ||| relational algebra tree is equivalent to the following con-
bodyText ||| strained query:
construct ||| ANY :orderNo, :productNo GENERATED BY
construct ||| SELECT o.orderno, p.productno
construct ||| FROM Order o, Orderdetail d, Product p
construct ||| WHERE o.orderno = d.orderno AND
construct ||| d.productno = p.productno AND
construct ||| p.price &gt; 50
bodyText ||| which requires that at least one order must exist that in-
bodyText ||| volves the purchase of at least one product that costs more
bodyText ||| than £50. Joins complicate the process of preparing the
bodyText ||| database, because they introduce dependencies between the
bodyText ||| updates that take place at different leaf nodes. For example,
bodyText ||| imagine that we have processed the tree shown in Figure 3 as
bodyText ||| far as the leaf node representing the OrderDetail relation.
bodyText ||| Join operators further constrain the selection condition (by
bodyText ||| conjoining in their join condition), but add no other con-
bodyText ||| straints. So, by the time we reach this leaf node, SelC will
bodyText ||| have been set to:
equation ||| o.orderno = d.orderno A d.productno = p.productno
bodyText ||| We need to find out whether a suitable OrderDetail record
bodyText ||| exists within the database. However, in order to do this,
bodyText ||| we need to know something about what preparation actions
bodyText ||| were performed when the Product leaf node was processed.
bodyText ||| Maybe there were already plenty of £50-plus products in
bodyText ||| the catalogue, or maybe there were none and one had to
bodyText ||| be created. How is this information passed through to the
bodyText ||| OrderDetail node so that the correct tuple can be identi-
bodyText ||| fied or created?
bodyText ||| In the current version of our algorithm, we have chosen
bodyText ||| to use the database itself to communicate these values. If
bodyText ||| there are many suitable Product records, then we can find
bodyText ||| one by querying the database directly once again. If a new
bodyText ||| product had to be created, then it will now be present in
bodyText ||| the database, so we can still retrieve it by querying. The
bodyText ||| information needed to construct these queries is present in
bodyText ||| the selection conditions that have been considered during
bodyText ||| the processing of the relational algebra tree up to this point.
bodyText ||| For example, in order to search for an OrderDetail tuple
bodyText ||| that is connected to a suitable Product, we need to issue
bodyText ||| the following query:
construct ||| SELECT d.* FROM OrderDetail d, Product p
construct ||| WHERE d.productno = p.productno AND
construct ||| p.price &gt; 50
bodyText ||| This query cannot be constructed from only the constraints
bodyText ||| pushed-down from the parent nodes of the leaf node; instead,
bodyText ||| we need to collect up the constraints imposed by all nodes
bodyText ||| visited before the current node, so that they are available for
bodyText ||| query formation. This is done using the Bgs data structure
bodyText ||| mentioned earlier.
bodyText ||| Figure 4 presents the complete algorithm, showing the be-
bodyText ||| haviour required for each different type of operator. The al-
bodyText ||| gorithm is presented as a side-effecting function which takes
bodyText ||| the constrained query that is to be satisfied by the database,
bodyText ||| and a set of initial conditions that state the required cardi-
bodyText ||| nality bounds and initialise SelC to true, UAtts to 0 and Bgs
bodyText ||| to 0. The function returns a set of bindings, but these are
bodyText ||| discarded. The main task of the algorithm is carried out
bodyText ||| by the side-effecting updates that occur when leaf nodes are
bodyText ||| processed.
sectionHeader ||| 4. DOT-UNIT TESTING FRAMEWORK
bodyText ||| The intensional database test language and accompanying
bodyText ||| preparation algorithm have been implemented within a test-
bodyText ||| ing tool, called DOT- Unit. This tool is part of a larger Data-
bodyText ||| Oriented Testing7 framework that is under development at
bodyText ||| the University of Manchester [20]. DOT-Unit has been im-
bodyText ||| plemented as an extension to the JUnit testing framework
footnote ||| 7http://www.cs.man.ac.uk/—willmord/dot/
page ||| 107
figure ||| Projection operator
figure ||| prepare(irattsQ, Min, Max, UAtts, SelC, Bgs)
figure ||| = prepare(Q, Min, Max, UAtts U Atts, SelC, Bgs)
figure ||| Selection operator
figure ||| prepare(acQ, Min, Max, UAtts, SelC, Bgs)
figure ||| = prepare(Q, Min, Max, UAtts, SelC n c, Bgs)
figure ||| Join operator
figure ||| prepare(Q1 ✶jc Q2, Min, Max, UAtts, SelC, Bgs)
figure ||| = prepare(Q2, Min, Max, UAtts, SelC n jc,
figure ||| prepare(Q1, Min, Max, UAtts, SelC, Bgs))
figure ||| Relation (leaf node)
figure ||| prepare(Rasv, Min, Max, UAtts, SelC, Bgs)
figure ||| Q = bindingQuery(v, SelC, Bgs)
figure ||| Execute Q to produce result set RS
figure ||| if IRSI &lt; Min then
figure ||| Invoke DBMonster to create (Min - IRSI) more
figure ||| instances of R that satisfy the conditions in Q
figure ||| else if IRSI &gt; Max then
figure ||| Delete the first (IRSI - Max) tuples in RS
figure ||| else
figure ||| No preparation updates needed
figure ||| return (Bgs U binding(v, Q))
figureCaption ||| Figure 4: The Database Preparation Algorithm
bodyText ||| for the unit testing of Java applications [16]. We have sub-
bodyText ||| classed the standard JUnit TestCase class, to create a ded-
bodyText ||| icated DatabaseTestCase class for specifying and man-
bodyText ||| aging intensional database tests. DatabaseTestCase pro-
bodyText ||| vides facilities for specifying pre-conditions on database state,
bodyText ||| generating and manipulating the bindings that are produced
bodyText ||| by such pre-conditions, and evaluating post-conditions on
bodyText ||| the database state after the test has been completed. The
bodyText ||| standard JUnit methods for determining the results of test
bodyText ||| execution on the in-memory fixture can also be used.
figureCaption ||| Figure 5 shows an example DatabaseTestCase that in-
figureCaption ||| cludes two individual tests. The first verifies that when a
figureCaption ||| customer with a non-negative balance is deleted, all cus-
figureCaption ||| tomers with that customer number really do disappear from
figureCaption ||| the database. The second uses a data generation function to
figureCaption ||| propose attribute values for a new customer record (includ-
figureCaption ||| ing a unique customer number), and checks that after the
figureCaption ||| program has executed only one customer with the generated
figureCaption ||| customer number exists.
bodyText ||| We use a prefixed colon to indicate variables that are
bodyText ||| shared amongst the test components — a notation that will
bodyText ||| be familiar to many database programmers, since it is com-
bodyText ||| monly used in various forms of embedded SQL. The shared
bodyText ||| variables acquire their values when the test harness evalu-
bodyText ||| ates the precondition (and performs any necessary database
bodyText ||| preparation steps). These values can then be accessed us-
bodyText ||| ing the binding method, and can be used in arbitrarily
bodyText ||| complex assert conditions, as well as in instantiating the
bodyText ||| post-condition query.
bodyText ||| One of the main advantages of using the JUnit framework
bodyText ||| as the basis for the implementation of DOT-Unit is that it
bodyText ||| allows us to integrate our tool seamlessly into existing de-
bodyText ||| velopment environments, such as Eclipse8. Thus, DOT-Unit
bodyText ||| tests are executed in exactly the same way as a standard JU-
bodyText ||| nit test case, and the results are displayed using the same
bodyText ||| interface components. This allows testing of database and
bodyText ||| non-database components to be interleaved in a convenient
bodyText ||| and natural manner.
footnote ||| 8http://www.eclipse.org
sectionHeader ||| 5. EVALUATION
bodyText ||| The practicality of this intensional test case approach de-
bodyText ||| pends largely on the performance overhead imposed by the
bodyText ||| database preparation algorithm. If the time required to ex-
bodyText ||| ecute each individual test case is significantly higher using
bodyText ||| our approach than with DBUnit, say, then fewer tests will
bodyText ||| be able to be executed in the time available and the benefits
bodyText ||| of faster test development and fewer spurious test failures
bodyText ||| will be negated.
bodyText ||| To gain a handle on the degree of performance overhead
bodyText ||| to be expected from DOT-Unit, we made use of an exist-
bodyText ||| ing extensional DB test suite that we created for earlier
bodyText ||| work [20]. This suite was designed for mp3cd browser9, an
bodyText ||| open-source Java/JDBC program that stories information
bodyText ||| about mp3 files in a MySQL 5.0 database10. The schema
bodyText ||| of the database consists of 6 relations with 22 attributes, 7
bodyText ||| primary key constraints and 6 foreign key constraints. We
bodyText ||| created an equivalent intensional test suite, consisting of 20
bodyText ||| test cases, from the extensional suite by converting each test
bodyText ||| case into DOT-Unit pre- and post-conditions. We also re-
bodyText ||| placed each hard-coded test parameter in the original tests
bodyText ||| into constrained query bindings.
bodyText ||| We wanted to investigate two specific aspects of the per-
bodyText ||| formance of DOT-Unit. First, we wanted to compare its
bodyText ||| performance with that of DBUnit over the equivalent test
bodyText ||| cases as the database size grows. Second, we wanted to gain
bodyText ||| some idea of what aspects of DB preparation and testing
bodyText ||| were dominating the performance of DOT-Unit. The re-
bodyText ||| sults of the experiments we performed are presented below.
bodyText ||| All experiments were run on a Pentium-M 2.0GHz machine,
bodyText ||| with 1Gb RAM, running Ubuntu Linux.
subsectionHeader ||| 5.1 Comparison with DBUnit
bodyText ||| At first sight, the extensional approach, as exemplified
bodyText ||| by DBUnit, would seem to be the more efficient method
bodyText ||| of the two, as the testing harness does not need to spend
bodyText ||| any time figuring out what updates need to be made prior
bodyText ||| to each test—it only needs to execute them. This does
footnote ||| 9http://mp3cdbrowser.sourceforge.net/mp3cd/
footnote ||| 10http://www.mysql.com
page ||| 108
figure ||| public class ProgramTest extends DatabaseTestCase {
figure ||| public void testDeleteCustomer() {
figure ||| preCondition(&quot;ANY :cn GENERATED BY SELECT custNo FROM customer WHERE balance &gt; 0;&quot;);
figure ||| Program p = new Program();
figure ||| p.deleteCustomer(binding(&quot;:cn&quot;));
figure ||| postCondition(&quot;NO :cn2 GENERATED BY SELECT custno FROM customer WHERE custNo = :cn;&quot;);
figure ||| }
figure ||| public void testNewCustomer() {
figure ||| preCondition(&quot;ANY :cn, :name, :addr GENERATED BY SELECT gc.custNo, gc.name, gc.addr FROM
figure ||| genCustomerDetails() AS gc WHERE gc.custNo NOT IN (SELECT custNo FROM customer);&quot;);
figure ||| Program p = new Program();
figure ||| boolean b = p.newCustomer(binding(&quot;:cn&quot;), binding(&quot;:name&quot;), binding(&quot;:addr&quot;));
figure ||| assertTrue(b);
figure ||| postCondition(&quot;EXACTLY 1 :cn, :name, :addr GENERATED BY SELECT custno, name, addr
figure ||| FROM customer;&quot;);
figure ||| }
figure ||| }
figureCaption ||| Figure 5: Example DOT-Unit Test Case
bodyText ||| not happen by accident, but because a human programmer
bodyText ||| has spent time earlier, deciding exactly what the database
bodyText ||| should look like for each test case. However, when writing
bodyText ||| DBUnit tests, it is common to try to reuse database de-
bodyText ||| scriptions for multiple test cases where possible, to reduce
bodyText ||| the amount of programming and maintenance time. In this
bodyText ||| case, some redundant updates will be made before each test
bodyText ||| case - updates that our extensional approach will not bother
bodyText ||| to make. It is also the case that DBUnit makes its updates
bodyText ||| blindly, whether they are needed or not, whereas the inten-
bodyText ||| sional approach will be able to reuse much of the existing
bodyText ||| database state for each new test case.
bodyText ||| Given this, it seems likely that the performance of DBUnit
bodyText ||| will be better when the database state required for each
bodyText ||| test case is relatively small, but that the situation will be
bodyText ||| reversed when the database state grows much larger. In
bodyText ||| order to gauge the point at which this change occurs, we
bodyText ||| ran our two test suites (extensional and intensional) with
bodyText ||| databases of varying sizes, and measured the execution time
bodyText ||| taken to execute the whole test suite.
bodyText ||| In each case, we generated initial database states of vary-
bodyText ||| ing sizes at random - either populating the database directly
bodyText ||| (for the intensional test cases) or generating XML descrip-
bodyText ||| tions of the required state (for the extensional test cases).
bodyText ||| The results are shown in Figure 6.
figureCaption ||| Figure 6: Comparison of Approaches as DB Size
figureCaption ||| Increases
bodyText ||| To our surprise, although the performance of DOT-Unit was
bodyText ||| initially worse than that of DBUnit, it overtook its com-
bodyText ||| petitor at a comparatively small database size of around 20
bodyText ||| tuples per relation. Obviously, this experiment is a little
bodyText ||| unfair to DBUnit, since programmers are unlikely to create
bodyText ||| database descriptions consisting of 1000s of tuples per re-
bodyText ||| lation. However, tests of this scale will be needed at some
bodyText ||| point in the development cycle, in order to verify the be-
bodyText ||| haviour of the system on more realistic data sets.
bodyText ||| In order to assess the behaviour of DOT-Unit more pre-
bodyText ||| cisely, consider the graph in Figure 7, which shows the re-
bodyText ||| sults at small databases sizes in more detail. It can be ob-
bodyText ||| served that the performance of DOT-Unit first improves and
bodyText ||| then begins to degrade again at a database size of around
bodyText ||| 50 tuples per relation.
figureCaption ||| Figure 7: Detailed Comparison of Approaches
bodyText ||| One possible explanation for this initial improvement in per-
bodyText ||| formance is that, as the database size rises, so does the
bodyText ||| probability that the data needed for the test case is al-
bodyText ||| ready present in the database. For the very small states,
bodyText ||| a lot of preparation work is required to create the needed
bodyText ||| data, whereas less work is needed for a more fully populated
bodyText ||| database. As the database size increases further, however,
bodyText ||| the costs of making the queries needed to test the precondi-
bodyText ||| tions and formulate the preparation updates rises, pushing
bodyText ||| up the time required for the entire preparation step. This
page ||| 109
bodyText ||| behaviour may be a peculiarity of the particular test suite
bodyText ||| used, of course, and further, more extensive studies will be
bodyText ||| required in order to completely characterise the performance
bodyText ||| of the DOT-Unit test harness.
bodyText ||| From these initial results, however, DOT-Unit appears to
bodyText ||| scale well relative to database size, and the execution times
bodyText ||| are of the same order of magnitude as those resulting from
bodyText ||| DBUnit. This suggests that the intensional approach may
bodyText ||| provide a good compromise between saving expensive pro-
bodyText ||| grammer time in developing new test cases and expenditure
bodyText ||| of cheaper processing time in executing the test cases.
subsectionHeader ||| 5.2 Effect of Constraint Complexity
bodyText ||| A further concern was the effect of increasing constraint
bodyText ||| complexity on the performance of DOT-Unit test cases. How
bodyText ||| much additional overhead is added for conditions involving
bodyText ||| a higher number of selection conditions and (most impor-
bodyText ||| tantly) joins? In order to assess this, we grouped the test
bodyText ||| cases into three groups, according to their complexity:
listItem ||| 9 A: queries with one or more selections and no joins,
listItem ||| 9 B: queries with one or more selections and a join be-
listItem ||| tween two relations,
listItem ||| 9 C: queries with one or more selections and joins be-
listItem ||| tween three relations.
bodyText ||| This gave a test suite with 5 test cases in each of these
bodyText ||| categories, which we executed against a randomly generated
bodyText ||| database state with 500 tuples per relation that does not
bodyText ||| satisfy any of the test case pre-conditions. Figure 8 shows
bodyText ||| the results obtained for the three complexity categories. We
bodyText ||| measured the average time taken to execute the test cases
bodyText ||| in each category, including a breakdown of where the time
bodyText ||| is spent in each case:
listItem ||| 9 Test: the time required to execute the procedural as-
listItem ||| pects of the test case;
listItem ||| 9 Query: the time required to execute the query aspect
listItem ||| of the test case condition;
listItem ||| 9 Prepare the time required to execute the preparation
listItem ||| aspect of the test case condition.
bodyText ||| While the overall time required to execute the test cases rises
bodyText ||| as the complexity rises (unsurprisingly), the relative propor-
bodyText ||| tions of time spent in the various phases remains roughly the
bodyText ||| same. The preparation phase seems to account for slightly
bodyText ||| more than half of the time in each case, indicating that sig-
bodyText ||| nificant improvements could be achieved with a less-naive
bodyText ||| preparation algorithm.
sectionHeader ||| 6. CONCLUSIONS
bodyText ||| We have presented a new approach to the specification
bodyText ||| of test cases for database systems that attempts to reduce
bodyText ||| the amount of manual intervention required in between test
bodyText ||| case runs while also minimising the number of spurious test
bodyText ||| failures due to inappropriate input database states. The ap-
bodyText ||| proach has the further advantage that it sits naturally on top
bodyText ||| of test data sets taken from live databases, and this allows
bodyText ||| testing to be carried out using realistic data sets without re-
bodyText ||| quiring significant programmer effort to tailor the data set to
bodyText ||| the test cases. In effect, the intensional approach we have
figureCaption ||| Figure 8: The Affect of Changing Constraint Com-
figureCaption ||| plexity
bodyText ||| described allows software developers to trade programmer
bodyText ||| time for test execution time
bodyText ||| Our experience has indicated that intensional test cases
bodyText ||| are quick and natural to write for anyone who is familiar
bodyText ||| with SQL and database programming, although a study
bodyText ||| with an independent testing team would be necessary be-
bodyText ||| fore we can make any strong claims in this regard. How-
bodyText ||| ever, compared with what is involved in writing pure JDBC
bodyText ||| database test cases and DBUnit test cases, we found that
bodyText ||| the self-contained nature of the intensional test cases was a
bodyText ||| definite advantage. Writing DBUnit test cases requires the
bodyText ||| programmer to continually check that the test case is com-
bodyText ||| patible with the database description. Moreover, since it is
bodyText ||| common to try to reuse database descriptions for multiple
bodyText ||| test cases by combining their requirements into one database
bodyText ||| state, it becomes very easy to break one test case by chang-
bodyText ||| ing the database description in order to ready it for another.
bodyText ||| These problems do not arise with intensional testing, since
bodyText ||| all the information about the test case is present in a single
bodyText ||| file (the Java class file).
bodyText ||| We designed this first version of the preparation algorithm
bodyText ||| for simplicity and correctness rather than efficiency, and as
bodyText ||| such it performs rather stupidly in many cases. We are cur-
bodyText ||| rently exploring options for improving the algorithm, includ-
bodyText ||| ing more intelligent selection of the order in which the rela-
bodyText ||| tional algebra tree is traversed, alternating between passing
bodyText ||| query bindings and passing literal value bindings as is most
bodyText ||| efficient, and making use of modifications to existing tuples
bodyText ||| as well as simply adding and deleting tuples (both of which
bodyText ||| are comparatively expensive operations). The complexity of
bodyText ||| the conditions we can handle is at present limited by the
bodyText ||| capabilities of DBMonster, and can be expanded by devel-
bodyText ||| opment of a custom data generation facility. We also need
bodyText ||| to expand the range of queries that can be handled, beyond
bodyText ||| simple select-project-join queries. For example, standard
bodyText ||| SQL also allows aggregation and ordering within queries—
bodyText ||| both of which offer challenges in terms of automatic prepa-
bodyText ||| ration.
bodyText ||| A further problem with our current algorithm is that it
bodyText ||| may sometimes fail to find a solution to the database prepa-
bodyText ||| ration problem, even though one exists. This is due to the
bodyText ||| fact that updates are made at leaf nodes before the full set of
bodyText ||| constraints on those nodes has been encountered. It should
page ||| 110
bodyText ||| be possible to address the problem with more sophisticated
bodyText ||| querying techniques (this is an example of a fairly standard
bodyText ||| constrained search problem, after all), although this will add
bodyText ||| to the performance overhead. A thorough study of the trade-
bodyText ||| offs between spurious failures and more intelligent searching
bodyText ||| will need to be carried out before any concrete recommen-
bodyText ||| dations can be made.
bodyText ||| Finally, we note that where it is important to test large
bodyText ||| numbers of frame constraints (i.e. aspects of the original
bodyText ||| database state that are not affected by the execution of the
bodyText ||| program under test), it may be easier to express the test case
bodyText ||| using DBUnit, rather than cluttering up the intensional test
bodyText ||| with many such constraints.
bodyText ||| Our work presents a number of possible avenues for future
bodyText ||| work beyond the improvements mentioned above, of which
bodyText ||| the most urgent is the question of ordering of test cases
bodyText ||| within suites. This ordering can be in terms of reducing the
bodyText ||| cost of the modifications to database state or to maximise
bodyText ||| fault coverage. There is also the question of whether the
bodyText ||| modifications to database state should always persist be-
bodyText ||| tween test cases or under certain conditions discarded. For
bodyText ||| example, a test case may specify that a relation be empty
bodyText ||| and to satisfy the condition the content is discarded. How-
bodyText ||| ever, this relation may be required by later test cases and so
bodyText ||| by discarding its contents we increase the divide between the
bodyText ||| test state and the real world. This could be accomplished
bodyText ||| by either embedding the modifications inside of a transac-
bodyText ||| tion which can then be aborted or by using a hypothetical
bodyText ||| database engine.
sectionHeader ||| 7. ACKNOWLEDGMENTS
bodyText ||| We thank Leonardo Mariani and the anonymous reviewers
bodyText ||| for comments on earlier drafts of this paper. David Willmor
bodyText ||| is supported by a research studentship from the UK Engi-
bodyText ||| neering and Physical Sciences Research Council.
sectionHeader ||| 8. REFERENCES
reference ||| [1] M. Arenas, L. E. Bertossi, and J. Chomicki.
reference ||| Consistent query answers in inconsistent databases. In
reference ||| Proceedings of the 18th ACM
reference ||| SIGACT-SIGMOD-SIGART Symposium on Principles
reference ||| of Database Systems (PODS), pages 68–79. ACM
reference ||| Press, 1999.
reference ||| [2] L. E. Bertossi and J. Chomicki. Query answering in
reference ||| inconsistent databases. In J. Chomicki, R. van der
reference ||| Meyden, and G. Saake, editors, Logics for Emerging
reference ||| Applications of Databases, pages 43–83. Springer,
reference ||| 2003.
reference ||| [3] P. Bohannon, M. Flaster, W. Fan, and R. Rastogi. A
reference ||| cost-based model and effective heuristic for repairing
reference ||| constraints by value modification. In Proceedings of
reference ||| the SIGMOD Conference, pages 143–154. ACM, 2005.
reference ||| [4] L. Bravo and L. E. Bertossi. Logic programs for
reference ||| consistently querying data integration systems. In
reference ||| G. Gottlob and T. Walsh, editors, Proceedings of the
reference ||| 18th International Joint Conference on Artificial
reference ||| Intelligence (IJCAI), pages 10–15. Morgan Kaufmann,
reference ||| August 2003.
reference ||| [5] A. Cali, D. Lembo, and R. Rosati. On the decidability
reference ||| and complexity of query answering over inconsistent
reference ||| and incomplete databases. In Proceedings of the 22nd
reference ||| ACM SIGACT-SIGMOD-SIGART Symposium on
reference ||| Principles of Database Systems (PODS), pages
reference ||| 260–271. ACM, June 2003.
reference ||| [6] D. Chays, S. Dan, P. G. Frankl, F. I. Vokolos, and
reference ||| E. J. Weber. A framework for testing database
reference ||| applications. In Proceedings of the International
reference ||| Symposium on Software Testing and Analysis
reference ||| (ISSTA), pages 147–157, August 2000.
reference ||| [7] D. Chays, Y. Deng, P. G. Frankl, S. Dan, F. I.
reference ||| Vokolos, and E. J. Weyuker. An AGENDA for testing
reference ||| relational database applications. Software Testing,
reference ||| Verification and Reliability, 14(1):17–44, 2004.
reference ||| [8] J. Chomicki and J. Marcinkowski. On the
reference ||| computational complexity of minimal-change integrity
reference ||| maintenance in relational databases. In L. E. Bertossi,
reference ||| A. Hunter, and T. Schaub, editors, Inconsistency
reference ||| Tolerance, volume 3300 of Lecture Notes in Computer
reference ||| Science, pages 119–150. Springer, 2005.
reference ||| [9] S. S. Cosmadakis and C. H. Papadimitriou. Updates
reference ||| of relational views. Journal of the ACM,
reference ||| 31(4):742–760, 1984.
reference ||| [10] S. M. Embury, S. M. Brandt, J. S. Robinson,
reference ||| I. Sutherland, F. A. Bisby, W. A. Gray, A. C. Jones,
reference ||| and R. J. White. Adapting integrity enforcement
reference ||| techniques for data reconciliation. Information
reference ||| Systems, 26(8):657–689, 2001.
reference ||| [11] G. Greco, S. Greco, and E. Zumpano. A logical
reference ||| framework for querying and repairing inconsistent
reference ||| databases. IEEE Transactions on Knowledge and
reference ||| Data Engineering, 15(6):1389–1408, 2003.
reference ||| [12] A. Guessoum and J. W. Lloyd. Updating knowledge
reference ||| bases. New Generation Computing, 8(1):71–89, 1990.
reference ||| [13] F. Haftmann, D. Kossmann, and A. Kreutz. Efficient
reference ||| regression tests for database applications. In
reference ||| Proceedings of the 2nd Biennial Conference on
reference ||| Innovative Data Systems Research (CIDR), pages
reference ||| 95–106. Online Proceedings, January 2005.
reference ||| [14] G. M. Kapfhammer and M. L. Soffa. A family of test
reference ||| adequacy criteria for database-driven applications. In
reference ||| Proceedings of the 11th ACM SIGSOFT Symposium
reference ||| on Foundations of Software Engineering, pages
reference ||| 98–107. ACM, September 2003.
reference ||| [15] R. Langerak. View updates in relational databases
reference ||| with an independent scheme. ACM Transactions on
reference ||| Database Systems (TODS), 15(1):40–66, 1990.
reference ||| [16] P. Louridas. Junit: Unit testing and coding in
reference ||| tandem. IEEE Software, 22(4):12 – 15, July-Aug 2005.
reference ||| [17] J. Melton and A. R. Simon. SQL:1999 Understanding
reference ||| Relational Language Components. Morgan Kaufmann,
reference ||| 2002.
reference ||| [18] H. Shu. Using constraint satisfaction for view update.
reference ||| Journal of Intelligent Information Systems,
reference ||| 15(2):147–173, 2000.
reference ||| [19] D. Willmor and S. M. Embury. Exploring test
reference ||| adequacy for database systems. In Proceedings of the
reference ||| 3rd UK Software Testing Research Workshop
reference ||| (UKTest), pages 123–133. The University of Sheffield,
reference ||| September 2005.
reference ||| [20] D. Willmor and S. M. Embury. A safe regression test
reference ||| selection technique for database–driven applications.
reference ||| In Proceedings of the 21st International Conference on
reference ||| Software Maintenance (ICSM), pages 421–430. IEEE
reference ||| Computer Society, September 2005.
page ||| 111
