note ||| 	Mobile Networks and Applications 9, 9–20, 2004 © 2004 Kluwer Academic Publishers. Manufactured in The Netherlands.
title ||| A Fair and Traffic Dependent Scheduling Algorithm for Bluetooth
title ||| Scatternets
author ||| ROHIT KAPOOR
affiliation ||| University of California, Los Angeles (UCLA), USA
author ||| ANDREA ZANELLA
affiliation ||| University of Padova, Italy
author ||| MARIO GERLA
affiliation ||| University of California, Los Angeles (UCLA), USA
bodyText ||| Abstract. The Bluetooth specification defines the notion of interconnected piconets, called scatternets, but does not define the actual
bodyText ||| mechanisms and algorithms necessary to set up and maintain them. The operation of a scatternet requires some Bluetooth units to be inter-
bodyText ||| piconet units (gateways), which need to time-division multiplex their presence among their piconets. This requires a scatternet-scheduling
bodyText ||| algorithm that can schedule the presence of these units in an efficient manner. In this paper, we propose a distributed scatternet-scheduling
bodyText ||| scheme that is implemented using the HOLD mode of Bluetooth and adapts to non-uniform and changing traffic. Another attribute of the
bodyText ||| scheme is that it results in fair allocation of bandwidth to each Bluetooth unit. This scheme provides an integrated solution for both intra-
bodyText ||| and inter-piconet scheduling, i.e., for polling of slaves and scheduling of gateways.
sectionHeader ||| Keywords: Bluetooth, scatternet, scheduling, fairness
sectionHeader ||| 1. Introduction
bodyText ||| The Bluetooth [10] technology was developed as a replace-
bodyText ||| ment of cables between electronic devices and this is perhaps
bodyText ||| its most obvious use. But, it is the ability of Bluetooth de-
bodyText ||| vices to form small networks called piconets that opens up a
bodyText ||| whole new arena for applications where information may be
bodyText ||| exchanged seamlessly among the devices in the piconet. Typ-
bodyText ||| ically, such a network, referred to as a PAN (Personal Area
bodyText ||| Network), consists of a mobile phone, laptop, palmtop, head-
bodyText ||| set, and other electronic devices that a person carries around
bodyText ||| in his every day life. The PAN may, from time to time, also
bodyText ||| include devices that are not carried along with the user, e.g.,
bodyText ||| an access point for Internet access or sensors located in a
bodyText ||| room. Moreover, devices from other PANs can also be in-
bodyText ||| terconnected to enable sharing of information.
bodyText ||| The networking capabilities of Bluetooth can be further
bodyText ||| enhanced by interconnecting piconets to form scatternets.
bodyText ||| This requires that some units be present in more than one pi-
bodyText ||| conet. These units, called gateways, need to time-division
bodyText ||| their presence among the piconets. An important issue with
bodyText ||| the gateways is that their presence in different piconets needs
bodyText ||| to be scheduled in an efficient manner. Moreover, since the
bodyText ||| gateway cannot receive information from more than one pi-
bodyText ||| conet at a time, there is a need to co-ordinate the presence of
bodyText ||| masters and gateways.
bodyText ||| Some previous work has looked at scheduling in a piconet
bodyText ||| [2,5] and also in a scatternet. In [4], the authors define a
bodyText ||| Rendezvous-Point based architecture for scheduling in a scat-
bodyText ||| ternet, which results in the gateway spending a fixed fraction
bodyText ||| of its time in each piconet. Such a fixed time-division of the
bodyText ||| gateway may clearly be inefficient since traffic is dynamic.
bodyText ||| In [9], the authors propose the Pseudo-Random Coordinated
bodyText ||| Scatternet Scheduling (PCSS) scheme in which Bluetooth
bodyText ||| nodes assign meeting points with their peers. The sequence
bodyText ||| of meeting points follows a pseudo-random process that leads
bodyText ||| to unique meeting points for different peers of a node. The
bodyText ||| intensity of these meeting points may be increased or de-
bodyText ||| creased according to the traffic intensity. This work presents
bodyText ||| performance results for various cases. In [11], a scatternet-
bodyText ||| scheduling algorithm based on the concept of a switch table,
bodyText ||| which can be dynamically adjusted based on traffic load, is
bodyText ||| presented. In [1], the authors present a credit-based schedul-
bodyText ||| ing scheme based on the SNIFF mode of Bluetooth, where
bodyText ||| credits may be reallocated to cater to changing traffic.
bodyText ||| Our scheduling scheme addresses the issues of fairness and
bodyText ||| utilization of bandwidth. Since Bluetooth is a low-bandwidth
bodyText ||| environment, it is important that bandwidth should be effi-
bodyText ||| ciently utilized. Also, since a low bandwidth can easily lead
bodyText ||| to starvation of flows, another metric we focus on is fairness.
bodyText ||| We propose a distributed scatternet-scheduling algorithm that
bodyText ||| is implemented using the HOLD mode [10] of Bluetooth
bodyText ||| and adapts to non-uniform and changing traffic. This algo-
bodyText ||| rithm provides an integrated solution for both intra- and inter-
bodyText ||| piconet scheduling, i.e., for polling of slaves and scheduling
bodyText ||| of gateways. The algorithm leads to a high bandwidth utiliza-
bodyText ||| tion and results in a fair division of (a) the piconet bandwidth
bodyText ||| between the slaves of a piconet and (b) the gateway presence
bodyText ||| among different piconets.
bodyText ||| In section 2, we discuss the Bluetooth technology. In
bodyText ||| section 3, we present a definition of fairness in the context
note ||| 10	R. KAPOOR ET AL.
figureCaption ||| Figure 1. Gateway may be viewed as a virtual master and masters as virtual
figureCaption ||| slaves.
bodyText ||| of Bluetooth scatternets, which takes into account intra- and
bodyText ||| inter-piconet max-min fairness. Section 4 describes the al-
bodyText ||| gorithm and proves its fairness property. Section 5 presents
bodyText ||| simulation results and section 6 presents the conclusions.
sectionHeader ||| 2. Bluetooth technology
bodyText ||| The Bluetooth system [3] operates in the worldwide un-
bodyText ||| licensed 2.4 GHz Industrial–Scientific–Medical (ISM) fre-
bodyText ||| quency band. To make the link robust to interference, it uses
bodyText ||| a Frequency Hopping (FH) technique with 79 radio carriers.
bodyText ||| It allows a raw data transmission rate of 1 Mbit/s.
bodyText ||| Two or more Bluetooth units sharing the same channel
bodyText ||| form a piconet. Each piconet consists of a master unit and
bodyText ||| up to seven active slave units. The master unit polls the slave
bodyText ||| units according to a polling algorithm and a slave is only al-
bodyText ||| lowed to transmit after the master has polled it. The piconet
bodyText ||| capacity is thus, shared among the slave units according to the
bodyText ||| polling algorithm.
bodyText ||| Furthermore, two or more piconets can be interconnected,
bodyText ||| forming a scatternet. This requires a unit, called an inter-
bodyText ||| piconet unit (gateway), to be a part of more than one piconet.
bodyText ||| Such a unit can simultaneously be a slave member of multi-
bodyText ||| ple piconets, but a master in only one, and can transmit and
bodyText ||| receive data in only one piconet at a time; so participation in
bodyText ||| multiple piconets has to be on a time-division multiplex ba-
bodyText ||| sis. The time of the gateway is, thus, also shared among the
bodyText ||| piconets it belongs to. In this work, we assume that the gate-
bodyText ||| way can only be a slave in its piconets. If a gateway were
bodyText ||| to be a master in a piconet, it would lead to the stoppage of
bodyText ||| all transmission in the piconet when the gateway visits some
bodyText ||| other piconet. Thus, we believe that the use of the gateway as
bodyText ||| a slave is the most efficient method of scatternetting.
sectionHeader ||| 3. Fair allocation of bandwidth
bodyText ||| As introduced in the previous section, units belonging to a
bodyText ||| piconet share the piconet capacity according to the polling
bodyText ||| algorithm used by the master. In an analogous manner, gate-
bodyText ||| ways in a scatternet divide their time among their different
bodyText ||| piconets, according to the “master-listening” algorithm they
bodyText ||| use. It can be noted that there is a duality in this architec-
bodyText ||| ture. On the one hand, a master divides its capacity among
bodyText ||| the units of its piconet by using a polling algorithm. On the
bodyText ||| other hand, a gateway shares its capacity among the piconets
bodyText ||| it belongs to, on the basis of a scheduling algorithm it uses
bodyText ||| for listening to the masters. The gateway, can, then be viewed
bodyText ||| as a “virtual master” and its masters can be viewed as “virtual
bodyText ||| slaves” forming a “virtual piconet”, in which the polling cycle
bodyText ||| is, actually, the “listening cycle” of the gateway. A graphical
bodyText ||| interpretation of this duality is given in figure 1, in which the
bodyText ||| solid line shows the actual piconets, and the dotted line shows
bodyText ||| the virtual piconet.
bodyText ||| Due to this duality, we design our scheduling scheme such
bodyText ||| that the same scheduling algorithm is used for fair sharing of
bodyText ||| both (a) the piconet capacity among slaves and (b) the gate-
bodyText ||| way time among piconets.
bodyText ||| We now give a definition of max-min fairness [7]. We then
bodyText ||| go on to define max-min fairness in the context of Bluetooth
bodyText ||| scatternets, by considering (a) intra-piconet fairness, i.e., fair-
bodyText ||| ness in division of piconet bandwidth among slaves (both
bodyText ||| gateway and non-gateway) of a piconet and (b) inter-piconet
bodyText ||| fairness, i.e., fairness in division of the gateway’s presence
bodyText ||| among its piconets. We first define a ‘feasible’ rate distribu-
bodyText ||| tion since this is used in the definition of max-min fairness.
construct ||| Definition 1 (Feasible). A rate distribution is feasible if rates
construct ||| are non-negative, the aggregate rate is not greater than one,
construct ||| and no unit receives a higher rate than required.
construct ||| Definition 2 (Max-min fairness). An allocation of rates η1,
construct ||| η2, ... , ηs among s units is max-min fair if it is feasible, and
construct ||| for each unit i, ηi cannot be increased (while maintaining fea-
construct ||| sibility) without decreasing η j for some other unit j for which
construct ||| ηj &lt;, ηi.
bodyText ||| The distribution of max-min fair rates depends upon the
bodyText ||| set of rate demands (traffic generated) of the units. In the
bodyText ||| following subsections, we discuss factors that determine the
bodyText ||| max-min “fair share” of a slave (gateway or non-gateway).
bodyText ||| We call these factors the Piconet Presence Fraction and the
bodyText ||| Scatternet Presence Fraction and show how they may be used
bodyText ||| to calculate the “fair share” for a slave in a scatternet.
subsectionHeader ||| 3.1. Piconet presence fraction
bodyText ||| Consider a piconet consisting of gateway and non-gateway
bodyText ||| slaves in which the master has complete knowledge of the rate
bodyText ||| demands of all slaves (an ideal master). Using this knowl-
bodyText ||| edge, the master polls the slaves in a max-min fair man-
bodyText ||| ner such that each slave gets its “fair share” of the master’s
bodyText ||| polling. We refer to the “fair share” received by a slave as the
bodyText ||| “piconet presence fraction” (PPF) of the slave. The gateway
bodyText ||| has a PPF for each piconet it belongs to.
bodyText ||| Consider the piconets shown in figures 2(a) and 2(b), each
bodyText ||| consisting of one gateway and two slaves, with the traffic rates
bodyText ||| of each slave as shown. In figure 2(a) (Piconet I), the PPF of
bodyText ||| each non-gateway slave is 0.2, while the PPF of the gateway
bodyText ||| is 0.6. In figure 2(b) (Piconet II), the PPFs of the slaves are
bodyText ||| 0.2 and 0.4, while the PPF of the gateway is 0.4.
note ||| A FAIR AND TRAFFIC DEPENDENT SCHEDULING	11
figureCaption ||| Figure 2. Piconets with traffic rates between master and each slave shownn.
subsectionHeader ||| 3.2. Scatternet presence fraction
bodyText ||| A gateway will, in general, be a slave in multiple piconets and
bodyText ||| may have different amounts of traffic to exchange with each
bodyText ||| piconet. Consider an ideal gateway that has complete knowl-
bodyText ||| edge of the rate demands of all its masters. The gateway can
bodyText ||| then divide its presence among its piconets in a max-min fair
bodyText ||| manner, giving each piconet a “fair share” of its presence. We
bodyText ||| call this fair share the “scatternet presence fraction” (SPF) of
bodyText ||| the gateway for the piconet. The importance of the SPF is that
bodyText ||| a fair division of the gateway’s presence among its piconets
bodyText ||| can be achieved based on the SPF.
bodyText ||| Consider the piconets of figure 2 again, but the gateway of
bodyText ||| each of the piconets now connects them to form a scatternet,
bodyText ||| as shown in figure 3. The traffic requirements are the same as
bodyText ||| shown in figure 2. The SPF of the gateway is 0.5 in Piconet I
bodyText ||| and 0.5 in Piconet II.
subsectionHeader ||| 3.3. Fair share
bodyText ||| We see that for a gateway to be fair, there are two kinds of
bodyText ||| fairness it has to achieve: that dictated by the PPFs, which
bodyText ||| achieves fairness between the gateway and the other slaves of
bodyText ||| a piconet, and that of the SPFs, which distributes the presence
bodyText ||| of the gateway between its piconets in a fair manner. Both
bodyText ||| these kinds of fairness may not always be completely achiev-
bodyText ||| able and this can lead to a change in the values of PPF and
bodyText ||| SPF, as we now discuss.
bodyText ||| We observe that an ideal master (as in section 3.1) does
bodyText ||| not give a gateway more than the PPF of its polling. Thus,
bodyText ||| if the SPF of a gateway is greater than its PPF for a piconet,
bodyText ||| the gateway spends a fraction of its time equal to the PPF
bodyText ||| in the piconet. The gateway cannot stay for a fraction equal
bodyText ||| to its SPF in the piconet since it is limited by its PPF. Thus,
bodyText ||| the extra scatternet presence fraction (the difference of the
bodyText ||| SPF and the PPF) is redistributed in a fair manner among
bodyText ||| the gateway’s other piconets for which the SPF is less than
bodyText ||| the PPF. This may increase the SPF of the gateway in the
bodyText ||| other piconets. In other words, the gateway behaves as if
bodyText ||| its SPF in a particular piconet is reduced to the PPF and
bodyText ||| thus, its SPF in the other piconets increases. We refer to this
bodyText ||| changed SPF as the “updated SPF” of the gateway in a pi-
bodyText ||| conet.
bodyText ||| Similarly, an ideal gateway does not stay a fraction of time
bodyText ||| more than the SPF in a piconet. Thus, if the PPF of the gate-
tableCaption ||| Table 1
tableCaption ||| Calculation of fair share of the gateway in the two piconets of figure 3.
table ||| 	Piconet I	Piconet II
table ||| Actual traffic rate	0.7	0.6
table ||| PPF	0.6	0.4
table ||| SPF	0.5	0.5
table ||| Updated PPF	0.6	0.4
table ||| Updated SPF	0.6	0.4
table ||| Fair share	0.6	0.4
figureCaption ||| Figure 3. Gateway shared between two piconets; traffic rates between slaves
figureCaption ||| and the master are shown.
bodyText ||| way in the piconet is greater than the SPF, the gateway spends
bodyText ||| a fraction of time equal to the SPF in the piconet. The remain-
bodyText ||| ing PPF of the gateway (the difference of the PPF and the
bodyText ||| SPF) is redistributed in a fair manner among the other slaves
bodyText ||| of the piconet (if this other slave is a gateway, it is redistrib-
bodyText ||| uted to it if its SPF is greater than its PPF in the piconet). This
bodyText ||| may increase the PPF of these slaves. We refer to this changed
bodyText ||| PPF as the “updated PPF” of the slave in the piconet. In case
bodyText ||| there is no such redistribution, the updated PPF is equal to the
bodyText ||| PPF and the updated SPF is equal to the SPF.
bodyText ||| The fair share can now be calculated from the “updated
bodyText ||| PPF” and the “updated SPF” as the minimum of these two
bodyText ||| quantities. Note that all these quantities – PPF, SPF, updated
bodyText ||| PPF, updated SPF and fair share–are dependent on the traffic.
bodyText ||| Any change in traffic demand of a unit may lead to a change
bodyText ||| in some of these quantities. We explain the calculation of the
bodyText ||| fair share using some examples.
bodyText ||| An example is given in table 1, which shows the actual traf-
bodyText ||| fic rate, PPF, SPF, Updated PPF, Updated SPF and fair share
bodyText ||| of the gateway in the two piconets of figure 3. In Piconet II,
bodyText ||| the gateway has a PPF of 0.4, which is less than the SPF. In
bodyText ||| Piconet I, the gateway has a PPF of 0.6 and an SPF of 0.5.
bodyText ||| Thus, the extra scatternet presence fraction of the gateway in
bodyText ||| Piconet II (the difference between the SPF and the PPF) is
bodyText ||| given to Piconet I, which has a higher traffic rate than may
bodyText ||| be allowed by the SPF. This is reflected in the “updated SPF”
bodyText ||| values. Thus, the “fair share” of the gateway in Piconet I is
bodyText ||| 0.6 and in Piconet II is 0.4. The fair shares of the non-gateway
bodyText ||| slaves are equal to their PPF.
bodyText ||| As another example, consider the scatternet consisting of
bodyText ||| 5 piconets with the traffic rates shown as in figure 4. As shown
bodyText ||| in table 2, gateway G2 has a PPF of 0.5 and an SPF of 0.4 in
bodyText ||| Piconet B. Thus, the “updated PPF” of G2 in Piconet B is 0.4.
bodyText ||| The extra PPF (= PPF − SPF) is added to the PPF of gateway
note ||| 12	R. KAPOOR ET AL.
figureCaption ||| Figure 4. Scatternet with two gateways.
table ||| Table 2
tableCaption ||| Calculation of fair share of the gateways G1 and G2 in the scatternet of
tableCaption ||| figure 4.
table ||| Gateway G1	Piconet A	Piconet B	Piconet C
table ||| Actual traffic rate	0.4	0.6	0.1
table ||| PPF	0.25	0.5	0.1
table ||| SPF	0.4	0.5	0.1
table ||| Updated PPF	0.25	0.6	0.1
table ||| Updated SPF	0.25	0.65	0.1
table ||| Fair share	0.25	0.6	0.1
table ||| Gateway G2	Piconet B	Piconet D	Piconet E
table ||| Actual traffic rate	0.7	0.2	0.4
table ||| PPF	0.5	0.2	0.4
table ||| SPF	0.4	0.2	0.4
table ||| Updated PPF	0.4	0.2	0.4
table ||| Updated SPF	0.4	0.2	0.4
table ||| Fair share	0.4	0.2	0.4
bodyText ||| G1 in Piconet B. The “updated PPF” of G1 in Piconet B is,
bodyText ||| thus, 0.6.
bodyText ||| Also, gateway G1 has a PPF of 0.25 and an SPF of 0.4
bodyText ||| in Piconet A. Thus, the “updated SPF” of G1 in Piconet A is
bodyText ||| 0.25. The extra SPF (= SPF − PPF) is added to the SPF of G1
bodyText ||| in Piconet B. The “updated SPF” of G1 in Piconet B, is thus,
bodyText ||| equal to 0.65. The fair shares can now be easily calculated.
bodyText ||| A division of the master’s polling and the gateway’s pres-
bodyText ||| ence based on PPF and SPF as described in this section takes
bodyText ||| into account the traffic demands of the slaves and the gate-
bodyText ||| ways and leads to fairness in the scatternet. In the next sec-
bodyText ||| tion, we introduce and describe an algorithm that aims to
bodyText ||| achieve such a fair distribution of bandwidth.
sectionHeader ||| 4. Description of algorithm
bodyText ||| We first explain how the algorithm works in the case of a sin-
bodyText ||| gle piconet with no gateway. We then extend the algorithm
bodyText ||| to the case of a scatternet and explain how the coordination
bodyText ||| between the master and the gateways is achieved. We then
bodyText ||| prove the fairness of the algorithm.
subsectionHeader ||| 4.1. Single piconet with no gateways
bodyText ||| The polling algorithm is based on the master estimating the
bodyText ||| traffic rate between each slave and itself. This traffic rate is
bodyText ||| the sum of the traffic rates from the master to a slave and in
bodyText ||| the reverse direction. We assume, in order to simplify the ex-
bodyText ||| planation of the algorithm, that traffic flows only from slaves
bodyText ||| to master; masters generate no traffic to slaves. The same al-
bodyText ||| gorithm also applies with little change when traffic flows in
bodyText ||| both directions (explained later).
bodyText ||| The master uses a Round Robin polling scheme, with the
bodyText ||| modification that a slave is skipped if it does not belong to the
bodyText ||| “active list” of the master. The slaves are moved in and out
bodyText ||| of the active list on the basis of two variables that the master
bodyText ||| maintains for each slave. These two variables are:
bodyText ||| r – estimate of the rate of traffic generated by the slave;
bodyText ||| N – estimate of the queue length of the slave.
bodyText ||| When a slave is polled, the master–slave pair gets a chance
bodyText ||| to exchange a maximum amount of data in each direction,
bodyText ||| denoted by M. After each such polling phase, the master up-
bodyText ||| dates the values of N and r in the following manner:
bodyText ||| For the slave just polled:
equation ||| N=N+rτ −x, (1)
equation ||| αr+(1−α)xT ,	x &lt;M,
equation ||| αr+(1−α)xT + δ, x=M.
equation ||| For other slaves:
equation ||| N = N + rτ, (3)
bodyText ||| where τ is the time elapsed since the last update, x is the
bodyText ||| amount of data exchanged during the poll phase, T is the total
bodyText ||| time elapsed since the last poll of the same slave, α is a para-
bodyText ||| meter used to smooth the rate estimation and δ is a parameter
bodyText ||| used to probe for more bandwidth. Note that x is the actual
bodyText ||| amount of data exchanged, which may be less than or equal
bodyText ||| to M, depending upon the number of packets in the slave’s
bodyText ||| queue. Since N is an estimate of the slave’s queue length and
bodyText ||| r is an estimate of the rate at which traffic is generated, N is
bodyText ||| increased at the rate of r (as in equations (1) and (3)). Also,
bodyText ||| when a slave is polled, N is decreased by the amount of data
bodyText ||| exchanged ((equation 1)).
bodyText ||| After updating these values, the master determines the
bodyText ||| changes to be made to the active list. A slave is added or
bodyText ||| deleted from the active list depending upon whether its value
bodyText ||| of N is greater or smaller than a “threshold”. The value of
bodyText ||| this threshold is the minimum amount of data that the master
bodyText ||| would like the slave to have in order to poll it. We choose
bodyText ||| a value equal to a multiple of a DH5 packet for the thresh-
bodyText ||| old since this packet incurs least overhead (the selection of
bodyText ||| the value of the threshold is discussed further in the next sub-
bodyText ||| section). Thus, a slave is present in the active list if the mas-
bodyText ||| ter’s estimate of the value of N for the slave is greater than the
bodyText ||| threshold. This makes the simple Round Robin polling strat-
bodyText ||| egy adaptive to traffic and enables it to utilize bandwidth ef-
bodyText ||| ficiently, even when slaves have different rates of traffic. The
bodyText ||| maximum amount of data that can be exchanged at each poll,
bodyText ||| M, is also set equal to the threshold. Note that if the amount
bodyText ||| of data, x, in the slave’s queue is less than the threshold, the
bodyText ||| polling of the slave ends after this data has been exchanged.
equation ||| r=	
equation ||| (2)
note ||| A FAIR AND TRAFFIC DEPENDENT SCHEDULING	13
bodyText ||| If the value of N is less than the threshold for all the slaves,
bodyText ||| then the slave whose value of N is estimated to take the small-
bodyText ||| est time to reach the threshold is polled, i.e., the slave for
bodyText ||| which the value of (Threshold − N)/r is the smallest.
bodyText ||| The master now goes to the next slave according to the
bodyText ||| Round Robin ordering of slaves. If the slave is present in the
bodyText ||| active list, it is polled. Else, the procedure is repeated for the
bodyText ||| next slave in the Round Robin ordering.
bodyText ||| Also, note that if the amount of data sent by the slave x
bodyText ||| is equal to M, r is increased by a small amount, δ. This is
bodyText ||| basically an attempt by the slave to probe for more bandwidth
bodyText ||| if it is able to send data at the present rate. The usefulness
bodyText ||| of this increase is evident in the proof of fairness in the next
bodyText ||| section. The value of δ chosen is 0.15 and that of α is 0.65.
bodyText ||| We also discuss the rationale behind choosing these values in
bodyText ||| the proof of fairness.
bodyText ||| If traffic flows in both directions, i.e., from the slaves to
bodyText ||| the master and in the reverse direction, x is the average of
bodyText ||| the amount of data exchanged in the two directions, r refers
bodyText ||| to the average of the rate-estimations of the two directions
bodyText ||| and N refers to the average of the queue length estimates of
bodyText ||| the two directions. Also, if the number of packets in either
bodyText ||| direction is less than the threshold, the polling of the slave
bodyText ||| continues till in both directions, (a) there is no more data to
bodyText ||| send or (b) amount of data equal to the threshold has been
bodyText ||| exchanged.
bodyText ||| The initial value of N is set to the threshold (to ensure that
bodyText ||| slaves get polled at the beginning) and that of r is set to 0.25
bodyText ||| (as a reasonable value). Note that the algorithm converges to
bodyText ||| the fair share, but a careful selection of initial values makes
bodyText ||| the initial convergence faster.
bodyText ||| Another advantage of such a scheme is that it may allow
bodyText ||| the master to go into a power-saving mode if it realizes that no
bodyText ||| slave has sufficient packets to send, i.e., if N is smaller than
bodyText ||| the threshold for all slaves. Though we do not explore this
bodyText ||| option in this paper, it may be useful since Bluetooth devices
bodyText ||| are expected to work in power-constrained environments.
bodyText ||| To improve the algorithm, we add a heuristic to it. The
bodyText ||| maximum number of polling cycles that a slave is not polled
bodyText ||| is bounded. If a slave generates a large burst of data occa-
bodyText ||| sionally and then does not generate any data for a long time,
bodyText ||| the value of r for the slave may be very low. This may cause
bodyText ||| the value of N for the slave to be lower than the threshold
bodyText ||| for a long time. By limiting the maximum number of cycles
bodyText ||| missed by the slave, we make sure that such a behavior of the
bodyText ||| slave does not lead to its starvation. In the experiments, this
bodyText ||| value is taken to be equal to 5 cycles. We now explain how
bodyText ||| the above algorithm works in a scatternet.
subsectionHeader ||| 4.2. Scatternet
bodyText ||| Scheduling of gateways using Rendezvous Points. Before
bodyText ||| describing how the algorithm works in a scatternet, we briefly
bodyText ||| discuss the notion of Rendezvous Points (RPs) described
bodyText ||| in [4]. A RP is a slot at which a master and a gateway have
bodyText ||| agreed to meet, i.e., at this slot, the master will poll the gate-
bodyText ||| way and the gateway will listen to the master. In [4], RPs are
bodyText ||| implemented using the SNIFF mode of Bluetooth, but we im-
bodyText ||| plement RPs using the HOLD mode [ 10]. In the HOLD mode,
bodyText ||| the slave does not have to listen to the master for a certain time
bodyText ||| period and may use this time to visit other piconets. Prior to
bodyText ||| entering the HOLD mode, the master and the slave agree on
bodyText ||| the time duration the slave remains in the HOLD mode. We
bodyText ||| implement our algorithm using RPs as described below.
bodyText ||| The working of the algorithm in a scatternet is very similar
bodyText ||| to its operation in a piconet. The master continues to poll the
bodyText ||| non-gateway slaves in the same manner as described in the
bodyText ||| previous section with the modification that a gateway is polled
bodyText ||| at a Rendezvous Point. Each RP is a slot at which a particular
bodyText ||| gateway is polled and a master has different RPs for each of its
bodyText ||| gateways. These RPs are always unique (i.e., a master cannot
bodyText ||| have the same RP with more than one gateway). Since the
bodyText ||| gateway must be polled at the RP, this has implications in the
bodyText ||| polling of the other slaves (discussed later). Once a gateway
bodyText ||| has been polled, the master continues with the polling of the
bodyText ||| other slaves in the same manner as described in the previous
bodyText ||| section, i.e., it checks its active list to see if the next slave in
bodyText ||| the polling cycle is to be polled and so on.
bodyText ||| In order to divide its time among different piconets in a
bodyText ||| fair manner, the gateway performs similar calculations as de-
bodyText ||| scribed in the earlier section for the master. The gateway
bodyText ||| maintains values of N and r for each piconet it belongs to and
bodyText ||| these values are updated each time a gateway is polled (i.e.,
bodyText ||| at each RP). Thus, the calculations performed by a gateway at
bodyText ||| each RP are:
bodyText ||| For the piconet in which the gateway was just polled:
equation ||| N=N+rτ −x, (4)
equation ||| x
equation ||| αr+(1−α)T, x &lt;M,
equation ||| αr+(1−α) xT + δ, x=M.
equation ||| For other piconets:
equation ||| N = N + rτ, (6)
bodyText ||| where τ is the time elapsed since the last update, x is the
bodyText ||| amount of data exchanged during the poll phase, T is the to-
bodyText ||| tal time elapsed since the gateway was polled in the same pi-
bodyText ||| conet, and α and δ are as defined earlier.
bodyText ||| Moreover, at each RP, the gateway and the master negoti-
bodyText ||| ate the next RP between them. The assignment of this next
bodyText ||| RP takes into account the fairness between (a) the gateway
bodyText ||| and other slaves in a piconet and (b) the presence of the gate-
bodyText ||| way in different piconets. Also, we again employ a heuristic
bodyText ||| that improves the algorithm. When the next RP is being nego-
bodyText ||| tiated, we keep a bound on the maximum value this can take.
bodyText ||| This prevents a piconet from not being visited by a gateway
bodyText ||| for a long time. The maximum value of this next RP used in
bodyText ||| our experiments is 400 slots.
bodyText ||| We now see how the master and the gateway use the in-
bodyText ||| formation that they have to achieve fairness in the scatternet.
bodyText ||| When a gateway is polled at a RP, the gateway and the master
bodyText ||| do the following.
equation ||| r=	
equation ||| (5)
note ||| 14	R. KAPOOR ET AL.
listItem ||| (i) Gateway. The gateway calculates the number of slots,
listItem ||| Nthresh after which N for the piconet will become greater
listItem ||| than the threshold; Nthresh = (threshold − N)/r, where
listItem ||| threshold is as explained in the previous section, N and
listItem ||| r are values maintained by the gateway for the piconet.
listItem ||| The gateway makes use of this value and does not visit
listItem ||| a piconet till its estimate of N for the piconet becomes
listItem ||| greater than the threshold. This is similar to the algo-
listItem ||| rithm used by the master in which a slave is not polled till
listItem ||| the master’s estimate of N for the slave becomes greater
listItem ||| than the threshold. Thus, the gateway tries to divide its
listItem ||| time between the piconets in a fair manner, i.e., accord-
listItem ||| ing to the SPFs. Note that Nthresh may be negative if N
listItem ||| is greater than the threshold. Also, Nthresh is allowed to
listItem ||| have a maximum value of 400.
bodyText ||| Moreover, each time a gateway visits a piconet, it knows
bodyText ||| the RPs for the other piconets it belongs to (except right
bodyText ||| at the beginning or when the gateway is added to another
bodyText ||| piconet).
listItem ||| (ii) Master. The master calculates the number of slots after
listItem ||| which the gateway can be polled such that the fairness
listItem ||| with other slaves is maintained. It adopts the following
listItem ||| procedure to achieve this:
bodyText ||| It maintains a counter, num_slots (which is initialized
bodyText ||| to 0) and checks the value of N for each slave, in a cyclic
bodyText ||| order, starting from the slave after the current gateway in
bodyText ||| the cyclic order to the slave before the current gateway.
bodyText ||| The master checks if the value of N for the slave will be
bodyText ||| greater than the threshold after num_slots slots. If this
bodyText ||| condition is true, num_slots is incremented by twice the
bodyText ||| value of the threshold. After incrementing num_slots, the
bodyText ||| master also checks to see if it has a RP with any gate-
bodyText ||| way whose value is equal to num_slots and increments
bodyText ||| num_slots by twice the value of the threshold if this is
bodyText ||| true. This ensures that the master has a unique RP for
bodyText ||| each of its gateways. Note that num_slots is incremented
bodyText ||| by twice the value of the threshold since the master ex-
bodyText ||| pects to exchange threshold slots of data with a slave in
bodyText ||| each direction.
bodyText ||| The master uses the above procedure to estimate the num-
bodyText ||| ber of slaves who will have their value of N greater than
bodyText ||| the threshold when the master polls the slaves in their
bodyText ||| cyclic order starting from the gateway just polled. The
bodyText ||| value of num_slots determines the number of slots which
bodyText ||| the master expects to use in polling the other slaves in
bodyText ||| one cycle before polling the gateway again and is thus,
bodyText ||| used by the master to maintain fairness between the gate-
bodyText ||| way and the other slaves in the piconet. Again, note that
bodyText ||| num_slots is allowed to have a maximum value of 400.
bodyText ||| The master and the gateway now exchange the informa-
bodyText ||| tion they have to calculate their next RP. This exchange takes
bodyText ||| place using the LMP_hold_req PDU of the LMP (Link Man-
bodyText ||| ager Protocol) layer. This PDU carries a hold instant and a
bodyText ||| hold time, which are used to specify the instant at which the
bodyText ||| hold will become effective and the hold time, respectively.
bodyText ||| When the master is sending a packet to a gateway, the value
bodyText ||| of num_slots can be sent after hold instant and hold time in
bodyText ||| the packet. The master also sends the values of its RPs with
bodyText ||| its other gateways in the packet. Similarly, the gateway sends
bodyText ||| the master the values of its RPs with other piconets and the
bodyText ||| value of Nthresh also in an LMP_hold_req PDU. The master
bodyText ||| now knows all the RPs of the gateway; similarly, the gateway
bodyText ||| knows all the RPs of the master.
bodyText ||| Note that the above information exchange requires a min-
bodyText ||| imal change in the Bluetooth specifications that the contents
bodyText ||| of the LMP_hold_req PDU need to be enhanced. This PDU is
bodyText ||| 1-slot in length; thus, some bandwidth of the master is wasted
bodyText ||| in sending these PDUs. This wasted bandwidth can be re-
bodyText ||| duced by increasing the value of threshold, i.e., the maximum
bodyText ||| data that a slave and a master may exchange in each direc-
bodyText ||| tion during one poll of the slave. On the other hand, a large
bodyText ||| value of the threshold will lead to larger delays for packets.
bodyText ||| Thus, we have a tradeoff here. We choose a threshold value
bodyText ||| equal to three times a DH5 packet. The effect of this wasted
bodyText ||| bandwidth can be seen in the experiments section where the
bodyText ||| piconet capacity used is slightly less than 1. Note that we
bodyText ||| pay a small price here to get perfect coordination between the
bodyText ||| master and the gateway and also to get a high degree of fair-
bodyText ||| ness in the system, as the experiments later demonstrate.
bodyText ||| Now, the master and the gateway both have complete in-
bodyText ||| formation. So, each of them calculates the next RP in the
bodyText ||| following manner:
bodyText ||| They take the maximum value out of num_slots and Nthresh
bodyText ||| and as long as this value is the same as one of the RPs (note
bodyText ||| that all relevant RPs are known to both the master and the
bodyText ||| gateway), the value is incremented by 2 · threshold. The value
bodyText ||| at the end of this small procedure is the next RP between the
bodyText ||| gateway and the master. Since this value takes into account
bodyText ||| both Nthresh and num_slots, it incorporates both the fairness
bodyText ||| of the master’s polling and the gateway’s presence.
bodyText ||| Note that the value of num_slots calculated by the master is
bodyText ||| just an estimate (the master assumes that each slave included
bodyText ||| in the calculation of num_slots will exchange threshold slots
bodyText ||| of data with the master in each direction, but this may not be
bodyText ||| true). Thus, the master may have polled all the slaves that had
bodyText ||| to be polled before the RP of the gateway (according to the
bodyText ||| estimate in the calculation of num_slots) and still be left with
bodyText ||| some slots before the RP. In this case, the master just contin-
bodyText ||| ues polling the slaves in their cyclic order and polls the gate-
bodyText ||| way when the time for the RP arrives. Note that this means
bodyText ||| that the master may have to force a slave to send a packet
bodyText ||| smaller than a certain length. For example, if two slots are
bodyText ||| left for the RP, then the master will send a 1-slot packet and
bodyText ||| ask the slave being polled to do the same. Note that the Blue-
bodyText ||| tooth header has 4 bits to represent the packet type and these
bodyText ||| can represent 16 packet types. For ACL links, 10 (7 data,
bodyText ||| 3 control packets) of the packet types are defined. We use 2
bodyText ||| of the remaining bit sequences to send packets that force the
bodyText ||| slave to send packets smaller than or equal to a certain length.
bodyText ||| This is shown in table 3.
bodyText ||| From table 3, we see that this procedure is adopted if the
bodyText ||| number of slots left for the RP is less than 10 (if the number
bodyText ||| of slots left for the RP is greater than or equal to 10, then the
note ||| A FAIR AND TRAFFIC DEPENDENT SCHEDULING	15
tableCaption ||| Table 3
tableCaption ||| Procedure adopted by the master if slots left for the RP is less than 10.
table ||| Slots left for RP	Maximum	Maximum
table ||| length of packet	length of packet
table ||| sent by master	sent by slave
table ||| 2	1	1
table ||| 4	1	1
table ||| 6	3	3
table ||| 8	3	3
bodyText ||| slave’s packet length does not have to be restricted). Thus,
bodyText ||| if the slots left for the RP is 2, the master can send a packet
bodyText ||| of maximum length = 1 and the gateway can send a packet
bodyText ||| of maximum length = 1 and so on. Note that for reasons of
bodyText ||| fairness, the maximum packet length for the master and the
bodyText ||| gateway is the same. Since the master needs to restrict the
bodyText ||| maximum length of the gateway’s packet to either 1 or 3 (as
bodyText ||| shown in table 3), we need 2 packet types to achieve this. This
bodyText ||| procedure effectively suspends the polling of a slave to honor
bodyText ||| a RP with a gateway. The polling of the slave continues after
bodyText ||| the gateway has been polled.
bodyText ||| In addition, a gateway may lose a slot in switching from
bodyText ||| one piconet to another. This loss is unavoidable since piconets
bodyText ||| are in general, not synchronized in time. In the experiments in
bodyText ||| the paper, we set the value of the threshold to three times the
bodyText ||| payload of a DH5 packet, which can give a switching loss of
bodyText ||| about 3 % at heavy loads (every 2 · threshold slots, the gateway
bodyText ||| loses about one slot in switching). At light loads, this switch-
bodyText ||| ing loss does not lead to inefficiency since the sum of the fair
bodyText ||| shares of the gateway in all its piconets is less than 1 and even
bodyText ||| after the switching loss, the gateway is able to obtain its fair
bodyText ||| share. The simulations in the next section do not take this
bodyText ||| switching loss into account and thus, the bandwidth received
bodyText ||| by the gateway under heavy loads will be a little smaller than
bodyText ||| the one shown in the results.
subsectionHeader ||| 4.3. Proof offairness
bodyText ||| We now prove that the above algorithm leads to a max-min
bodyText ||| fair distribution of the bandwidth of a scatternet among units.
bodyText ||| We start by proving this in the case of a piconet. In the next
bodyText ||| step, we will extend the proof to the general case of a scatter-
bodyText ||| net.
subsubsectionHeader ||| 4.3.1. Fairness in a piconet
bodyText ||| Let us introduce the following notation:
bodyText ||| S: number of slave units in the piconet;
bodyText ||| gi : rate-demand of the ith unit;
bodyText ||| ηi: rate achieved by the ith unit;
bodyText ||| ri: rate-estimation of the ith unit (as defined in equa-
bodyText ||| tion (2)),
bodyText ||| where ηi and ri are average values.
bodyText ||| Slave unit i is referred to as “satisfied”, if it achieves it rate
bodyText ||| demand, i.e., ηi = gi; else, the slave unit is referred to as
bodyText ||| “unsatisfied”. Also, in the proof that follows, “slot” refers to
bodyText ||| “Bluetooth slot”; “unit” and “slave unit” may be used inter-
bodyText ||| changeably.
bodyText ||| If there is one slave unit in a piconet, then it will always get
bodyText ||| polled and hence, the algorithm is fair. We prove the fairness
bodyText ||| when there are two or more slave units.
bodyText ||| We first make the following observations:
listItem ||| (a) If a unit has a rate-estimation, r &gt; 0.25, it will never
listItem ||| achieve a lesser rate than any other unit.
bodyText ||| r is an estimation of the average number of slots of traf-
bodyText ||| fic that a master–slave pair will generate per slot in each di-
bodyText ||| rection. Thus, a rate of 0.25 means that a master–slave pair
bodyText ||| generates, on the average, “threshold” slots of traffic in each
bodyText ||| direction in every 4 · threshold slots. Suppose a piconet has
bodyText ||| two slaves, and the first has a rate-estimation, r &gt; 0.25, then
bodyText ||| the first slave will be polled at least once in every 4 · threshold
bodyText ||| slots, i.e., will get on the average at least threshold polling
bodyText ||| slots out of every 2 · threshold, regardless of the r of the other
bodyText ||| slave (since N increases at the rate of r, N will increase by
bodyText ||| at least 0.25 · 4 · threshold = threshold; thus, the slave will
bodyText ||| enter into the “active list” in 4 · threshold slots). Thus, it will
bodyText ||| never achieve a lesser rate than another unit. It is easy to see
bodyText ||| that this property would be true if there were more than two
bodyText ||| slaves (two slaves is the worst case).
listItem ||| (b) For δ &gt; 0.1 and α &gt; 0.6, an unsatisfied slave will tend to
listItem ||| a rate-estimation of at least 0.25.
listItem ||| For an unsatisfied slave, the second part of equation (2)
listItem ||| (when x = M) is always used for updating the rate. Thus, if
listItem ||| ri is the ith rate-estimation:
equation ||| rn+1 = αrn + (1 − α) T + δ.
bodyText ||| This leads to (as n becomes very large):
equation ||| r=(1−α)M
bodyText ||| Thus, for δ &gt; 0.1 and α &gt; 0. 6, for any value of T, the
bodyText ||| value of r tends to at least 0.25.
listItem ||| (c) As long as there is an unsatisfied unit, the utilization of
bodyText ||| the system capacity is 1 (for δ &gt; 0.15 and α &gt; 0.65).
bodyText ||| Consider a piconet consisting of seven slave units, in
bodyText ||| which the first unit, unit1 is unsatisfied. From (a) and (b),
bodyText ||| unit1 will never achieve a lesser rate than any other unit; this
bodyText ||| means that it will be polled at least once for each time the
bodyText ||| other slaves are polled. The value of T (as in equation (2)) for
bodyText ||| unit1 is thus, at most, 14 · threshold. For this value of T and
bodyText ||| for δ = 0.15 and α = 0. 65, r for unit1 tends to at least 0.5.
bodyText ||| A value of r = 0.5 for a slave unit means that it can be polled
bodyText ||| all the time (since N increases at the rate of r, N will increase
bodyText ||| by at least 0.5 · 2 · threshold = threshold; thus, the slave will
bodyText ||| enter into the “active list” in 2 · threshold slots, which is also
bodyText ||| the time of its polling). Thus, the system capacity is totally
bodyText ||| utilized. If there were less than 7 slave units, the value of T
bodyText ||| would be smaller (than 14 · threshold), and r would tend to a
bodyText ||| higher value (than 0.5).
equation ||| αn−k
equation ||| Tk	+
equation ||| δ	 &gt;
equation ||| 1−α
equation ||| ∞
equation ||| E
equation ||| k=0
equation ||| δ
equation ||| 	.
equation ||| 1−α
note ||| 16	R. KAPOOR ET AL.
bodyText ||| We choose values of δ and α to satisfy the above proper-
bodyText ||| ties, i.e., δ = 0.15 and α = 0.65.
bodyText ||| The following statements hold.
listItem ||| (i) Units with the same rate-demand achieve the same aver-
listItem ||| age rate:
equation ||| gi = gj ⇒ ηi = ηj.
bodyText ||| We prove this by contradiction. Suppose there are two units,
bodyText ||| unit1 and unit2 with rate demands g1 and g2, respectively,
bodyText ||| such that g1 = g2. Also, suppose one unit achieves a higher
bodyText ||| average rate than the other, η1 &gt; η2.
bodyText ||| Now, unit2 does not achieve its rate-demand (since η1 &gt;
bodyText ||| η2). Unit1 may or may not achieve its rate demand. From
bodyText ||| property (b), unit2 will always tend to a value at least equal to
bodyText ||| 0.25, since it is an unsatisfied slave. Using property (a), this
bodyText ||| implies that η2 cannot be less than η1. This is a contradiction.
listItem ||| (ii) Units with a higher rate-demand achieve an average rate
listItem ||| at least equal to that achieved by units with a lower rate-
listItem ||| demand:
equation ||| gi &gt; gj ⇒ ηi i ηj.
bodyText ||| This can be proved by contradiction in the same manner as in
bodyText ||| part (i).
bodyText ||| Now, without loss of generality, let us partition the slave
bodyText ||| units into two sets, S1 and S2, in such a way that units in S1
bodyText ||| are satisfied, while units in S2 are not.
listItem ||| •	If the set S2 is empty, than all the units achieve their rate-
listItem ||| demand and the system is fair.
listItem ||| •	If the set S2 is not empty, then using statements (i) and (ii),
listItem ||| all units share the bandwidth in a fair manner. Moreover,
listItem ||| since S2 contains at least one unit, the total system capac-
listItem ||| ity is utilized. Hence, it is not possible to increase the rate
listItem ||| of a unit in S2 without decreasing the rate of some other
listItem ||| unit.
subsubsectionHeader ||| 4.3.2. Fairness in a scatternet
bodyText ||| The proof of fairness for a scatternet follows trivially from
bodyText ||| that for a piconet. We make the following two observations:
listItem ||| (1) The gateway visits a piconet only after the estimation
listItem ||| of N for the piconet becomes greater than the threshold (it
listItem ||| calculates Nthresh while determining the next RP). In other
listItem ||| words, the “virtual master” (gateway) does not poll (visit) its
listItem ||| “virtual slave” (master) till the estimate of N becomes greater
listItem ||| than the threshold. This is similar to the algorithm used by
listItem ||| the master to poll the slaves in which a slave is not polled till
listItem ||| its estimate of N becomes greater than the threshold. Thus,
listItem ||| the gateway divides its presence among its piconets in a fair
listItem ||| manner, i.e., according to the SPF. Note that if the PPF for
listItem ||| a gateway in a piconet is less than its SPF, the master does
listItem ||| not poll the gateway for more than the PPF. Thus, the appar-
listItem ||| ent rate demand and SPF for the gateway in the piconet are
listItem ||| reduced. This may increase the SPF of the gateway in other
listItem ||| piconets. In this case, the gateway divides its presence ac-
listItem ||| cording to the updated SPFs.
listItem ||| (2) While calculating the next RP for a gateway, the mas-
listItem ||| ter calculates the num_slots value which estimates the num-
listItem ||| ber of slaves in one polling cycle (starting from the slave after
listItem ||| the gateway in the polling cycle) who will have their values
listItem ||| of N greater than the threshold at the estimated time of their
listItem ||| poll. This achieves fairness between the gateway and the non-
listItem ||| gateway slaves. Also, the master continues to use the same
listItem ||| algorithm for polling non-gateway slaves in a scatternet as
listItem ||| described for a piconet in section 4.1. This maintains fairness
listItem ||| between non-gateway slaves, i.e., the division is done accord-
listItem ||| ing to the PPFs (or the updated PPFs).
subsectionHeader ||| 4.4. Overhead/limitations of the algorithm
bodyText ||| The rate calculations will lead to a higher load on the system.
bodyText ||| Also, the algorithm does not take into account SCO links. We
bodyText ||| believe (and as has been shown in [6]) that ACL links are
bodyText ||| capable of carrying voice with small delays. The controlled
bodyText ||| channel access in Bluetooth can ensure good support of voice
bodyText ||| using ACL links. Also, scheduling in a scatternet where SCO
bodyText ||| links are allowed may not be feasible. Since SCO links re-
bodyText ||| quire a periodic reservation of two slots every two, four or
bodyText ||| six slots, meeting the demands of such a link with a gateway
bodyText ||| may be impossible when the gateway is visiting some other
bodyText ||| piconet.
sectionHeader ||| 5. Experiments and results
bodyText ||| In this section, we present simulation results, which show that
bodyText ||| the algorithm satisfies the fairness criteria described earlier.
bodyText ||| We start with simple topologies that illustrate the behavior of
bodyText ||| the algorithm and then show that it also works well in more
bodyText ||| complex topologies. There are three topologies that the exper-
bodyText ||| iments focus on and these demonstrate the behavior of the al-
bodyText ||| gorithm – a topology with (a) a gateway belonging to two pi-
bodyText ||| conets, (b) a gateway belonging to three piconets and (c) a pi-
bodyText ||| conet having two gateways. The experiments also show the
bodyText ||| adaptivity of the algorithm, i.e., how quickly the algorithm
bodyText ||| adapts to changing traffic demands of slaves.
bodyText ||| In the experiments, we specify the “rate of a slave”, which
bodyText ||| refers to the sum of the rates at which a slave generates data
bodyText ||| for a master (i.e., the rate demand of a slave) and the mas-
bodyText ||| ter generates data for the slave. Moreover, unless mentioned
bodyText ||| otherwise, we assume that the traffic rate from a slave to a
bodyText ||| master is equal to that from the master to the slave. Thus, a
bodyText ||| slave having a rate of 0.4 means that the slave generates data
bodyText ||| at the rate of 0.2 Bluetooth slots per slot and the master also
bodyText ||| has a rate demand of 0.2 towards the slave. As we show in the
bodyText ||| section on asymmetric traffic, the algorithm works well even
bodyText ||| if these two rates are not the same.
bodyText ||| The simulation environment used in our experiments is
bodyText ||| NS-2 [8]. We have augmented NS-2 with the Bluetooth
bodyText ||| model. The simulator models the Bluetooth baseband, LMP
bodyText ||| and L2CAP layers and enables the creation of piconets and
bodyText ||| scatternets. The model contains most of the standard features
bodyText ||| of Bluetooth like Frequency Hopping, Multi-Slot Packets,
bodyText ||| Fast ARQ (Automatic Retransmission Query). Note that as
bodyText ||| mentioned earlier, in our simulator, the switching loss asso-
bodyText ||| ciated with the gateway moving from one piconet to another
note ||| A FAIR AND TRAFFIC DEPENDENT SCHEDULING	17
figureCaption ||| Figure 5. Example scatternet.
bodyText ||| is not taken into account. This effect can lead to the gate-
bodyText ||| way losing up to 3% of slots at heavy loads. The experiment
bodyText ||| results are thus, a slight overestimate.
bodyText ||| In the experiments, all traffic generated is CBR. Each ex-
bodyText ||| periment is run for a system time of 32 sec. In the experi-
bodyText ||| ments, the term “slave” refers to a non-gateway slave; a gate-
bodyText ||| way slave is referred to as “gateway”. Also, in experiments
bodyText ||| where the PPF and the SPF values (and not the updated PPF
bodyText ||| and the updated SPF) are shown, the PPF and the updated PPF
bodyText ||| are equal and the SPF and the updated SPF are also equal. In
bodyText ||| the graphs, “BW” in the index stands for bandwidth, “GW”
bodyText ||| stands for gateway.
subsectionHeader ||| 5.1. Single gateway in two piconets
bodyText ||| We first consider the simple topology shown in figure 5,
bodyText ||| which consists of two piconets, numbered I and II, connected
bodyText ||| by a single gateway. We consider various cases by changing
bodyText ||| the traffic and the number of slaves in the piconets.
construct ||| Experiment 1. Adaptation between gateway and
bodyText ||| non-gateway slave traffic
bodyText ||| Each piconet has one non-gateway slave that generates very
bodyText ||| high traffic, with rate equal to 1, to the master. The gateway
bodyText ||| has equal traffic to both masters. We vary the gateway traffic
bodyText ||| to show the fair sharing of the piconet bandwidth between the
bodyText ||| gateway and the slave. We show the results for one piconet
bodyText ||| since the two piconets are exactly symmetric.
bodyText ||| Figure 6(a) shows the sharing of bandwidth between the
bodyText ||| gateway and slave for different values of gateway traffic. It
bodyText ||| also shows the fair share of the slave and the total fraction
bodyText ||| of the bandwidth obtained by the gateway and the slave in
bodyText ||| the piconet. It can be seen that the slave obtains a bandwidth
bodyText ||| equal to its fair share for different values of gateway traffic.
bodyText ||| Moreover, the sum of the bandwidths obtained by the slave
bodyText ||| and the gateway is nearly equal to 1. The reason for this to
bodyText ||| be slightly less than 1 is that some of the piconet capacity is
bodyText ||| used in sending LMP _ hold _req PDUs of the LMP layer.
bodyText ||| In figure 6(b), the comparison of the fraction of the band-
bodyText ||| width obtained by the gateway to its SPF (PPF and SPF are
bodyText ||| equal) is shown. Figure 6(b) shows that the gateway gets al-
bodyText ||| most equal to its fair share of the bandwidth for all values
bodyText ||| of traffic. Again, the reason that the gateway obtains slightly
bodyText ||| less than its fair share is because some of the slots are used
bodyText ||| for LMP PDUs. This also explains why the gateway obtains
bodyText ||| slightly less than the slave in figure 6(a).
figureCaption ||| Figure 6. (a) Sharing of bandwidth between gateway and slave. (b) Compar-
figureCaption ||| ison of fraction of bandwidth obtained to SPF for the gateway.
construct ||| Experiment 2. Different traffic to piconets
bodyText ||| The same topology as in the previous case, but each slave has
bodyText ||| a traffic rate of 0.3 to the master. The gateway has a fixed traf-
bodyText ||| fic rate of 0.2 to the master of Piconet I and variable traffic to
bodyText ||| the other master. The PPF and SPF of the gateway in the first
bodyText ||| piconet are, thus, both equal to 0.2. The traffic in Piconet I
bodyText ||| does not change and the gateway and the slave get a constant
bodyText ||| fraction of 0.2 and 0.3 of the piconet bandwidth, respectively.
bodyText ||| Figure 7(a) shows the sharing of bandwidth between the
bodyText ||| gateway and slave for different values of gateway traffic,
bodyText ||| while figure 7(b) shows the comparison of the fraction of the
bodyText ||| bandwidth obtained by the gateway in Piconet II to its SPF
bodyText ||| and PPF. From the graphs, we can see that when the gate-
bodyText ||| way has different traffic to piconets, it divides its presence
bodyText ||| among the piconets according to the traffic offered and in a
bodyText ||| fair manner (again, the gateway obtains slightly less than its
bodyText ||| fair share due to the LMP PDUs). Also, the gateway makes
bodyText ||| use of the lower traffic offered by the slave in Piconet II to
bodyText ||| obtain a higher share of the bandwidth in Piconet II.
construct ||| Experiment 3. Different number of slaves
bodyText ||| Piconet I has 3 slaves, while the number of slaves in Piconet II
bodyText ||| is variable. Each slave generates traffic to the master at the
bodyText ||| rate of 0.2. The gateway has a traffic rate of 0.3 to Piconet I
bodyText ||| and 0.8 to Piconet II. The PPF and SPF of the gateway in
bodyText ||| Piconet I are, thus, 0.2 and 0.3, respectively. In Piconet II, the
bodyText ||| value of PPF changes depending upon the number of slaves.
bodyText ||| In Piconet I, the slaves get a bandwidth fraction of 0.2
bodyText ||| and the gateway gets 0.3. Figure 8(a) shows the sharing
note ||| 18	R. KAPOOR ET AL.
figureCaption ||| Figure 7. (a) Sharing of bandwidth between gateway and slave in Piconet II.
figureCaption ||| (b) Comparison of fraction of bandwidth obtained by the gateway to SPF and
figureCaption ||| PPF in Piconet II.
bodyText ||| of bandwidth between the gateway and each slave in Pi-
bodyText ||| conet II. Figure 8(b) shows the comparison of the fraction
bodyText ||| of the bandwidth obtained by the gateway in Piconet II to the
bodyText ||| SPF and PPF. The gateway receives a fraction of the band-
bodyText ||| width almost equal to its fair share. Also, as the number of
bodyText ||| slaves increases, the fraction of the bandwidth received by
bodyText ||| the gateway (and each slave) reduces in a fair manner.
construct ||| Experiment 4. Asymmetric traffic
bodyText ||| We now consider a case where the traffic rates from Master
bodyText ||| to Slave and Slave to Master are different (asymmetric traf-
bodyText ||| fic). We consider the same topology as in experiment 2 of the
bodyText ||| current section, with the non-gateway slaves having the same
bodyText ||| rate as in experiment 2. The gateway has a fixed traffic rate of
bodyText ||| 0.2 to the master of Piconet I and variable traffic to the other
bodyText ||| master. The variable traffic is such that traffic from Master
bodyText ||| to Slave has a rate of 0.1 and traffic from Slave to Master
bodyText ||| varies.
bodyText ||| Figure 9 shows the comparison of bandwidth fraction ob-
bodyText ||| tained by the gateway in this experiment versus that obtained
bodyText ||| by the gateway in experiment 2 in Piconet II for different val-
bodyText ||| ues of gateway traffic (which is the sum of master to gateway
bodyText ||| and gateway to master traffic rates). We see that the fraction
bodyText ||| is slightly lower than the fraction obtained in experiment 2.
bodyText ||| Asymmetric traffic leads to wastage of slots, since an empty
bodyText ||| slot is returned in one direction where there is no data to send.
bodyText ||| It can be seen though, that the gateway still behaves in an ap-
figureCaption ||| Figure 8. (a) Sharing of bandwidth between gateway and slave in Piconet II.
figureCaption ||| (b) Comparison of fraction of bandwidth obtained by the gateway to SPF and
figureCaption ||| PPF in Piconet II.
figureCaption ||| Figure 9. Comparison of fraction of bandwidth obtained by gateway in this
figureCaption ||| experiment with that in experiment 2 in Piconet II.
bodyText ||| proximately fair manner. All other bandwidth fractions for
bodyText ||| slaves and the gateway are the same as in experiment 2.
subsectionHeader ||| 5.2. Single gateway shared between three piconets
bodyText ||| We now consider a topology, where a gateway is shared be-
bodyText ||| tween 3 piconets, numbered I, II and III. Piconet I has 5, Pi-
bodyText ||| conet II has 1 and Piconet III has 4 slaves. Each slave has
bodyText ||| a traffic rate of 0.2. The gateway has a traffic rate of 0.2 to
bodyText ||| Piconet I, 0.3 to Piconet III and a variable rate to Piconet II.
bodyText ||| All traffic is symmetric (same from master to slave and from
bodyText ||| slave to master).
note ||| A FAIR AND TRAFFIC DEPENDENT SCHEDULING	19
figureCaption ||| Figure 10. Bandwidth fraction received by gateway in the three piconets.
figureCaption ||| Figure 12. Fraction of bandwidth and fair share of GW1 and GW2 in Pi-
figureCaption ||| conet II.
figureCaption ||| Figure 11. Example scatternet topology.
bodyText ||| Figure 10 shows the fraction of bandwidth obtained by the
bodyText ||| gateway in each piconet with increasing gateway traffic rate to
bodyText ||| Piconet II. It also shows the PPF and the Updated SPF of the
bodyText ||| gateway in Piconet II. We do not show the fair shares of the
bodyText ||| gateway in Piconet I and III since they are constant (0.16 and
bodyText ||| 0.2, respectively). It can be seen that the gateway manages
bodyText ||| to get close to its fair share in the 3 piconets. The slaves in
bodyText ||| Piconet I get a bandwidth fraction of 0.16 and the slaves in
bodyText ||| Piconet II and III get a bandwidth fraction of 0.2 (all these are
bodyText ||| equal to their fair shares).
subsectionHeader ||| 5.3. Piconet with two gateways
bodyText ||| We now show the working of the algorithm in a piconet hav-
bodyText ||| ing 2 gateways, as shown in figure 11. Piconets I, II and III
bodyText ||| have 6, 2 and 4 non-gateway slaves, respectively. There are
bodyText ||| two gateways, GW 1 between Piconets I and II; and GW 2 be-
bodyText ||| tween Piconets II and III. All slaves have a traffic rate of 0.2.
bodyText ||| GW 1 has a traffic rate of 0.2 in Piconet I and 0.5 in Piconet II.
bodyText ||| GW 2 has a traffic rate of 0.2 in Piconet III. We vary the traf-
bodyText ||| fic rate of GW 2 in Piconet II and show the fair sharing of
bodyText ||| bandwidth.
bodyText ||| Figure 12 shows the fraction of bandwidth obtained by
bodyText ||| GW 1 and GW 2 in Piconet II compared to their fair shares.
bodyText ||| The x-axis denotes GW 2 traffic in Piconet II. It can be seen
bodyText ||| that the bandwidth fractions obtained are very close to the
bodyText ||| fair value. The non-gateway slaves of Piconet II receive a
bodyText ||| bandwidth fraction of 0.2, which is equal to their fair share
bodyText ||| (not shown in the figure). The bandwidth fraction received by
bodyText ||| slaves in Piconets I and III does not change for different val-
bodyText ||| ues of GW2 traffic in Piconet II. The fair share of each slave
bodyText ||| (including the gateway) in Piconet I is 0.14 and in Piconet III
bodyText ||| Figure 13. Actual rate estimation of the gateway and its ideal value.
bodyText ||| is 0.2; the bandwidth fraction received by each slave is very
bodyText ||| close to these fair shares.
subsectionHeader ||| 5.4. Adaptivity to changing traffic demands
bodyText ||| We now show how quickly the algorithm is able to adapt to
bodyText ||| changing traffic. We again consider the scenario of experi-
bodyText ||| ment 1 of section 5.1, consisting of two piconets, each hav-
bodyText ||| ing a non-gateway slave, connected by a single gateway. The
bodyText ||| non-gateway slaves have a traffic rate of 1; the gateway has
bodyText ||| equal traffic to both the masters. We vary the traffic rate of
bodyText ||| the gateway as time progresses: for the first 2.5 seconds, the
bodyText ||| gateway’s rate is 0. 1, for the next 2.5 seconds, it is 0.5 and for
bodyText ||| the remaining time, it is 0.3.
bodyText ||| Figure 13 shows the actual rate estimation of the gateway
bodyText ||| (and its ideal value) versus time. It can be seen that the rate
bodyText ||| estimation adapts very quickly to the new rate. For example,
bodyText ||| when the rate changes from 0.1 to 0.5, the rate estimation
bodyText ||| reaches a value of 0.45 in about half a second after 2.5 sec.
bodyText ||| Thus, the algorithm adapts to quickly changing traffic.
sectionHeader ||| 6. Conclusions
bodyText ||| This paper proposed a distributed scatternet-scheduling algo-
bodyText ||| rithm that adapts to non-uniform and changing traffic. This
note ||| 20	R. KAPOOR ET AL.
note ||| algorithm provides an integrated solution for both intra- and
note ||| inter-piconet scheduling and can be implemented using the
note ||| HOLD mode of Bluetooth. Through analysis and simulations,
note ||| we showed that the algorithm is traffic-adaptive and results in
note ||| a fair allocation of bandwidth to units. We explained earlier
note ||| that the algorithm may allow a unit to go into a power-saving
note ||| mode.
note ||| In future, we would like to explore this option, which also
note ||| assumes importance since Bluetooth devices will most likely
note ||| operate in a power-constrained environment. As future work,
note ||| we would also like to evaluate the performance of TCP and
note ||| other kinds of traffic on our algorithm. We are also working
note ||| towards interfacing the algorithm with requirements of higher
note ||| layers. In this respect, we are working towards providing QoS
note ||| support using the algorithm.
sectionHeader ||| References
reference ||| [1] S. Baatz, M. Frank, C. Kehl, P. Martini and C. Scholz, Adaptive scat-
reference ||| ternet support for Bluetooth using sniff mode, in: Proc. of IEEE LCN
reference ||| (2001).
reference ||| [2] A. Das, A. Ghose, A. Razdan, H. Saran and R. Shorey, Enhancing per-
reference ||| formance of asynchronous data traffic over the Bluetooth wireless ad-
reference ||| hoc network, in: Proc. ofIEEE INFOCOM’2001 (2001).
reference ||| [3] J. Haartsen, BLUETOOTH – the universal radio interface for ad hoc
reference ||| wireless connectivity, Ericsson Review 3 (1998) 110–117.
reference ||| [4] P. Johansson, M. Kazantzidis, R. Kapoor and M. Gerla, Bluetooth – an
reference ||| enabler for personal area networking, IEEE Network Magazine, Wire-
reference ||| less Personal Area Network (September 2001).
reference ||| [5] M. Kalia, D. Bansal and R. Shorey, MAC scheduling and SAR policies
reference ||| for Bluetooth: A master driven TDD pico-cellular wireless system, in:
reference ||| Proc. of 6th IEEE International Workshop on Mobile Multimedia Com-
reference ||| munications (MOMUC) (1999).
reference ||| [6] R. Kapoor, L. Chen, Y. Lee and M. Gerla, Bluetooth: carrying voice
reference ||| over ACL links, in: Proc. of MWCN (2002).
reference ||| [7] A. Mayer, Y. Ofek and M. Yung, Approximating max-min fair rates via
reference ||| distributed local scheduling with partial information, in: Proc. of IEEE
reference ||| INFOCOM (1996).
reference ||| [8] NS-2 simulator, http://www.isi.edu/nsnam/ns/
reference ||| [9] A. Racz, G. Miklos, F. Kubinszky and A. Valko, A pseudo-random
reference ||| coordinated scheduling algorithm for Bluetooth scatternets, in: Proc.
reference ||| ofMobiHoc (2001).
reference ||| [10] Specifications of the Bluetooth System – core, Vol. 1, v. 1.1, www.
reference ||| Bluetooth.com
reference ||| [11] W. Zhang and G. Cao, A flexible scatternet-wide scheduling algorithm
reference ||| for Bluetooth networks, in: Proc. ofIEEE IPCCC (2002).
note ||| Rohit Kapoor received his Bachelor degree in com-
note ||| puter science in 1999 from the University of Roor-
note ||| kee, India. He is currently a Ph.D. candidate at the
note ||| University of California, Los Angeles (UCLA). His
note ||| research focuses on Bluetooth-based personal area
note ||| networks. He is a member of the Network Research
note ||| Lab at UCLA.
email ||| E-mail: rohitk@cs.ucla.edu
note ||| Andrea Zanella received the Ph.D. degree in tele-
note ||| communication engineering from the University of
note ||| Padova, Italy, in 2002. Prior to that he received
note ||| the Dr. Ing. degree (comparable to Master degree)
note ||| in computer engineering in 1998, still from the Uni-
note ||| versity of Padova. He spent nine months, in 2001, as
note ||| post-doc researcher at the Department of Computer
note ||| Science of the University of California, Los Ange-
note ||| les (UCLA), where he was engaged in research on
note ||| Wireless Networks and Wireless Access to Internet
note ||| under the supervision of Prof. Mario Gerla. Currently, he is a research fellow
note ||| in the Department of Information Engineering of the University of Padova,
note ||| Italy. His research interests are mainly focused on topics related to wireless
note ||| and mobile networking. In particular, in the last period, he has been working
note ||| on the performance aspects of wireless personal area networks based on the
note ||| Bluetooth standard.
email ||| E-mail: zanella@dei.unipd.it
note ||| Mario Gerla is a professor in the Computer Science
note ||| Department at UCLA. He received his graduate de-
note ||| gree in engineering from the Politecnico di Milano
note ||| in 1966, and his M.S. and Ph.D. degrees in engi-
note ||| neering from UCLA in 1970 and 1973, respectively.
note ||| He joined the faculty of the UCLA Computer Sci-
note ||| ence Department in 1977. His current research is
note ||| in the area of analysis, design and control of com-
note ||| munication networks. Ongoing projects include the
note ||| design and evaluation of QoS routing and multicast
note ||| algorithms for IP domains, the design and evaluation of all-optical network
note ||| topologies and access protocols, the design of wireless mobile, multimedia
note ||| networks for mobile computing applications, and the development of mea-
note ||| surement methods and tools for evaluating the performance of high-speed
note ||| networks and applications.
email ||| E-mail: gerla@cs.ucla.edu
