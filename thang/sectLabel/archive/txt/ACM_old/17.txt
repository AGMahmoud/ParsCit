A Pseudo Random Coordinated Scheduling Algorithm for
Bluetooth Scatternets
Andr´as R´acz, Gy¨orgy Mikl´os, Ferenc Kubinszky, Andr´as Valk´o
Traffic Analysis and Network Performance Lab., Ericsson Research
Laborc 1, 1037 Budapest, Hungary
Ph: +36-1-4377621, Fax: +36-1-4377767
Andras.Racz@eth.ericsson.se
ABSTRACT
The emergence of Bluetooth as a default radio interface allows +L+ handheld devices to be rapidly interconnected into ad hoc networks. +L+ Bluetooth allows large numbers of piconets to form a scatternet us- +L+ ing designated nodes that participate in multiple piconets. A unit +L+ that participates in multiple piconets can serve as a bridge and for- +L+ wards traffic between neighbouring piconets. Since a Bluetooth +L+ unit can transmit or receive in only one piconet at a time, a bridging +L+ unit has to share its time among the different piconets. To sched- +L+ ule communication with bridging nodes one must take into account +L+ their availability in the different piconets, which represents a dif- +L+ ficult, scatternet wide coordination problem and can be an impor- +L+ tant performance bottleneck in building scatternets. In this paper +L+ we propose the Pseudo-Random Coordinated Scatternet Schedul- +L+ ing (PCSS) algorithm to perform the scheduling of both intra and +L+ inter-piconet communication. In this algorithm Bluetooth nodes +L+ assign meeting points with their peers such that the sequence of +L+ meeting points follows a pseudo random process that is different +L+ for each pair of nodes. The uniqueness of the pseudo random se- +L+ quence guarantees that the meeting points with different peers of +L+ the node will collide only occasionally. This removes the need +L+ for explicit information exchange between peer devices, which is +L+ a major advantage of the algorithm. The lack of explicit signaling +L+ between Bluetooth nodes makes it easy to deploy the PCSS algo- +L+ rithm in Bluetooth devices, while conformance to the current Blue- +L+ tooth specification is also maintained. To assess the performance of +L+ the algorithm we define two reference case schedulers and perform +L+ simulations in a number of scenarios where we compare the perfor- +L+ mance of PCSS to the performance of the reference schedulers.
Keywords
Bluetooth, scheduling, inter-piconet communication, scatternet
1. INTRODUCTION
Short range radio technologies enable users to rapidly interconnect +L+ handheld electronic devices such as cellular phones, palm devices +L+ or notebook computers. The emergence of Bluetooth [1] as de-
Permission to make digital or hard copies of part or all of this work or +L+ personal or classroom use is granted without fee provided that copies are +L+ not made or distributed for profit or commercial advantage and that copies +L+ bear this notice and the full citation on the first page. To copy otherwise, to +L+ republish, to post on servers, or to redistribute to lists, requires prior +L+ specific permission and/or a fee.
MobiHOC 2001, Long Beach, CA, USA
© ACM 2001 1-58113-390-1/01/10...$5.00
fault radio interface in these devices provides an opportunity to turn +L+ them from stand-alone tools into networked equipment. Building +L+ Bluetooth ad hoc networks also represents, however, a number of +L+ new challenges, partly stemming from the fact that Bluetooth was +L+ originally developed for single hop wireless connections. In this +L+ paper we study the scheduling problems of inter-piconet commu- +L+ nication and propose a lightweight scheduling algorithm that Blue- +L+ tooth nodes can employ to perform the scheduling of both intra and +L+ inter-piconet communication.
Bluetooth is a short range radio technology operating in the unli- +L+ censed ISM (Industrial-Scientific-Medical) band using a frequency +L+ hopping scheme. Bluetooth (BT) units are organized into piconets. +L+ There is one Bluetooth device in each piconet that acts as the mas- +L+ ter, which can have any number of slaves out of which up to seven +L+ can be active simultaneously. The communication within a piconet +L+ is organized by the master which polls each slave according to some +L+ polling scheme. A slave is only allowed to transmit in a slave- +L+ to-master slot if it has been polled by the master in the previous +L+ master-to-slave slot. In Section 3 we present a brief overview of +L+ the Bluetooth technology.
A Bluetooth unit can participate in more than one piconet at any +L+ time but it can be a master in only one piconet. A unit that par- +L+ ticipates in multiple piconets can serve as a bridge thus allowing +L+ the piconets to form a larger network. We define bridging degree +L+ as the number of piconets a bridging node is member of. A set +L+ of piconets that are all interconnected by such bridging units is re- +L+ ferred to as a scatternet network (Figure 1). Since a Bluetooth unit +L+ can transmit or receive in only one piconet at a time, bridging units +L+ must switch between piconets on a time division basis. Due to the +L+ fact that different piconets are not synchronized in time a bridging +L+ unit necessarily loses some time while switching from one piconet +L+ to the other. Furthermore, the temporal unavailability of bridging +L+ nodes in the different piconets makes it difficult to coordinate the +L+ communication with them, which impacts throughput and can be +L+ an important performance constraint in building scatternets.
There are two important phenomena that can reduce the efficiency +L+ of the polling based communication in Bluetooth scatternets:
•	slaves that have no data to transmit may be unnecessarily +L+ polled, while other slaves with data to transmit may have to +L+ wait to be polled; and
•	at the time of an expected poll one of the nodes of a master- +L+ slave node pair may not be present in the piconet (the slave
Figure 1: Example scatternet
that is being polled is not listening or the master that is ex- +L+ pected to poll is not polling).
The first problem applies to polling based schemes in general, while +L+ the second one is specific to the Bluetooth environment. In or- +L+ der to improve the efficiency of inter-piconet communication the +L+ scheduling algorithm has to coordinate the presence of bridging +L+ nodes in the different piconets such that the effect of the second +L+ phenomenon be minimized.
However, the scheduling of inter-piconet communication expands +L+ to a scatternet wide coordination problem. Each node that has more +L+ than one Bluetooth links have to schedule the order in which it com- +L+ municates with its respective neighbours. A node with multiple +L+ Bluetooth links can be either a piconet master or a bridging node or +L+ both. The scheduling order of two nodes will mutually depend on +L+ each other if they have a direct Bluetooth link in which case they +L+ have to schedule the communication on their common link for the +L+ same time slots. This necessitates some coordination between the +L+ respective schedulers. For instance in Figure 1 the scheduling order +L+ of node A and the scheduling order of its bridging neighbours, B, +L+ C, D and E mutually depend on each other, while nodes D and E +L+ further effects nodes F, G and H as well. Furthermore, the possi- +L+ ble loops in a scatternet (e.g., A-E-G-H-F-D) makes it even more +L+ complicated to resolve scheduling conflicts.
In case of bursty traffic in the scatternet the scheduling problem +L+ is further augmented by the need to adjust scheduling order in re- +L+ sponse to dynamic variation of traffic intensity. In a bursty traffic +L+ environment it is desirable that a node spends most of its time on +L+ those links that have a backlogged burst of data.
One way to address the coordination problem of inter-piconet +L+ scheduling is to explicitly allocate, in advance, time slots for com- +L+ munication in each pair of nodes. Such a hard coordination ap- +L+ proach eliminates ambiguity with regards to a node’s presence in +L+ piconets, but it implies a complex, scatternet wide coordination +L+ problem and requires explicit signaling between nodes of a scat- +L+ ternet. In the case of bursty traffic, hard coordination schemes +L+ generate a significant computation and signaling overhead as the +L+ communication slots have to be reallocated in response to changes +L+ in traffic intensity and each time when a new connection is estab- +L+ lished or released.
In this paper we propose the Pseudo-Random Coordinated Scatter- +L+ net Scheduling algorithm which falls in the category of soft coor- +L+ dination schemes. In soft coordination schemes nodes decide their +L+ presence in piconets based on local information. By nature, soft co- +L+ ordination schemes cannot guarantee conflict-free participation of +L+ bridging nodes in the different piconets, however, they have a sig- +L+ nificantly reduced complexity. In the PCSS algorithm coordination +L+ is achieved by implicit rules in the communication without the need +L+ of exchanging explicit control information. The low complexity of +L+ the algorithm and its conformance to the current Bluetooth specifi- +L+ cation allow easy implementation and deployment.
The first key component of the algorithm is the notion of check- +L+ points which are defined in relation to each pair of nodes that +L+ are connected by a Bluetooth link and which represent predictable +L+ points in time when packet transmission can be initiated on the par- +L+ ticular link. In other words, checkpoints serve as regular meeting +L+ points for neighboring nodes when they can exchange packets. In +L+ order to avoid systematic collision of checkpoints on different links +L+ of a node the position of checkpoints follows a pseudo random se- +L+ quence that is specific to the particular link the checkpoints belong +L+ to.
The second key component of the algorithm is the dynamic adjust- +L+ ment of checking intensity, which is necessary in order to effec- +L+ tively support bursty data traffic. Bandwidth can be allocated and +L+ deallocated to a particular link by increasing and decreasing check- +L+ point intensity, respectively.
To assess the performance of the algorithm we define two reference +L+ schedulers and relate the performance of the PCSS scheme to these +L+ reference algorithms in a number of simulation scenarios.
The remainder of the paper is structured as follows. In Section 2 we +L+ give an overview of related work focusing on Bluetooth scheduling +L+ related studies available in the literature. Section 3 gives a brief +L+ overview of the Bluetooth technology. In Section 4 and 5 we intro- +L+ duce the proposed algorithm. In Section 6 we define the reference +L+ schedulers. Finally, in Section 7 we present simulation results.
2. RELATED WORK
A number of researchers have addressed the issue of scheduling in +L+ Bluetooth. Most of these studies have been restricted, however, to +L+ the single piconet environment, where the fundamental question is +L+ the polling discipline used by the piconet master to poll its slaves. +L+ These algorithms are often referred to as intra-piconet scheduling +L+ schemes. In [7] the authors assume a simple round robin polling +L+ scheme and investigate queueing delays in master and slave units +L+ depending on the length of the Bluetooth packets used. In [5] Jo- +L+ hansson et al. analyze and compare the behavior of three differ- +L+ ent polling algorithms. They conclude that the simple round robin +L+ scheme may perform poorly in Bluetooth systems and they propose +L+ a scheme called Fair Exhaustive Polling. The authors demonstrate +L+ the strength of this scheme and argue in favor of using multi-slot +L+ packets. Similar conclusions are drawn by Kalia et al. who argue +L+ that the traditional round robin scheme may result in waste and un- +L+ fairness [8]. The authors propose two new scheduling disciplines +L+ that utilize information about the status of master and slave queues. +L+ In [9, 10] the authors concentrate on scheduling policies designed +L+ with the aim of low power consumption. A number of schedul- +L+ ing policies are proposed which exploit either the park or sniff low +L+ power modes of Bluetooth.
B
E
A
G
C
D
H
F
master
slave
slave in two piconets
slave in one piconet and master in another
Although the above studies have revealed a number of important +L+ performance aspects of scheduling in Bluetooth piconets, the algo- +L+ rithms developed therein are not applicable for inter-piconet com- +L+ munication. In [6] the authors have shown that constructing an op- +L+ timal link schedule that maximizes total throughput in a Bluetooth +L+ scatternet is an NP hard problem even if scheduling is performed +L+ by a central entity. The authors also propose a scheduling algo- +L+ rithm referred to as Distributed Scatternet Scheduling Algorithm +L+ (DSSA), which falls in the category of distributed, hard coordina- +L+ tion schemes. Although the DSSA algorithm provides a solution +L+ for scheduling communication in a scatternet, some of its idealized +L+ properties (e.g., nodes are aware of the traffic requirements of their +L+ neighbours) and its relatively high complexity make it difficult to +L+ apply it in a real life environment.
There is an ongoing work in the Personal Area Networking (PAN) +L+ working group of the Bluetooth Special Interest Group (SIG) [2] to +L+ define an appropriate scheduling algorithm for Bluetooth scatter- +L+ nets.
3. BLUETOOTH BACKGROUND
Bluetooth is a short range radio technology that uses frequency +L+ hopping scheme, where hopping is performed on 79 RF channels +L+ spaced 1 MHz apart. Communication in Bluetooth is always be- +L+ tween master and slave nodes. Being a master or a slave is only +L+ a logical state: any Bluetooth unit can be a master or a slave. +L+ The Bluetooth system provides full-duplex transmission based on +L+ slotted Time Division Duplex (TDD) scheme, where each slot is +L+ 0.625 ms long. Master-to-slave transmission always starts in an +L+ even-numbered time slot, while slave-to-master transmission al- +L+ ways starts in an odd-numbered time slot. A pair of master-to-slave +L+ and slave-to-master slots are often referred to as a frame. The com- +L+ munication within a piconet is organized by the master which polls +L+ each slave according to some polling scheme. A slave is only al- +L+ lowed to transmit in a slave-to-master slot if it has been polled by +L+ the master in the previous master-to-slave slot. The master may +L+ or may not include data in the packet used to poll a slave. Blue- +L+ tooth packets can carry synchronous data (e.g., real-time traffic) on +L+ Synchronous Connection Oriented (SCO) links or asynchronous +L+ data (e.g., elastic data traffic, which is the case in our study) on +L+ Asynchronous Connectionless (ACL) links. Bluetooth packets on +L+ an ACL link can be 1, 3 or 5 slot long and they can carry differ- +L+ ent amount of user data depending on whether the payload is FEC +L+ coded or not. Accordingly, the Bluetooth packet types DH 1, DH3 +L+ and DH5 denote 1, 3 and 5 slot packets, respectively, where the +L+ payload is not FEC encoded, while in case of packet types DM1, +L+ DM3 and DM5 the payload is protected with FEC encoding. There +L+ are two other types of packets, the POLL and NULL packets that do +L+ not carry user data. The POLL packet is used by the master when +L+ it has no user data to the slave but it still wants to poll it. Similarly, +L+ the NULL packet is used by the slave to respond to the master if it +L+ has no user data. For further information regarding the Bluetooth +L+ technology the reader is referred to [1, 3].
4. OVERVIEW OF THE PCSS ALGO- +L+ RITHM
Coordination in the PCSS algorithm is achieved by the unique +L+ pseudo random sequence of checkpoints that is specific to each +L+ master-slave node pair and by implicit information exchange be- +L+ tween peer devices. A checkpoint is a designated Bluetooth frame. +L+ The activity of being present at a checkpoint is referred to as to +L+ check. A master node actively checks its slave by sending a packet
to the slave at the corresponding checkpoint and waiting for a re- +L+ sponse from the slave. The slave node passively checks its master +L+ by listening to the master at the checkpoint and sending a response +L+ packet in case of being addressed.
The expected behaviour of nodes is that they show up at each +L+ checkpoint on all of their links and check their peers for available +L+ user data. The exchange of user data packets started at a check- +L+ point can be continued in the slots following the checkpoint. A +L+ node remains active on the current link until there is user data in +L+ either the master-to-slave or slave-to-master directions or until it +L+ has to leave for a next checkpoint on one of its other links. In +L+ the PCSS scheme we exploit the concept of randomness in assign- +L+ ing the position of checkpoints, which excludes the possibility that +L+ checkpoints on different links of a node will collide systematically, +L+ thus giving the node an equal chance to visit all of its checkpoints. +L+ The pseudo random procedure is similar to the one used to derive +L+ the pseudo random frequency hopping sequence. In particular, the +L+ PCSS scheme assigns the positions of checkpoints on a given link +L+ following a pseudo random sequence that is generated based on the +L+ Bluetooth clock of the master and the MAC address of the slave. +L+ This scheme guarantees that the same pseudo random sequence +L+ will be generated by both nodes of a master-slave pair, while the se- +L+ quences belonging to different node pairs will be different. Figure +L+ 2 shows an example for the pseudo random arrangement of check- +L+ points in case of a node pair A and B. The length of the current base +L+ checking interval is denoted by T(h k and the current checking in- +L+ tensity is defined accordingly as e9 . There is one checkpoint
T(i) heck
within each base checking interval and the position of the check- +L+ point within this window is changing from one time window to the +L+ other in a pseudo random manner.
Figure 2: Pseudo-random positioning of checkpoints
Since the pseudo random sequence is different from one link to an- +L+ other, checkpoints on different links of a node will collide only oc- +L+ casionally. In case of collision the node can attend only one of the +L+ colliding checkpoints, which implies that the corresponding neigh- +L+ bours have to be prepared for a non-present peer. That is, the mas- +L+ ter might not poll and the slave might not listen at a checkpoint. +L+ We note that a collision occurs either if there are more than one +L+ checkpoints scheduled for the same time slot or if the checkpoints +L+ are so close to each other that a packet transmission started at the +L+ first checkpoint necessarily overlaps the second one. Furthermore, +L+ if the colliding checkpoints belong to links in different piconets, +L+ the necessary time to perform the switch must be also taken into +L+ account.
During the communication there is the possibility to increase or +L+ decrease the intensity of checkpoints depending on the amount of +L+ user data to be transmitted and on the available capacity of the +L+ node. According to the PCSS algorithm a node performs certain +L+ traffic measurements at the checkpoints and increases or decreases +L+ the current checking intensity based on these measurements. Since
T(Z) +L+ check
1 frame
checkpoints of A toward B	checkpoints of B toward A
nodes decide independently about the current checking intensity +L+ without explicit coordination, two nodes on a given link may select +L+ different base checking periods. In order to ensure that two nodes +L+ with different checking intensities on the same link can still com- +L+ municate we require the pseudo random generation of checkpoints +L+ to be such that the set of checkpoint positions at a lower checking +L+ intensity is a subset of checkpoint positions at any higher checking +L+ intensities. In the Appendix we are going to present a pseudo ran- +L+ dom scheme for generating the position of checkpoints, which has +L+ the desired properties.
5. OPERATION OF PCSS
In what follows, we describe the procedures of the PCSS algorithm. +L+ We start by the initialization process which ensures that two nodes +L+ can start communication as soon as a new link has been established +L+ or the connection has been reset. Next, we describe the rules that +L+ define how nodes calculate their checkpoints, decide upon their +L+ presence at checkpoints and exchange packets. Finally, we present +L+ the way neighboring nodes can dynamically increase and decrease +L+ of checkpoint intensity.
5.1 Initialization
In the PCSS algorithm there is no need for a separate initialization +L+ procedure to start communication, since the pseudo random gener- +L+ ation of checkpoints is defined such that once a master slave node +L+ pair share the same master’s clock and slave’s MAC address infor- +L+ mation, it is guaranteed that the same pseudo random sequence will +L+ be produced at each node. That is, it is guaranteed that two nodes +L+ starting checkpoint generation at different time instants with differ- +L+ ent checking intensities will be able to communicate. It is the own +L+ decision of the nodes to select an appropriate initial checking in- +L+ tensity, which may depend for example on the free capacities of the +L+ node or on the amount of data to transmit. Once the communication +L+ is established the increase and decrease procedures will adjust the +L+ possibly different initial checking intensities to a common value.
5.2 Communication
A pair of nodes can start exchanging user data packets at a check- +L+ point, which can expand through the slots following the checkpoint. +L+ The nodes remain active on the current link following a check- +L+ point until there is user data to be transmitted or one of them has to +L+ leave in order to attend a checkpoint on one of its other links. Af- +L+ ter a POLL/NULL packet pair has been exchanged indicating that +L+ there is no more user data left the nodes switch off their transmit- +L+ ters/receivers and remain idle until a next checkpoint comes on one +L+ of their links. However, during the communication any of the nodes +L+ can leave in order to attend a coming checkpoint on one of its other +L+ links. After one of the nodes has left the remaining peer will realize +L+ the absence of the node and will go idle until the time of its next +L+ checkpoint. If the master has left earlier the slave will realize the +L+ absence of the master at the next master-to-slave slot by not receiv- +L+ ing the expected poll. In the worst case the master has left before +L+ receiving the last packet response from the slave, which can be a 5 +L+ slot packet in which case the slave wastes 5+1 slots before realiz- +L+ ing the absence of the master. Similarly, if the master does not get +L+ a response from the slave it assumes that the slave has already left +L+ the checkpoint and goes idle until its next checkpoint. Note that the +L+ master may also waste 5+1 slots in the worst case before realizing +L+ the absence of the slave.
A node stores the current length of the base checking interval and +L+ the time of the next checkpoint for each of its Bluetooth links sep-
arately. For its ith link a node maintains the variable Tcheck to +L+ store the length of the current base checking period in number of +L+ frames and the variable t(i)
check, which stores the Bluetooth clock +L+ of the master at the next checkpoint. After passing a checkpoint +L+ the variable thheck is updated to the next checkpoint by running +L+ the pseudo random generator (PseudoChkGen) with the current +L+ value of the master’s clock t(i) and the length of the base checking +L+ period Tcheck and with the MAC address of the slave A(i)
slave as in-
put parameters; tcizeck = PseudoChkGen(Tcheck, A(i)slave, t(i)). +L+ The procedure PseudoChkGen is described in the Appendix.
There is a maximum and minimum checking interval Tmax = +L+ 2fmax and Tmin = 2fmin, respectively. The length of the check- +L+ ing period must be a power of 2 number of frames and it must take +L+ a value from the interval [2fmin, 2fmax].
5.3 Increasing and Decreasing Checking In- +L+ tensity
The increase and decrease procedures are used to adjust the check- +L+ ing intensity of a node according to the traffic intensity and to the +L+ availability of the peer device. Each node decides independently +L+ about the current checking intensity based on traffic measurements +L+ at checkpoints.
Since the time spent by a node on a link is proportional to the ratio +L+ of the number of checkpoints on that link and the number of check- +L+ points on all links of the node, the bandwidth allocated to a link can +L+ be controlled by the intensity of checkpoints on that link. This can +L+ be shown by the following simple calculation.
Let us assume that the node has L number of links and assume +L+ further that for the base checking periods on all links of the node +L+ it holds that Tmin :5 T(i)
check &lt; Tmax, Vi = 1, ... , L. Then the +L+ average number of checkpoints within an interval of length Tmaxis
L
N = 1 T ,)ax  , and the average time between two consecutive
Tcheck
checkpoints is
t=	Tmax	=		1	
	N				
					,
			L	1  Th	
				check	
					
			i=1		
provided that the pseudo random generator produces a uniformly +L+ distributed sequence of checkpoints. Then, the share of link j from +L+ the total capacity of the node is
A node has to measure the utilization of checkpoints on each of +L+ its links separately in order to provide input to the checking inten- +L+ sity increase and decrease procedures. According to the algorithm +L+ a given checkpoint is considered to be utilized if both nodes have +L+ shown up at the checkpoint and at least one Bluetooth packet carry- +L+ ing user data has been transmitted or received. If there has not been +L+ a successful poll at the checkpoint due to the unavailability of any +L+ of the nodes or if there has been only a POLL/NULL packet pair +L+ exchange but no user data has been transmitted, the checkpoint is +L+ considered to be unutilized. We note that due to packet losses the +L+ utilization of a given checkpoint might be interpreted differently by +L+ the nodes. However, this does not impact correct operation of the +L+ algorithm.
.
rj =
1/T(j) check
L
1 
T(i)
i=1 check
To measure the utilization of checkpoints p(i) on the ith link of the +L+ node we employ the moving average method as follows. The uti- +L+ lization of a checkpoint equals to 1 if it has been utilized, otherwise +L+ it equals to 0. If the checkpoint has been utilized the variable p(i) +L+ is updated as,
p(i) = quti • p(i) + (1 — quti) • 1;
if the checkpoint has not been utilized it is updated as, +L+ p(i) = quti • p(i) + (1 — quti) • 0,
where 0 &lt; quti &lt; 1 is the time scale parameter of the moving +L+ average method. A further parameter of the utilization measure- +L+ ment is the minimum number of samples that have to be observed +L+ before the measured utilization value is considered to be confident +L+ and can be used as input to decide about increase and decrease of +L+ checking intensity. This minimum number of samples is a denoted
by Nsample,min.
Finally, a node also has to measure its total utilization, which is +L+ defined as the fraction of time slots where the node has been active +L+ (transmitted or received) over the total number of time slots. To +L+ measure the total utilization of a node we employ the moving aver- +L+ age method again. Each node measures its own utilization p(node) +L+ and updates the p(node) variable after each Nuti,win number of +L+ slots as follows:
(node) _ (node) (node) (node)
p —quti•p +(1—
quti )•p (win ),
where p(win) is the fraction of time slots in the past time window +L+ of length Nuti,win where the node has been active over the total +L+ number of time slots Nuti,win.
If the utilization of checkpoints on link i falls below the lower +L+ threshold plower, the current base checking period T(i)
check will be
doubled. Having a low checkpoint utilization can be either because +L+ one or both of the nodes have not shown up at all of the checkpoints +L+ or because there is not enough user data to be transmitted. In either +L+ cases the intensity of checkpoints has to be decreased. Whenever a +L+ decrease or increase is performed on link i the measured utilization +L+ p(i) must be reset.
Since the parameter T (i)k is one of the inputs to the pseudo ran-
chec
dom checkpoint generation process, PseudoChkGen the check- +L+ points after the decrease will be generated according to the new +L+ period. Furthermore, due to the special characteristic of the check- +L+ point generation scheme the remaining checkpoints after the de- +L+ crease will be a subset of the original checkpoints, which guaran- +L+ tees that the two nodes can sustain communication independent of +L+ local changes in checking intensities.
An example for the checking intensity decrease in case of a node +L+ pair A and B is shown in Figure 3. First, node A decreases check- +L+ ing intensity by doubling its current base checking period in re- +L+ sponse to the measured low utilization. As a consequence node B +L+ will find node A on average only at every second checkpoint and +L+ its measured utilization will decrease rapidly. When the measured +L+ utilization at node B falls below the threshold plower, B realizes +L+ that its peer has a lower checking intensity and follows the de- +L+ crease by doubling its current base checking period. Although we +L+ have not explicitly indicated in the Figure, it is assumed that there +L+ has been user data exchanged at each checkpoint where both nodes +L+ were present.
checkpoints of A toward B
node A reduces the checking
intensity, by doubling its base period	checkpoints of B toward A
ρ=0.35&lt;ρlower	ρ=0.2	ρ=0.35	ρ=0.5	ρ=0.65 ρ=0.7
node B realizes the decrease and +L+ doubles its base period
Figure 3: Checking intensity decrease
Recall from the utilization measurement procedure that there is a +L+ minimum number of checkpoints Nsample,min that has to be sam- +L+ pled before the measured utilization is considered to be confident +L+ and can be used to decide about checking intensity decrease. The +L+ parameter Nsample,min together with the parameter of the mov- +L+ ing average method quti determine the time scale over which the +L+ utilization of checkpoints has to be above the threshold plower, +L+ otherwise the node decreases checking intensity. It might be also +L+ reasonable to allow that the parameter Nsample,min and the mov- +L+ ing average parameter quti can be changed after each decrease or +L+ increase taking into account for example the current checking in- +L+ tensity, the available resources of the node or the amount of user +L+ data to be transmitted, etc. However, in the current implementation +L+ we apply fixed parameter values.
After a checkpoint where user data has been exchanged (not only a +L+ POLL/NULL packet pair) checking intensity can be increased pro- +L+ vided that the measured utilization of checkpoints exceeds the up- +L+ per threshold pupper and the node has available capacity. Formally +L+ a checking intensity increase is performed on link i if the following +L+ two conditions are satisfied: p(i) &gt; pupper and p(node) &lt; piinn T), +L+ where pupil r is the upper threshold of the total utilization of the +L+ node. This last condition ensures that the intensity of checkpoints +L+ will not increase unbounded. The intensity of checkpoints is dou- +L+ bled at each increase by dividing the current length of the base +L+ checking period T(n,eck by 2. For typical values of pupper we rec- +L+ ommend 0.8 &lt; pupper &lt; 0.9 in which case the respective plower +L+ value should be plower &lt; 0.4 in order to avoid oscillation of in- +L+ creases and decreases.
Figure 4 shows an example where node A and B communicate and +L+ after exchanging user data at the second checkpoint both nodes +L+ double the checking intensity. In the Figure we have explicitly in- +L+ dicated whether there has been user data exchanged at a checkpoint +L+ or not.
Figure 4: Checking intensity increase
ρ=0.6ρ=0.5 ρ=0.58ρ=0.48ρ=0.56 ρ=0.46ρ=0.36&lt;ρlower ρ=0.2	ρ=0.35 ρ=0.5
ρ=0.7	ρ=0.8&gt;ρupper ρ=0.2 ρ=0.4	ρ=0.3 ρ=0.55
checking intensity
ρ=0.3
ρ=0.55
ρ=0.8&gt;ρupper
ρ=0.2 ρ=0.4
checkpoints of A toward B +L+ checkpoints of B toward A
ρ=0.7
user data
both node A and B double
user data
user data	user data
6. REFERENCE ALGORITHMS
In this section we define the Ideal Coordinated Scatternet Sched- +L+ uler (ICSS) and the Uncoordinated Greedy Scatternet Scheduler +L+ (UGSS) reference algorithms. The ICSS algorithm represents +L+ the “ideal” case where nodes exploit all extra information when +L+ scheduling packet transmissions, which would not be available in a +L+ realistic scenario. The UGSS algorithm represents the greedy case +L+ where nodes continuously switch among their Bluetooth links in a +L+ random order.
6.1 The ICSS Algorithm
The ICSS algorithm is a hypothetical, ideal scheduling algorithm +L+ that we use as a reference case in the evaluation of the PCSS +L+ scheme. In the ICSS algorithm a node has the following extra +L+ information about its neighbours, which represents the idealized +L+ property of the algorithm:
•	a node is aware of the already pre-scheduled transmissions +L+ of its neighbours; and
•	a node is aware of the content of the transmission buffers of +L+ its neighbours.
According to the ICSS algorithm each node maintains a scheduling +L+ list, which contains the already pre-scheduled tasks of the node. A +L+ task always corresponds to one packet pair exchange with a given +L+ peer of the node. Knowing the scheduling list of the neighbours +L+ allows the node to schedule communication with its neighbours +L+ without overlapping their other communication, such that the ca- +L+ pacity of the nodes is utilized as much as possible. Furthermore +L+ being aware of the content of the transmission buffers of neigh- +L+ bours eliminates the inefficiencies of the polling based scheme, +L+ since there will be no unnecessary polls and the system will be +L+ work-conserving.
In the scheduling list of a node there is at most one packet pair +L+ exchange scheduled in relation to each of its peers, provided that +L+ there is a Bluetooth packet carrying user data either in the trans- +L+ mission buffer of the node or in the transmission buffer of the peer +L+ or in both. After completing a packet exchange on a given link the +L+ two nodes schedule the next packet exchange, provided that there +L+ is user data to be transmitted in at least one of the directions. If +L+ there is user data in only one of the directions, a POLL or NULL +L+ packet is assumed for the reverse direction depending on whether +L+ it is the master-to-slave or slave-to-master direction, respectively. +L+ The new task is fitted into the scheduling lists of the nodes using +L+ a first fit strategy. According to this strategy the task is fitted into +L+ the first time interval that is available in both of the scheduling lists +L+ and that is long enough to accommodate the new task. Note that the +L+ algorithm strives for maximal utilization of node capacity by trying +L+ to fill in the unused gaps in the scheduling lists.
If there is no more user data to be transmitted on a previously busy +L+ link, the link goes to idle in which case no tasks corresponding to +L+ the given link will be scheduled until there is user data again in at +L+ least one of the directions.
An example for the scheduling lists of a node pair A and B is shown +L+ in Figure 5. The tasks are labeled with the name of the correspond- +L+ ing peers the different tasks belong to. Each node has as many +L+ pre-scheduled tasks in its scheduling list as the number of its ac- +L+ tive Bluetooth links. A link is considered to be active if there is
current time
schedule the next packet pair +L+ exchange for node A and B
Figure 5: Example for the scheduling lists of a node pair in case +L+ of the ICSS algorithm
user data packet in at least one of the directions. Node A has active +L+ peers B and C, while node B has active peers A, D and E. After +L+ node A and B have finished the transmission of a packet pair they +L+ schedule the next task for the nearest time slots that are available +L+ in both of their scheduling lists and the number of consecutive free +L+ time slots is greater than or equal to the length of the task.
6.2 The UGSS Algorithm
In the UGSS algorithm Bluetooth nodes do not attempt to coordi- +L+ nate their meeting points, instead each node visits its neighbours +L+ in a random order. Nodes switch continuously among their Blue- +L+ tooth links in a greedy manner. If the node has n number of links it +L+ chooses each of them with a probability of 1/n. The greedy nature +L+ of the algorithm results in high power consumption of Bluetooth +L+ devices.
If the node is the master on the visited link it polls the slave by +L+ sending a packet on the given link. The type of Bluetooth packet +L+ sent can be a 1, 3 or 5 slot packet carrying useful data or an empty +L+ POLL packet depending on whether there is user data to be trans- +L+ mitted or not. After the packet has been sent the master remains +L+ active on the link in order to receive any response from the slave. +L+ If the slave has not been active on the given link at the time when +L+ the master has sent the packet it could not have received the packet +L+ and consequently it will not send a response to the master. After +L+ the master has received the response of the slave or if it has sensed +L+ the link to be idle indicating that no response from the salve can be +L+ expected, it selects the next link to visit randomly.
Similar procedure is followed when the node is the slave on the +L+ visited link. The slave tunes its receiver to the master and listens +L+ for a packet transmission from the master in the current master- +L+ to-slave slot. If the slave has not been addressed by the master +L+ in the actual master-to-slave slot it immediately goes to the next +L+ link. However, if the slave has been addressed it remains active on +L+ the current link and receives the packet. After having received the +L+ packet of the master the slave responds with its own packet in the +L+ following slave-to-master slot. After the slave has sent its response +L+ it selects the next link to visit randomly.
7. SIMULATION RESULTS
First, we evaluate the algorithm in a realistic usage scenario, which +L+ is the Network Access Point (NAP) scenario. Next we investigate +L+ theoretical configurations and obtain asymptotical results that re- +L+ veals the scaling properties of the algorithm. For instance we in- +L+ vestigate the carried traffic in function of the number of forwarding
peer B
Dee, C	pear C
t
peer A
✑peer E	peer E
t
scheduling list of +L+ node A
Deer B
scheduling list of
node B
Deer A p
eer D
hops along the path and in function of bridging degree. Both in the +L+ realistic and theoretical configurations we relate the performance of +L+ the PCSS scheme to the performance of the ICSS and UGSS ref- +L+ erence algorithms. Before presenting the scenarios and simulation +L+ results we shortly describe the simulation environment and define +L+ the performance metrics that are going to be measured during the +L+ simulations.
7.1 Simulation Environment
We have developed a Bluetooth packet level simulator, which is +L+ based on the Plasma simulation environment [4]. The simulator +L+ has a detailed model of all the packet transmission, reception pro- +L+ cedures in the Bluetooth Baseband including packet buffering, up- +L+ per layer packet segmentation/reassemble, the ARQ mechanism, +L+ etc. The simulator supports all Bluetooth packet types and follows +L+ the same master-slave slot structure as in Bluetooth. For the physi- +L+ cal layer we employ a simplified analytical model that captures the +L+ frequency collision effect of interfering piconets.
In the current simulations the connection establishment procedures, +L+ e.g., the inquiry and page procedures are not simulated in detail and +L+ we do not consider dynamic scatternet formation either. Instead we +L+ perform simulations in static scatternet configurations where the +L+ scatternet topology is kept constant during one particular run of +L+ simulation.
In the current simulations we run IP directly on top of the Blue- +L+ tooth link layer and we apply AODV as the routing protocol in the +L+ IP layer. The simulator also includes various implementations of +L+ the TCP protocol (we employed RenoPlus) and supports different +L+ TCP/IP applications, from which we used TCP bulk data transfer +L+ in the current simulations.
One of the most important user perceived performance measures is +L+ the achieved throughput. We are going to investigate the throughput +L+ in case of bulk TCP data transfer and in case of Constant Bit Rate +L+ (CBR) sources.
In order to take into account the power consumption of nodes we +L+ define activity ratio of a node, ract as the fraction of time when +L+ the node has been active over the total elapsed time; and power +L+ efficiency, pep p as the fraction of the number of user bytes success- +L+ fully communicated (transmitted and received) over the total time +L+ the node has been active. The power efficiency shows the num- +L+ ber of user bytes that can be communicated by the node during an +L+ active period of length 1 sec. Power efficiency can be measured +L+ in [kbit/sec], or assuming that being active for 1 sec consumes 1 +L+ unit of energy we can get a more straightforward dimension of +L+ [kbit/energy unit], which is interpreted as the number of bits that +L+ can be transmitted while consuming one unit of energy.
7.2 Network Access Point Scenario
In this scenario we have a NAP that is assumed to be connected to +L+ a wired network infrastructure and it provides network access via +L+ its Bluetooth radio interface. The NAP acts as a master and up to 7 +L+ laptops, all acting as slaves, can connect to the NAP. Furthermore +L+ we assume that each laptop has a Bluetooth enabled mouse and +L+ each laptop connects to its mouse by forming a new piconet as it is +L+ shown in Figure 6.
We simulate a bulk TCP data transfer from the NAP towards each +L+ laptop separately. Regarding the traffic generated by the mouse we +L+ assume that the mouse produces a 16 byte long packet each 50 ms,
Figure 6: Network Access Point Scenario
periodically. In the NAP-laptop communication we are interested +L+ in the achieved throughput while in the laptop-mouse communi- +L+ cation we are concerned with the delay perceived by the mouse. +L+ In the current scenario we switched off the dynamic checkperiod +L+ adjustment capability of the PCSS algorithm and we set the base +L+ checking period to 32 frames (40 ms), which is in accordance with +L+ the delay requirement of a mouse. Note that this same base check- +L+ ing period is applied also on the NAP-laptop links, although, there +L+ is no delay requirement for the TCP traffic. However, the current +L+ implementation in the simulator does not yet support the setting of +L+ the base checking periods for each link separately. The dynamic +L+ checking period adjustment would definitely improve the through- +L+ put of NAP-laptop communication as we are going to see later in +L+ case of other configurations.
The simulation results are shown in Figure 7. In plot (a) the aver- +L+ aged throughput of NAP-laptop communications are shown in the +L+ function of number of laptops for the different algorithms, respec- +L+ tively. Graph (b) plots the sum of the throughputs between the +L+ NAP and all laptops. As we expect, the individual laptop through- +L+ put decreases as the number of laptops increases. However, it is +L+ important to notice that the sum of laptop throughputs do not de- +L+ crease with increasing number of laptops in case of the PCSS and +L+ ICSS algorithms. As the number of laptops increases the efficient +L+ coordination becomes more important and the total carried traffic +L+ will decrease with the uncoordinated UGSS scheme. The increase +L+ of the total throughput in case of the PCSS algorithm is the conse- +L+ quence of the fixed checking intensities, which allocates one half +L+ of a laptop capacity to the mouse and the other half to the NAP. In +L+ case of small number of laptops this prevents the laptops to fully +L+ utilize the NAP capacity, which improves as the number of laptops +L+ increases.
The 99% percentile of the delay seen by mouse packets is shown in +L+ plot (c). The delay that can be provided with the PCSS algorithm +L+ is determined by the base checking period that we use. Recall, that +L+ in the current setup the base checking period of the PCSS scheme +L+ was set to 32 frames, which implies that the delay has to be in the +L+ order of 32 frames, as shown in the figure. The low delay with the +L+ UGSS algorithm is due to the continuous switching among the links +L+ of a node, which ensures high polling intensity within a piconet +L+ and frequent switching between piconets. The UGSS algorithm +L+ provides an unnecessarily low delay, which is less than the delay +L+ requirement at the expense of higher power consumption.
Plots (d) and (e) show the averaged activity ratio over all lap- +L+ tops and mice, respectively. The considerably higher throughput +L+ achieved for small number of laptops by the ICSS scheme explains +L+ its higher activity ratio. On graph (f) the averaged power efficiency +L+ of laptops is shown, which relates the number of bytes transmit- +L+ ted to the total time of activity. The power efficiency of the PCSS
mouse
mouse
NAP
laptop	max 7	laptop
scheme decreases with increasing number of laptops, which is a +L+ consequence of the fixed checking intensities. Since the NAP has +L+ to share its capacity among the laptops, with an increasing number +L+ of laptops there will be an increasing number of checkpoints where +L+ the NAP cannot show up. In such cases the dynamic checking in- +L+ tensity adjustment procedure could help by decreasing checking +L+ intensity on the NAP-laptop links. Recall that in the current sce- +L+ nario we employed fixed checking intensities in order to satisfy the +L+ mouse delay requirement. It is also important to notice that with the +L+ uncoordinated UGSS scheme the activity ratio of a mouse is rela- +L+ tively high, which is an important drawback considering the low +L+ power capabilities of such devices.
7.3 Impact of Number of Forwarding Hops
In what follows, we investigate the performance impact of the num- +L+ ber of forwarding hops along the communication path in the scat- +L+ ternet configuration shown in Figure 8. The configuration consists +L+ of a chain of S/M forwarding nodes (Fi) and a certain number of +L+ additional node pairs connected to each forwarding node in order to +L+ generate background traffic. The number of S/M forwarding nodes +L+ is denoted by NF. There are NB number of background node pairs +L+ connected to each forwarding node as masters. The background +L+ traffic flows from each source node Bz) to its destination pair
B(P) through the corresponding forwarding node Fi. The traffic +L+ that we are interested in is a bulk TCP data transfer between node +L+ S and D. The background traffic is a CBR source, which generates +L+ 512 byte long IP packets with a period of length 0.05 sec.
D
During the simulations we vary the number of forwarding hops NF +L+ and the number of background node pairs NB connected to each +L+ forwarding node. As one would expect, with increasing number of +L+ forwarding hops and background node pairs the coordinated algo- +L+ rithms will perform significantly better than the one without any +L+ coordination (UGSS).
The throughput of the S-D traffic as a function of the number of +L+ forwarding nodes (NF) without background traffic (NB = 0) and +L+ with two pairs of background nodes (NB = 2) are shown in Fig- +L+ ure 9 (a) and (b), respectively. The throughput in case of no cross +L+ traffic drops roughly by half when we introduce the first forward- +L+ ing node. Adding additional forwarding hops continuously reduces +L+ the throughput, however, the decrease at each step is less drasti- +L+ cal. We note that in case of the ICSS scheme one would expect +L+ that for NF &gt; 1 the throughput should not decrease by adding +L+ additional forwarding hops. However, there are a number of other +L+ effects besides the number of forwarding hops that decrease the +L+ throughput. For instance, with an increasing number of forward- +L+ ing hops the number of piconets in the same area increases, which, +L+ in turn, causes an increasing number of lost packets over the radio +L+ interface due to frequency collisions. Furthermore with increasing +L+ number of hops the end-to-end delay suffered by the TCP flow in-
creases, which makes the TCP connection less reactive to recover +L+ from packet losses.
In the no background traffic case the PCSS scheme performs close +L+ to the UGSS algorithm in terms of throughput. However, as we +L+ introduce two pairs of background nodes the UGSS algorithm fails +L+ completely, while the PCSS scheme still achieves approximately 20 +L+ kbit/sec throughput. Furthermore, the power efficiency of the PCSS +L+ scheme is an order of magnitude higher than that of the UGSS algo- +L+ rithm in both cases, which indicates that the PCSS algorithm con- +L+ sumes significantly less power to transmit the same amount of data +L+ than the UGSS scheme.
7.4 Impact of Bridging Degree
Next we investigate the performance of scheduling algorithms as +L+ the number of piconets that a bridging node participates in is in- +L+ creased. The scatternet setup that we consider is shown in Figure +L+ 10, where we are interested in the performance of the bridging node +L+ C. Node C is an all slave bridging node and it is connected to mas- +L+ ter nodes Pi, where the number of these master nodes is denoted +L+ by NP. To each master node Pi we connect NL number of leaf +L+ nodes as slaves in order to generate additional background load in +L+ the piconets. We introduce bulk TCP data transfer from node C +L+ towards each of its master node Pi and CBR background traffic
on each Lij — Pi link. The packet generation interval for back-
ground sources was set to 0.25 sec, which corresponds to a 16 +L+ kbit/sec stream. During the simulation we vary the number of pi- +L+ conets NP participated by node C and investigate the performance +L+ of the PCSS algorithm with and without dynamic checkpoint inten- +L+ sity changes. The number of background nodes NL connected to +L+ each master node Pi was set to NL = 3 and it was kept constant in +L+ the simulations.
LmNL
The throughputs of TCP flows between node C and each Pi are av- +L+ eraged and it is shown in Figure 10 (a). The sum of TCP through- +L+ puts are plotted in graph (b) and the power efficiency of the central +L+ node is shown in graph (c). The PCSS algorithm has been tested +L+ both with fixed base checking periods equal to 32 frames (“PCSS- +L+ 32”) and with dynamic checking intensity changes as well (“PCSS- +L+ dyn”). The parameter settings of the dynamic case is shown in Ta- +L+ ble 1.
quti = 0.7	Nsample,min = 4	
Plower = 0.3	Pupper = 0.7	
quiode)=0.7	Nuti,win = 10	maxe) = 0.8
Tmin = 8	Tmax = 256	
Table 1: Parameter setting of the dynamic PCSS scheme
Lmi
LNPm
Pm
LNPNL
PNP
C
Figure 10: Impact of number of participated piconets
	B(D)	B(D)	B(D).
	1i	2i	NF�
Figure 8: Impact of number of forwarding nodes
B(S)
B(S)
F1	F2	FNF
S
B(S) +L+ N. +L+ F�
(d)	(e)	(f)
Figure 7: Throughput, delay and power measures in the function of number of laptops connected to the NAP
Activity Ratio of laptops
Activity Ratio of mice
Power efficiency of laptops
TCP throughput per laptop
Sum TCP throughput of laptops
0.99 percentile of mouse dealy
1	2	3	4	5	6	7
Number of laptops
1	2	3	4	5	6	7
Number of laptops
1	2	3	4	5	6	7
Number of laptops
(a)	(b)	(c)
PCSS +L+ UGSS +L+ ICSS
PCSS +L+ UGSS +L+ ICSS
500 +L+ 450 +L+ 400
350
300
250
200
150
100 +L+ 50 +L+ 0
0.06 +L+ 0.05 +L+ 0.04 +L+ 0.03 +L+ 0.02 +L+ 0.01 +L+ 0
500
450
400
350 +L+ 300 +L+ 250 +L+ 200 +L+ 150 +L+ 100 +L+ 50
0
PCSS +L+ UGSS +L+ ICSS
1	2	3	4	5	6	7
Number of laptops
1	2	3	4	5	6	7
Number of laptops
1	2	3	4	5	6	7
Number of laptops
600
0.9 +L+ 0.8 +L+ 0.7 +L+ 0.6 +L+ 0.5 +L+ 0.4 +L+ 0.3 +L+ 0.2 +L+ 0.1
500
PCSS +L+ UGSS +L+ ICSS
0.9 +L+ 0.8 +L+ 0.7 +L+ 0.6 +L+ 0.5 +L+ 0.4 +L+ 0.3 +L+ 0.2 +L+ 0.1
400
300
200
100
0
0
0
PCSS +L+ UGSS +L+ ICSS
PCSS +L+ UGSS +L+ ICSS
TCP throughput without background nodes (N_B=0)
PCSS +L+ UGSS +L+ ICSS
0	1	2	3	4	5	6	7	8
Number of forwarding nodes (N_F)
500 +L+ 450 +L+ 400 +L+ 350 +L+ 300 +L+ 250 +L+ 200 +L+ 150 +L+ 100 +L+ 50
0
TCP throughput with 2 pairs of background nodes (N_B=2)
Power efficiency of forwarding nodes (N_B=2)
0	1	2	3	4	5	6	7	8
Number of forwarding nodes (N_F)
0	1	2	3	4	5	6	7	8
Number of forwarding nodes (N_F)
0
300
200
100
500
450
400
PCSS +L+ UGSS +L+ ICSS
350
300
250
200
150
100
50
0
600
500
400
PCSS +L+ UGSS +L+ ICSS
(a)	(b)	(c)
Figure 9: Throughput and power efficiency in function of number of forwarding hops
It is important to notice that the per flow TCP throughputs in case +L+ of the dynamic PCSS scheme matches quite closely the through- +L+ put achieved by the ICSS algorithm and it significantly exceeds the +L+ throughput that has been achieved by the fixed PCSS. This large +L+ difference is due to the relatively low background traffic in the +L+ neighbouring piconets of node C, in which case the dynamic PCSS +L+ automatically reduces checkpoint intensity on the lightly loaded +L+ links and allocates more bandwidth to the highly loaded ones by +L+ increasing checking intensity.
8. CONCLUSIONS
We have presented Pseudo Random Coordinated Scatternet +L+ Scheduling, an algorithm that can efficiently control communica- +L+ tion in Bluetooth scatternets without exchange of control informa- +L+ tion between Bluetooth devices. The algorithm relies on two key +L+ components, namely the use of pseudo random sequences of meet- +L+ ing points, that eliminate systematic collisions, and a set of rules +L+ that govern the increase and decrease of meeting point intensity +L+ without explicit coordination.
We have evaluated the performance of PCSS in a number of sim- +L+ ulation scenarios, where we have compared throughput and power +L+ measures achieved by PCSS to those achieved by two reference +L+ schedulers. The first reference scheduler is an uncoordinated +L+ greedy algorithm, while the other is a hypothetical “ideal” sched- +L+ uler.
In all the scenarios investigated we have found that PCSS achieves +L+ higher throughput than the uncoordinated reference algorithm. +L+ Moreover, with the traffic dependent meeting point intensity adjust- +L+ ments the throughput and power measures of PCSS quite closely +L+ match the results of the “ideal” reference algorithm. At the same +L+ time PCSS consumes approximately the same amount of power as +L+ the ideal scheduler to achieve the same throughput, which is sig- +L+ nificantly less than the power consumption of the uncoordinated +L+ reference scheduler.
9. REFERENCES
[1] Bluetooth Special Interest Group. Bluetooth Baseband +L+ Specification Version 1.0 B. http://www.bluetooth.com/.
Figure 11: Throughput and power efficiency in function of the bridging degree of node C
Averaged TCP throughput between central node and master nodes
Sum of TCP throughputs at the central node
Effective power of central node
1	2	3	4	5	6
Number of piconets participated by the central node (N_P)
1	2	3	4	5	6
Number of piconets participated by the central node (N_P)
1	2	3	4	5	6
Number of piconets participated by the central node (N_P)
(a)	(b)	(c)
PCSS-3y2
PCSUGSS
ICSS
PCSS-32
PCSS-dyn
UGSS
ICSS
450
400
350
300
250
200
150
100
50
0
450
400
350
300
250
200
150
100
50
0
600 +L+ 500 +L+ 400 +L+ 300 +L+ 200 +L+ 100 +L+ 0
PCSS-32 +L+ P	y UGG
ICSS
[2] Bluetooth Special Interest Group. +L+ http://www.bluetooth.com/.
[3] J. Haartsen. BLUETOOTH- the universal radio interface for +L+ ad-hoc, wireless connectivity. Ericsson Review, (3), 1998.
[4] Z. Haraszti, I. Dahlquist, A. Farag´o, and T. Henk. Plasma - +L+ an integrated tool for ATM network operation. In Proc. +L+ International Switching Symposium, 1995.
[5] N. Johansson, U. K¨orner, and P. Johansson. Performance +L+ evaluation of scheduling algorithms for Bluetooth. In IFIP +L+ TC6 WG6.2 Fifth International Conference on Broadband +L+ Communications (BC’99), Hong Kong, November 1999.
[6] N. Johansson, U. K¨orner, and L. Tassiulas. A distributed +L+ scheduling algorithm for a Bluetooth scatternet. In Proc. of +L+ The Seventeenth International Teletraffic Congress, ITC’17, +L+ Salvador da Bahia, Brazil, September 2001.
[7] P. Johansson, N. Johansson, U. K¨orner, J. Elgg, and +L+ G. Svennarp. Short range radio based ad hoc networking: +L+ Performance and properties. In Proc. ofICC’99, Vancouver, +L+ 1999.
[8] M. Kalia, D. Bansal, and R. Shorey. MAC scheduling and +L+ SAR policies for Bluetooth: A master driven TDD +L+ pico-cellular wireless system. In IEEE Mobile Multimedia +L+ Communications Conference MOMUC’99, San Diego, +L+ November 1999.
[9] M. Kalia, D. Bansal, and R. Shorey. MAC scheduling +L+ policies for power optimization in Bluetooth: A master +L+ driven TDD wireless system. In IEEE Vehicular Technology +L+ Conference 2000, Tokyo, 2000.
[10] M. Kalia, S. Garg, and R. Shorey. Efficient policies for +L+ increasing capacity in Bluetooth: An indoor pico-cellular +L+ wireless system. In IEEE Vehicular Technology Conference +L+ 2000, Tokyo, 2000.
APPENDIX
Here, we present the procedure for generating the pseudo ran- +L+ dom sequence of checkpoints, where we reuse the elements of +L+ the pseudo random frequency hop generation procedure available +L+ in Bluetooth. The inputs to the checkpoint generation procedure +L+ PseudoChkGen are the current checking period T(h ck, the Blue- +L+ tooth MAC address of the slave As`ave and the current value of the
master’s clock t(i). A node can perform checkpoint generation us- +L+ ing the PseudoChkGen procedure at any point in time, it is al- +L+ ways guaranteed that the position of checkpoint generated by the +L+ two nodes will be the same, as it has been pointed out in Section +L+ 5.1. Nevertheless the typical case will be that whenever a node ar- +L+ rives to a checkpoint it generates the position of the next checkpoint +L+ on the given link. The variable t(i)cysstores the master’s
chek
clock at the next checkpoint, thus it needs to be updated every time +L+ a checkpoint is passed. Here we note that the Bluetooth clock of a +L+ device is a 28 bit counter, where the LSB changes at every half slot.
Let us assume that the base period of checkpoints on the it h link of +L+ the node is Tcheck = 2j-2, j &gt; 2 number of frames, which means +L+ that there is one pseudo randomly positioned checkpoint in each +L+ consecutive time interval of length T(h ck and the jth bit of the
Bluetooth clock changes at every Tcheck. Upon arrival to a check- +L+ point the variable t(i)
check equals to the current value of the master’s +L+ clock on that link. After the checkpoint generation procedure has +L+ been executed the variable tcheck will store the master’s clock at +L+ the time of the next checkpoint on that link.
Before starting the procedure the variable tch)eck is set to the cur- +L+ rent value of the master’s clock t(i) in order to cover the general +L+ case when at the time of generating the next checkpoint the value
of t(i)
check does not necessarily equals to the current value of the +L+ master’s clock t(i). The position of the next checkpoint is ob- +L+ tained such that the node first adds the current value of Tcheck +L+ to the variable tclzeck, clears the bits [j — 1, ... , 0] of tch)eck and
then generates the bits [j — 1, ... , 2] one by one using the pro-
cedure PseudoBitGen(X, WctT`). When generating the kth bit
(j-1 &lt; k &lt; 2) the clock bits X = tcheck [k+1, ... , k+5] are fed
as inputs to the PseudoBitGen procedure, while the control word +L+ WctT` is derived from tcheck including the bits already generated +L+ and from the MAC address of the slave As`ave. The schematic view +L+ of generating the clock bits of the next checkpoint is illustrated in +L+ Figure 12.
Figure 12: Generating the clock bits of the next checkpoint
28.
27.
Wctrl
k+5.
PseudoBitGen
X
k+1.
k.
2.
1.
0.
The PseudoBitGen procedure is based on the pseudo random +L+ scheme used for frequency hop selection in Bluetooth. How- +L+ ever, before presenting the PseudoBitGen procedure we give the +L+ pseudo-code of the PseudoChkGen procedure.
PseudoChkGen procedure:
t(i): the current value of the master’s clock;
Tcheck = 2j-2, j &gt; 2: current length of the base checkperiod +L+ in terms of number of frames.
(i)	(i)
tcheck = t
(i)tcheck [j — 1, . . . , 0] = 0;
t(i)= t(i)	+T(i)
check	check	check;
k=j—1; +L+ while (k &gt; 2)
X[0, ... , 4] = t(i)
check [k + 1,... , k + 5]; +L+ tcheck[k] =PseudoBitGen(X,WctTd); +L+ k=k-1;
end
Finally, we discuss the PseudoBitGen procedure, which is illus- +L+ trated in Figure 13.
Z[0]




Figure 13: The PseudoBitGen procedure
P[13,12] P[11,10] P[9,8]	P[7,6]	P[5,4]	P[3,2] P[1,0]
B
A
D
5
C
5
5
9
Add +L+ mod 32
5
Y
PERM5
bit selector +L+ V[k mod 5]
X +L+ O +L+ R
Z
X  5
5
5
V
1
O
Figure 14: Butterfly permutation
The control words of the PseudoBitGen procedure +L+ WctTd = {A, B, C, D} are the same as the control words of +L+ the frequency hop selection scheme in Bluetooth and they are +L+ shown in Table 2. However, the input X and the additional +L+ bit selection operator at the end are different. As it has been +L+ discussed above the input X is changing depending on which +L+ bit of the checkpoint is going to be generated. When gener- +L+ ating the kth clock bit of the next checkpoint the clock bits +L+ X = tcheck [k + 1,... , k + 5] are fed as inputs and the bit +L+ selection operator at the end selects the (k mod 5)th bit of the 5 +L+ bits long output V.
A	Asdave [27 — 23] ® tcheck [25 — 21]		
B	B[0 — 3] = Asdave[22 — 19], B[4] =		0
C	Asdave [8, 6, 4, 2, 0] ® t(i)	— 16]	
	check [20		
D	Asdave[18 — 10] ® t(i)	— 7]	
	check [15		
Table 2: Control words
The operation PERM5 is a butterfly permutation, which is the +L+ same as in the frequency hop selection scheme of Bluetooth and +L+ it is described in Figure 14. Each bit of the control word P is +L+ associated with a given bit exchange in the input word. If the +L+ given bit of the control word equals to 1 the corresponding bit ex- +L+ change is performed otherwise skipped. The control word P is +L+ obtained from C and D, such that P[i] = D[i], i = 0... 8 and +L+ P[j + 9] = C[j], j = 0 ... 4.
