A Distributed 3D Graphics Library
Blair MacIntyre and Steven Feiner1
Department of Computer Science
Columbia University
Abstract
We present Repo-3D, a general-purpose, object-oriented library for +L+ developing distributed, interactive 3D graphics applications across +L+ a range of heterogeneous workstations. Repo-3D is designed to +L+ make it easy for programmers to rapidly build prototypes using a +L+ familiar multi-threaded, object-oriented programming paradigm. +L+ All data sharing of both graphical and non-graphical data is done +L+ via general-purpose remote and replicated objects, presenting the +L+ illusion of a single distributed shared memory. Graphical objects +L+ are directly distributed, circumventing the “duplicate database” +L+ problem and allowing programmers to focus on the application +L+ details.
Repo-3D is embedded in Repo, an interpreted, lexically-scoped, +L+ distributed programming language, allowing entire applications to +L+ be rapidly prototyped. We discuss Repo-3D’s design, and introduce +L+ the notion of local variations to the graphical objects, which allow +L+ local changes to be applied to shared graphical structures. Local +L+ variations are needed to support transient local changes, such as +L+ highlighting, and responsive local editing operations. Finally, we +L+ discuss how our approach could be applied using other program- +L+ ming languages, such as Java.
CR Categories and Subject Descriptors: D.1.3 [Program- +L+ ming Techniques]: Concurrent Programming—Distributed Pro- +L+ gramming; H.4.1 [Information Systems Applications]: Office +L+ Automation—Groupware; I.3.2 [Computer Graphics]: Graphics +L+ Systems—Distributed/network graphics; I.3.6 [Computer Graph- +L+ ics]: Methodology and Techniques—Graphics data structures and +L+ data types; I.3.7 [Computer Graphics]: Three-Dimensional +L+ Graphics and Realism—Virtual reality.
Additional Keywords and Phrases: object-oriented graphics, +L+ distributed shared memory, distributed virtual environments, +L+ shared-data object model.
1 INTRODUCTION
Traditionally, distributed graphics has referred to the architecture +L+ of a single graphical application whose components are distributed +L+ over multiple machines [14, 15, 19, 27] (Figure 1a). By taking +L+ advantage of the combined power of multiple machines, and the +L+ particular features of individual machines, otherwise impractical +L+ applications became feasible. However, as machines have grown +L+ more powerful and application domains such as Computer
1. {bm,feiner}@cs.columbia.edu, http://www.cs.columbia.edu/graphics
Figure 1: Two meanings of distributed graphics: (a) a single logical +L+ graphics system with distributed components, and (b) multiple dis- +L+ tributed logical graphics systems. We use the second definition here.
Supported Cooperative Work (CSCW) and Distributed Virtual +L+ Environments (DVEs) have been making the transition from +L+ research labs to commercial products, the term distributed graphics +L+ is increasingly used to refer to systems for distributing the shared +L+ graphical state of multi-display/multi-person, distributed, interac- +L+ tive applications (Figure 1b). This is the definition that we use here. +L+ While many excellent, high-level programming libraries are +L+ available for building stand-alone 3D applications (e.g. Inventor +L+ [35], Performer [29], Java 3D [33]), there are no similarly powerful +L+ and general libraries for building distributed 3D graphics applica- +L+ tions. All CSCW and DVE systems with which we are familiar +L+ (e.g., [1, 7, 11, 12, 16, 28, 30, 31, 32, 34, 37, 41]) use the following +L+ approach: A mechanism is provided for distributing application +L+ state (either a custom solution or one based on a general-purpose +L+ distributed programming environment, such as ISIS [4] or Obliq +L+ [8]), and the state of the graphical display is maintained separately +L+ in the local graphics library. Keeping these “dual databases” syn- +L+ chronized is a complex, tedious, and error-prone endeavor. In con- +L+ trast, some non-distributed libraries, such as Inventor [35], allow +L+ programmers to avoid this problem by using the graphical scene +L+ description to encode application state. Extending this “single data- +L+ base” model to a distributed 3D graphics library is the goal of our +L+ work on Repo-3D.
Repo-3D is an object-oriented, high-level graphics package, +L+ derived from Obliq-3D [25]. Its 3D graphics facilities are similar to +L+ those of other modern high-level graphics libraries. However, the +L+ objects used to create the graphical scenes are directly distribut- +L+ able—from the programmer’s viewpoint, the objects reside in one +L+ large distributed shared memory (DSM) instead of in a single +L+ process. The underlying system replicates any of the fine-grained +L+ objects across as many processes as needed, with no additional +L+ effort on the part of the programmer. Updates to objects are +L+ automatically reflected in all replicas, with any required objects +L+ automatically distributed as needed. By integrating the replicated +L+ objects into the programming languages we use, distributed +L+ applications may be built using Repo-3D with little more difficulty +L+ than building applications in a single process.
No matter how simple the construction of a distributed applica- +L+ tion may be, a number of differences between distributed and +L+ monolithic applications must be addressed. These include:
•	Distributed control. In a monolithic application, a single com- +L+ ponent can oversee the application and coordinate activities +L+ among the separate components by notifying them of changes +L+ to the application state. This is not possible in a non-trivial dis- +L+ tributed application. Therefore, we must provide mechanisms +L+ for different components to be notified of changes to the +L+ distributed state.
•	Interactivity. Updates to distributed state will be slower than +L+ updates to local state, and the amount of data that can be +L+ distributed is limited by network bandwidth. If we do not want +L+ to sacrifice interactive speed, we must be able to perform some +L+ operations locally. For example, an object could be dragged +L+ locally with the mouse, with only a subset of the changes +L+ applied to the replicated state.
•	Local variations. There are times when a shared graphical +L+ scene may need to be modified locally. For example, a +L+ programmer may want to highlight the object under one user’s +L+ mouse pointer without affecting the scene graph viewed by +L+ other users.
Repo-3D addresses these problems in two ways. First, a +L+ programmer can associate a notification object with any replicated +L+ object. The notification object’s methods will be invoked when the +L+ replicated object is updated. This allows reactive programs to be +L+ built in a straightforward manner. To deal with the second and third +L+ problems, we introduce the notion of local variations to graphical +L+ objects. That is, we allow the properties of a graphical object to be +L+ modified locally, and parts of the scene graph to be locally added, +L+ removed, or replaced.
In Section 2 we describe how we arrived at the solution presented +L+ here. Section 3 discusses related work, and Section 4 offers a +L+ detailed description of the underlying infrastructure that was used. +L+ The design of Repo-3D is presented in Section 5, followed by +L+ some examples and concluding remarks in Sections 6 and 7.
2 BACKGROUND
Repo-3D was created as part of a project to support rapid prototyp- +L+ ing of distributed, interactive 3D graphical applications, with a +L+ particular focus on DVEs. Our fundamental belief is that by +L+ providing uniform high-level support for distributed programming +L+ in the languages and toolkits we use, prototyping and experiment- +L+ ing with distributed interactive applications can be (almost) as +L+ simple as multi-threaded programming in a single process. While +L+ care must be taken to deal with network delays and bandwidth +L+ limitations at some stage of the program design (the languages and +L+ toolkits ought to facilitate this), it should be possible to ignore such +L+ issues until they become a problem. Our view can be summarized +L+ by a quote attributed to Alan Kay, “Simple things should be +L+ simple; complex things should be possible.”
This is especially true during the exploration and prototyping +L+ phase of application programming. If programmers are forced to +L+ expend significant effort building the data-distribution components +L+ of the application at an early stage, not only will less time be spent +L+ exploring different prototypes, but radical changes in direction will +L+ become difficult, and thus unlikely. For example, the implementa- +L+ tion effort could cause programs to get locked into using a commu- +L+ nication scheme that may eventually prove less than ideal, or even +L+ detrimental, to the program’s final design.
Since we are using object-oriented languages, we also believe +L+ that data distribution should be tightly integrated with the +L+ language’s general-purpose objects. This lets the language’s type +L+ system and programming constructs reduce or eliminate errors in +L+ the use of the data-distribution system. Language-level integration +L+ also allows the system to exhibit a high degree of network data +L+ transparency, or the ability for the programmer to use remote and +L+ local data in a uniform manner. Without pervasive, structured, +L+ high-level data-distribution support integrated into our program- +L+ ming languages and libraries, there are applications that will never +L+ be built or explored, either because there is too much programming +L+ overhead to justify trying simple things (“simple things are not +L+ simple”), or because the added complexity of using relatively +L+ primitive tools causes the application to become intractable (“com- +L+ plex things are not possible”).
Of the tools available for integrating distributed objects into +L+ programming languages, client-server data sharing is by far the +L+ most common approach, as exemplified by CORBA [26], +L+ Modula-3 Network Objects [5], and Java RMI [39]. Unfortunately, +L+ interactive graphical applications, such as virtual reality, require +L+ that the data used to refresh the display be local to the process +L+ doing the rendering or acceptable frame refresh rates will not be +L+ achieved. Therefore, pure client-server approaches are inappropri- +L+ ate because at least some of the shared data must be replicated. +L+ Furthermore, since the time delay of synchronous remote method +L+ calls is unsuitable for rapidly changing graphical applications, +L+ shared data should be updated asynchronously. Finally, when data +L+ is replicated, local access must still be fast.
The most widely used protocols for replicated data consistency, +L+ and thus many of the toolkits (e.g., ISIS [4] and Visual-Obliq [3]), +L+ allow data updates to proceed unimpeded, but block threads read- +L+ ing local data until necessary updates arrive. The same reason we +L+ need replicated data in the first place—fast local read access to the +L+ data—makes these protocols unsuitable for direct replication of the +L+ graphical data. Of course, these protocols are fine for replicating +L+ application state that will then be synchronized with a parallel +L+ graphical scene description, but that is what we are explicitly try- +L+ ing to avoid. Fortunately, there are replicated data systems (e.g., +L+ Orca [2] or COTERIE [24]) that provide replicated objects that are +L+ well suited to interactive applications, and it is upon the second of +L+ these systems that Repo-3D is built.
3 RELATED WORK
There has been a significant amount of work that falls under the +L+ first, older definition of distributed graphics. A large number of +L+ systems, ranging from established commercial products (e.g., IBM +L+ Visualization Data Explorer [21]) to research systems (e.g., +L+ PARADISE [19] and ATLAS [14]), have been created to distribute +L+ interactive graphical applications over a set of machines. However, +L+ the goal of these systems is to facilitate sharing of application data +L+ between processes, with one process doing the rendering. While +L+ some of these systems can be used to display graphics on more +L+ than one display, they were not designed to support high-level +L+ sharing of graphical scenes.
Most high-level graphics libraries, such as UGA [40], Inventor +L+ [35] and Java 3D [33], do not provide any support for distribution. +L+ Others, such as Performer [29], provide support for distributing +L+ components of the 3D graphics rendering system across multiple +L+ processors, but do not support distribution across multiple +L+ machines. One notable exception is TBAG [13], a high-level +L+ constraint-based, declarative 3D graphics framework. Scenes in +L+ TBAG are defined using constrained relationships between time- +L+ varying functions. TBAG allows a set of processes to share a +L+ single, replicated constraint graph. When any process asserts or +L+ retracts a constraint, it is asserted or retracted in all processes. +L+ However, this means that all processes share the same scene, and +L+ that the system’s scalability is limited because all processes have a +L+ copy of (and must evaluate) all constraints, whether or not they are +L+ interested in them. There is also no support for local variations of +L+ the scene in different processes.
Machiraju [22] investigated an approach similar in flavor to ours, +L+ but it was not aimed at the same fine-grained level of interactivity +L+ and was ultimately limited by the constraints of the implementa- +L+ tion platform (CORBA and C++). For example, CORBA objects +L+ are heavyweight and do not support replication, so much of their +L+ effort was spent developing techniques to support object migration +L+ and “fine-grained” object sharing. However, their fine-grained +L+ objects are coarser than ours, and, more importantly, they do not +L+ support the kind of lightweight, transparent replication we desire. +L+ A programmer must explicitly choose whether to replicate, move, +L+ or copy an object between processes when the action is to occur (as +L+ opposed to at object creation time). Replicated objects are indepen- +L+ dent new copies that can be modified and used to replace the origi- +L+ nal—simultaneous editing of objects, or real-time distribution of +L+ changes as they are made is not supported.
Of greater significance is the growing interest for this sort of sys- +L+ tem in the Java and VRML communities. Java, like Modula-3, is +L+ much more suitable as an implementation language than C or C++ +L+ because of its cross-platform compatibility and support for threads +L+ and garbage collection: Without the latter two language features, +L+ implementing complex, large-scale distributed applications is +L+ extremely difficult. Most of the current effort has been focused on +L+ using Java as a mechanism to facilitate multi-user VRML worlds +L+ (e.g., Open Communities [38]). Unfortunately, these efforts +L+ concentrate on the particulars of implementing shared virtual +L+ environments and fall short of providing a general-purpose shared +L+ graphics library. For example, the Open Communities work is +L+ being done on top of SPLINE [1], which supports only a single +L+ top-level world in the local scene database.
Most DVEs [11, 12, 16, 31, 32] provide support for creating +L+ shared virtual environments, not general purpose interactive 3D +L+ graphics applications. They implement a higher level of abstrac- +L+ tion, providing support for rooms, objects, avatars, collision detec- +L+ tion, and other things needed in single, shared, immersive virtual +L+ environments. These systems provide neither general-purpose +L+ programming facilities nor the ability to work with 3D scenes at a +L+ level provided by libraries such as Obliq-3D or Inventor. Some use +L+ communication schemes that prevent them from scaling beyond a +L+ relatively small number of distributed processes, but for most the +L+ focus is explicitly on efficient communication. SIMNET [7], and +L+ the later NPSNet [41], are perhaps the best known large-scale +L+ distributed virtual-environment systems. They use a fixed, well- +L+ defined communication protocol designed to support a single, +L+ large-scale, shared, military virtual environment.
The techniques for object sharing implemented in recent CSCW +L+ toolkits [28, 30, 34, 37] provide some of the features we need, +L+ particularly automatic replication of data to ease construction of +L+ distributed applications. However, none of these toolkits has +L+ integrated the distribution of data into its programming language’s +L+ object model as tightly as we desire. As a result, they do not pro- +L+ vide a high enough level of network data transparency or suffi- +L+ ciently strong consistency guarantees. In groupware applications, +L+ inconsistencies tend to arise when multiple users attempt to per- +L+ form conflicting actions: the results are usually obvious to the +L+ users and can be corrected using social protocols. This is not an +L+ acceptable solution for a general-purpose, distributed 3D graphics +L+ toolkit. Furthermore, none of these CSCW systems provides any +L+ support for asynchronous update notification, or is designed to +L+ support the kind of large-scale distribution we have in mind.
Finally, while distributed games, such as Quake, have become +L+ very popular, they only distribute the minimum amount of applica- +L+ tion state necessary. They do not use (or provide) an abstract, high- +L+ level distributed 3D graphics system.
Network
Figure 2: The architecture of Repo-3D. Aside from native graphics +L+ libraries (X, Win32, OpenGL, Renderware) the Modula-3 runtime +L+ shields most of the application from the OS. The Replicated Object +L+ package uses an Event communication package and the Network +L+ Object package. DistAnim-3D is implemented on top of a variety of +L+ native graphics libraries and Replicated Objects. Repo exposes most of +L+ the useful Modula-3 packages, as well as using Network Objects and +L+ Replicated Objects to present a distributed shared memory model to +L+ the programmer.
4 UNDERLYING INFRASTRUCTURE
Our work was done in the Modula-3 programming language [18]. +L+ We decided to use Modula-3 because of the language itself and the +L+ availability of a set of packages that provide a solid foundation for +L+ our infrastructure. Modula-3 is a descendant of Pascal that corrects +L+ many of its deficiencies, and heavily influenced the design of Java. +L+ In particular, Modula-3 retains strong type safety, while adding +L+ facilities for exception handling, concurrence object-oriented +L+ programming, and automatic garbage collection . One of its most +L+ important features for our work is that it gives us uniform access to +L+ these facilities across all architectures.
Repo-3D relies on a number of Modula-3 libraries, as illustrated +L+ in Figure 2. Distributed data sharing is provided by two packages, +L+ the Network Object client-server object package [5], and the +L+ Replicated Object shared object package [24] (see Section 4.1). +L+ DistAnim-3D is derived from Anim-3D [25], a powerful, non- +L+ distributed, general-purpose 3D library originally designed for 3D +L+ algorithm animation (see Section 4.2). Finally, Repo itself is a +L+ direct descendant of Obliq [8], and uses the Replicated Object +L+ package to add replicated data to Obliq (see Section 4.3).
4.1 Distributed Shared Memory
Repo-3D’s data sharing mechanism is based on the Shared Data- +L+ Object Model of Distributed Shared Memory (DSM) [20]. DSM +L+ allows a network of computers to be programmed much like a mul- +L+ tiprocessor, since the programmer is presented with the familiar +L+ paradigm of a common shared memory. The Shared Data-Object +L+ Model of DSM is particularly well suited to our needs since it is a +L+ high-level approach that can be implemented efficiently at the +L+ application level. In this model, shared data is encapsulated in +L+ user-defined objects and can only be accessed through those +L+ objects’ method calls. The DSM address space is partitioned +L+ implicitly by the application programmer, with an object being the +L+ smallest unit of sharing. All shared data is fully network transpar-
2. The Modula-3 compiler we used is available from Critical Mass, Inc. as +L+ part of the Reactor programming environment. The compiler, and thus +L+ our system, runs on all the operating systems we have available (plus +L+ others): Solaris, IRIX, HP-UX, Linux, and Windows NT and 95.
Repo-3D
Modula-3 Runtime
Operating System Services
Repo
Network Objects
Replicated Objects
Events
DistAnim-3D
Native +L+ Graphics
ent because it is encapsulated within the programming language +L+ objects.
Distribution of new objects between the processes is as simple as +L+ passing them back and forth as parameters to, or return values +L+ from, method calls—the underlying systems take care of the rest.3 +L+ Objects are only distributed to new processes as necessary, and (in +L+ our system) are removed by the garbage collector when they are no +L+ longer referenced. Furthermore, distributed garbage collection is +L+ supported, so objects that are no longer referenced in any process +L+ are removed completely.
There are three kinds of distributed object semantics in our DSM:
•	Simple objects correspond to normal data objects, and have no +L+ special distributed semantics. When a simple object is copied +L+ between processes, a new copy is created in the destination +L+ process that has no implied relationship to the object in the +L+ source process.
•	Remote objects have client-server distribution semantics. When +L+ a remote object is copied between processes, all processes +L+ except the one in which the object was created end up with a +L+ proxy object that forwards method invocations across the +L+ network to the original object.
•	Replicated objects have replicated distribution semantics. +L+ When a replicated object is passed between processes, a new +L+ replica is created in the destination process. If any replica is +L+ changed, the change is reflected in all replicas.
The Network Object package provides support for remote +L+ objects. It implements distributed garbage collection, exception +L+ propagation back to the calling site, and automatic marshalling and +L+ unmarshalling of method arguments and return values of virtually +L+ any data type between heterogeneous machine architectures. The +L+ package is similar to other remote method invocation (RMI) pack- +L+ ages developed later, such as the Java RMI library [39]. All method +L+ invocations are forwarded to the original object, where they are +L+ executed in the order they are received.
The Replicated Object package supports replicated objects. Each +L+ process can call any method of an object it shares, just as it can +L+ with a simple or remote object. We will describe the Replicated +L+ Object package in more detail, as Repo-3D relies heavily on its +L+ design, and the design of a replicated object system is less straight- +L+ forward than a remote one. The model supported by the Replicated +L+ Object package follows two principles:
•	All operations on an instance of an object are atomic and +L+ serializable. All operations are performed in the same order on +L+ all copies of the object. If two methods are invoked simulta- +L+ neously, the order of invocation is nondeterministic, just as if +L+ two threads attempted to access the same memory location +L+ simultaneously in a single process.
•	The above principle applies to operations on single objects. +L+ Making sequences of operations atomic is up to the program- +L+ mer.
The implementation of the Replicated Object package is based +L+ on the approach used in the Orca distributed programming +L+ language [2]. A full replication scheme is used, where a single +L+ object is either fully replicated in a process or not present at all. +L+ Avoiding partial replication significantly simplifies the implemen- +L+ tation and the object model, and satisfies the primary rationale for +L+ replication: fast read-access to shared data. To maintain replication +L+ consistency an update scheme is used, where updates to the object +L+ are applied to all copies.
3. An important detail is how the communication is bootstrapped. In the +L+ case of the Network and Replicated Object packages, to pass a first +L+ object between processes, one of them exports the object to a special +L+ network object demon under some known name on some known +L+ machine. The second process then retrieves the object.
The method of deciding what is and is not an update is what +L+ makes the Orca approach particularly interesting and easy to +L+ implement. All methods are marked as either read or update meth- +L+ ods by the programmer who creates the object type. Read methods +L+ are assumed to not change the state of the object and are therefore +L+ applied immediately to the local object without violating consis- +L+ tency. Update methods are assumed to change the state. To distrib- +L+ ute updates, arguments to the update method are marshalled into a +L+ message and sent to all replicas. To ensure all updates are applied +L+ in the same order, the current implementation of the Replicated +L+ Object package designates a sequencer process for each object. +L+ There may be more than one sequencer in the system to avoid +L+ overloading one process with all the objects (in this case, each +L+ object has its updates managed by exactly one of the sequencers.) +L+ The sequencer is responsible for assigning a sequence number to +L+ each message before it is sent to all object replicas. The replicas +L+ then execute the incoming update messages in sequence. The pro- +L+ cess that initiated the update does not execute the update until it +L+ receives a message back from the sequencer and all updates with +L+ earlier sequence numbers have been executed.
There are three very important reasons for choosing this +L+ approach. First, it is easy to implement on top of virtually any +L+ object-oriented language, using automatically generated object +L+ subtypes and method wrappers that communicate with a simple +L+ runtime system. We do this in our Modula-3 implementation, and it +L+ would be equally applicable to an implementation in C++ or Java. +L+ For example, the JSDT [36] data-sharing package in Java uses a +L+ similar approach.
Second, the Replicated Object package does not pay attention to +L+ (or even care) when the internal data fields of an object change. +L+ This allows the programmer great flexibility in deciding exactly +L+ what constitutes an update or not, and what constitutes the shared +L+ state 4. For example, objects could have a combination of global +L+ and local state, and the methods that change the local state could +L+ be classified as read methods since they do not modify the global +L+ state. Alternatively, read methods could do some work locally and +L+ then call an update method to propagate the results, allowing time- +L+ consuming computation to be done once and the result distributed +L+ in a clean way. We took advantage of both of these techniques in +L+ implementing Repo-3D.
Finally, the immediate distribution of update methods ensures +L+ that changes are distributed in a timely fashion, and suggests a +L+ straightforward solution to the asynchronous notification problem. +L+ The Replicated Object package generates a Notification Object +L+ type for each Replicated Object type. These new objects have +L+ methods corresponding to the update methods of their associated +L+ Replicated Object. The arguments to these methods are the same as +L+ the corresponding Replicated Object methods, plus an extra +L+ argument to hold the Replicated Object instance. These notifiers +L+ can be used by a programmer to receive notification of changes to +L+ a Replicated Object in a structured fashion. To react to updates to a +L+ Replicated Object instance, a programmer simply overrides the +L+ methods of the corresponding Notification Object with methods +L+ that react appropriately to those updates, and associates an instance
4. Of course, it falls squarely on the shoulders of the programmer to +L+ ensure that the methods provided always leave the object in a consistent +L+ state. This is not significantly different than what needs to be done +L+ when building a complex object that is simultaneously accessed by +L+ multiple threads in a non-distributed system. For example, if a +L+ programmer reads an array of numbers from inside the object and then +L+ uses an update method to write a computed average back into the +L+ object, the internal array may have changed before the average is +L+ written, resulting in a classic inconsistency problem. In general, +L+ methods that perform computations based on internal state (rather than +L+ on the method arguments) are potentially problematic and need to be +L+ considered carefully.
RootGO +L+ ChoiceGroupGO
OrthoCameraGO +L+ PerspCameraGO
AmbientLightGO +L+ VectorLightGO +L+ PointLightGO
SpotLightGO
GO
IndexedLineSetGO
NonSurfaceGO
Text2DGO
PolygonGO
BoxGO
SphereGO
CylinderGO
DiskGO
TorusGO
QuadMeshGO
IndexedPolygonSetGO
Figure 3: The Repo-3D GO class hierarchy. Most of the classes are +L+ also in Obliq-3D; the italicized ones were added to Repo-3D.
Figure 4: The relationship between properties, names, values, and +L+ behaviors. Each oval represents an object and arrows show contain- +L+ ment.
of it with the Replicated Object instance. Each time an update +L+ method of the Replicated Object is invoked, the corresponding +L+ method of the Notifier Object is also invoked. Notification Objects +L+ eliminate the need for object polling and enable a “data-driven” +L+ flow of control.
4.2 Obliq-3D
Obliq-3D is composed of Anim-3D, a 3D animation package +L+ written in Modula-3, and a set of wrappers that expose Anim-3D to +L+ the Obliq programming language (see Section 4.3). Anim-3D is +L+ based on three simple and powerful concepts: graphical objects for +L+ building graphical scenes, properties for specifying the behavior of +L+ the graphical objects, and input event callbacks to support interac- +L+ tive behavior. Anim-3D uses the damage-repair model: whenever a +L+ graphical object or property changes (is damaged), the image is +L+ repaired without programmer intervention.
Graphical objects (GOs) represent all the logical entities in the +L+ graphical scene: geometry (e.g., lines, polygons, spheres, polygon +L+ sets, and text), lights and cameras of various sorts, and groups of +L+ other GOs. One special type of group, the RootGO, represents a +L+ window into which graphics are rendered. GOs can be grouped +L+ together in any valid directed acyclic graph (DAG). The GO class
hierarchy is shown in Figure 3.
A property is a defined by a name and a value. The name deter- +L+ mines which attribute is affected by the property, such as “Texture +L+ Mode” or “Box Corner1”. The value specifies how it is affected +L+ and is determined by its behavior, a time-variant function that +L+ takes the current animation time and returns a value. Properties, +L+ property values, and behaviors are all objects, and their relation- +L+ ships are shown in Figure 4. When a property is created, its name +L+ and value are fixed. However, values are mutable and their behav- +L+ ior may be changed at any time. There are four kinds of behaviors +L+ for each type of properties: constant (do not vary over time), +L+ synchronous (follow a programmed set of requests, such as “move +L+ from A to B starting at time t=1 and taking 2 seconds”), asynchro- +L+ nous (execute an arbitrary time-dependent function to compute the +L+ value) and dependent (asynchronous properties that depend on +L+ other properties). Synchronous properties are linked to animation +L+ handles and do not start satisfying their requests until the anima- +L+ tion handle is signalled. By linking multiple properties to the same +L+ handle, a set of property value changes can be synchronized.
Associated with each GO g is a partial mapping of property +L+ names to values determined by the properties that have been asso- +L+ ciated with g. A property associated with g affects not only g but +L+ all the descendants of g that do not override the property. A single +L+ property may be associated with any number of GOs. It is perfectly +L+ legal to associate a property with a GO that is not affected by it; for +L+ example, attaching a “Surface Color” property to a GroupGO does +L+ not affect the group node itself, but could potentially affect the +L+ surface color of any GO contained in that group. A RootGO sets an +L+ initial default value for each named property.
There are three types of input event callbacks in Anim-3D, corre- +L+ sponding to the three kinds of interactive events they handle: +L+ mouse callbacks (triggered by mouse button events), motion call- +L+ backs (triggered by mouse motion events) and keyboard callbacks +L+ (triggered by key press events). Each object has three callback +L+ stacks, and the interactive behavior of an object can be redefined +L+ by pushing a new callback onto the appropriate stack. Any event +L+ that occurs within a root window associated with a RootGO r will +L+ be delivered to the top handler on r’s callback stack. The handler +L+ could delegate the event to one of r’s children, or it may handle it +L+ itself, perhaps changing the graphical scene in some way.
DistAnim-3D is a direct descendant of Anim-3D. In addition to +L+ the objects being distributed, it has many additional facilities that +L+ are needed for general-purpose 3D graphical applications, such as +L+ texture mapping, indexed line and polygon sets, choice groups, +L+ projection and transformation callbacks, and picking. Since +L+ DistAnim-3D is embedded in Repo instead of Obliq (see +L+ Section 4.3), the resulting library is called Repo-3D.
4.3 Obliq and Repo
Obliq [8] is a lexically-scoped, untyped, interpreted language for +L+ distributed object-oriented computation. It is implemented in, and +L+ tightly integrated with, Modula-3. An Obliq computation may +L+ involve multiple threads of control within an address space, multi- +L+ ple address spaces on a machine, heterogeneous machines over a +L+ local network, and multiple networks over the Internet. Obliq uses, +L+ and supports, the Modula-3 thread, exception, and garbage-collec- +L+ tion facilities. Its distributed-computation mechanism is based on +L+ Network Objects, allowing transparent support for multiple +L+ processes on heterogeneous machines. Objects are local to a site, +L+ while computations can roam over the network. Repo [23] is a +L+ descendant of Obliq that extends the Obliq object model to include +L+ replicated objects. Therefore, Repo objects have state that may be +L+ local to a site (as in Obliq) or replicated across multiple sites.
5 DESIGN OF REPO-3D
Repo-3D’s design has two logical parts: the basic design and local +L+ variations. The basic design encompasses the changes to Obliq-3D +L+ to carry it into a distributed context, and additional enhancements +L+ that are not particular to distributed graphics (and are therefore not +L+ discussed here). Local variations are introduced to handle two +L+ issues mentioned in Section 1: transient local changes and respon- +L+ sive local editing.
. . .
Name
Property
Value	Behavior
Request
Request
GroupGO			
			
CameraGO			
LightGO			
			
	
SurfaceGO	
	
	
LineGO 	
MarkerGO +L+ TextGO 	
5.1 Basic Repo-3D Design
The Anim-3D scene-graph model is well suited for adaptation to a +L+ distributed environment. First, in Anim-3D, properties are attached +L+ to nodes, not inserted into the graph, and the property and child +L+ lists are unordered (i.e., the order in which properties are assigned +L+ to a node, or children are added to a group, does not affect the final +L+ result). In libraries that insert properties and nodes in the graph and +L+ execute the graph in a well-defined order (such as Inventor), the +L+ siblings of a node (or subtree) can affect the attributes of that node +L+ (or subtree). In Anim-3D, and similar libraries (such as Java 3D), +L+ properties are only inherited down the graph, so a node’s properties +L+ are a function of the node itself and its ancestors—its siblings do +L+ not affect it. Therefore, subtrees can be added to different scene +L+ graphs, perhaps in different processes, with predictable results. +L+ Second, the interface (both compiled Anim-3D and interpreted +L+ Obliq-3D) is programmatical and declarative. There is no “graphi- +L+ cal scene” file format per se: graphical scenes are created as the +L+ side effect of executing programs that explicitly create objects and +L+ manipulate them via the object methods. Thus, all graphical +L+ objects are stored as the Repo-3D programs that are executed to +L+ create them. This is significant, because by using the Replicated +L+ Object library described in Section 4.1 to make the graphical +L+ objects distributed, the “file format” (i.e., a Repo-3D program) is +L+ updated for free.
Converting Anim-3D objects to Replicated Objects involved +L+ three choices: what objects to replicate, what methods update the +L+ object state, and what the global, replicated state of each object is. +L+ Since replicated objects have more overhead (e.g., method execu- +L+ tion time, memory usage, and latency when passed between +L+ processes), not every category of object in Repo-3D is replicated. +L+ We will consider each of the object categories described in +L+ Figure 4.2 in turn: graphical objects (GOs), properties (values, +L+ names, behaviors, animation handles) and callbacks. For each of +L+ these objects, the obvious methods are designated as update meth- +L+ ods, and, as discussed in Section 4. 1, the global state of each object +L+ is implicitly determined by those update methods. Therefore, we +L+ will not go into excessive detail about either the methods or the +L+ state. Finally, Repo-3D’s support for change notification will be +L+ discussed.
5.1.1 Graphical Objects
GOs are the most straightforward. There are currently twenty-one +L+ different types of GOs, and all but the RootGOs are replicated. +L+ Since RootGOs are associated with an onscreen window, they are +L+ not replicated—window creation remains an active decision of the +L+ local process. Furthermore, if replicated windows are needed, the +L+ general-purpose programming facilities of Repo can be used to +L+ support this in a relatively straightforward manner, outside the +L+ scope of Repo-3D. A GO’s state is comprised of the properties +L+ attached to the object, its name, and some other non-inherited +L+ property attributes.5 The methods that modify the property list are +L+ update methods. Group GOs also contain a set of child nodes, and +L+ have update methods that modify that set.
5.1.2 Properties
Properties are more complex. There are far more properties in a +L+ graphical scene than there are graphical objects, they change much +L+ more rapidly, and each property is constructed from a set of +L+ Modula-3 objects. There are currently 101 different properties of
5. Some attributes of a GO, such as the arrays of Point3D properties that +L+ define the vertices of a polygon set, are not attached to the object, but +L+ are manipulated through method calls.
seventeen different types in Repo-3D, and any of them can be +L+ attached to any GO. A typical GO would have anywhere from two +L+ or three (e.g., a BoxGO would have at least two properties to +L+ define its corners) to a dozen or more. And, each of these proper- +L+ ties could be complex: in the example in Section 6, a single +L+ synchronous property for a long animation could have hundreds of +L+ requests enqueued within it.
Consider again the object structure illustrated in Figure 4. A +L+ property is defined by a name and a value, with the value being a +L+ container for a behavior. Only one of the Modula-3 objects is +L+ replicated, the property value. Property values serve as the repli- +L+ cated containers for property behaviors. To change a property, a +L+ new behavior is assigned to its value. The state of the value is the +L+ current behavior.
Animation handles are also replicated. They tie groups of related +L+ synchronous properties together, and are the basis for the interac- +L+ tion in the example in Section 6. In Anim-3D, handles have one +L+ animate method, which starts an animation and blocks until it +L+ finishes. Since update methods are executed everywhere, and block +L+ access to the object while they are being executed, they should not +L+ take an extended period of time. In creating Repo-3D, the +L+ animate method was changed to call two new methods: an update +L+ method that starts the animation, and a non-update method that +L+ waits for the animation to finish. We also added methods to pause +L+ and resume an animation, to retrieve and change the current rela- +L+ tive time of an animation handle, and to stop an animation early. +L+ The state of an Animation handle is a boolean value that says if it is +L+ active or not, plus the start, end, and current time (if the handle is +L+ paused).
Most of the Modula-3 objects that comprise a property are not +L+ replicated, for a variety of reasons:
•	Properties represent a permanent binding between a property +L+ value and a name. Since they are immutable, they have no syn- +L+ chronization requirements and can simply be copied between +L+ processes.
•	Names represent simple constant identifiers, and are therefore +L+ not replicated either.
•	Behaviors and requests are not replicated. While they can be +L+ modified after being created, they are treated as immutable +L+ data types for two reasons. First, the vast majority of behaviors, +L+ even complex synchronous ones, are not changed once they +L+ have been created and initialized. Thus, there is some justifica- +L+ tion for classifying the method calls that modify them as part +L+ of their initialization process. The second reason is practical +L+ and much more significant. Once a scene has been created and +L+ is being “used” by the application, the bulk of the time-critical +L+ changes to it tend to be assignments of new behaviors to the +L+ existing property values. For example, an object is moved by +L+ assigning a new (often constant) behavior to its +L+ GO _T rans fo rm property value. Therefore, the overall perfor- +L+ mance of the system depends heavily on the performance of +L+ property value behavior changes. By treating behaviors as +L+ immutable objects, they can simply be copied between +L+ processes without incurring the overhead of the replicated +L+ object system.
5.1.3 Input Callbacks
In Repo-3D, input event callbacks are not replicated. As discussed +L+ in Section 4.2, input events are delivered to the callback stacks of a +L+ RootGO. Callbacks attached to any other object receive input +L+ events only if they are delivered to that object by the programmer, +L+ perhaps recursively from another input event callback (such as the +L+ one attached to the RootGO). Therefore, the interactive behavior of +L+ a root window is defined not only by the callbacks attached to its +L+ RootGO, but also by the set of callbacks associated with the graph +L+ rooted at that RootGO. Since the RootGOs are not replicated, the
(a)	(b)
(c) (d)
Figure 5: Simultaneous images from a session with the distributed CATHI animation viewer, running on four machines, showing an anima- +L+ tion of an engine. (a) Plain animation viewer, running on Windows NT. (b) Overview window, running on Windows 95. (c) Animation viewer +L+ with local animation meter, running on IRIX. (d) Animation viewer with local transparency to expose hidden parts, running on Solaris.
callbacks that they delegate event handling to are not replicated +L+ either. If a programmer wants to associate callbacks with objects as +L+ they travel between processes, Repo’s general-purpose program- +L+ ming facilities can be used to accomplish this in a straightforward +L+ manner.
5.1.4 Change Notification
The final component of the basic design is support for notification +L+ of changes to distributed objects. For example, when an object’s +L+ position changes or a new child is added to a group, some of the +L+ processes containing replicas may wish to react in some way. For- +L+ tunately, as discussed in Section 4.1, the Replicated Object +L+ package automatically generates Notification Object types for all +L+ replicated object types, which provide exactly the required +L+ behavior. The Notification Objects for property values allow a +L+ programmer to be notified of changes to the behavior of a property,
and the Notification Objects for the various GOs likewise allow +L+ notification of updates to them.
5.2 Local Variations
Repo-3D’s local variations solve a set of problems particular to the +L+ distributed context in which Repo-3D lives: maintaining interactiv- +L+ ity and supporting local modifications to the shared scene graph. +L+ If the graphical objects and their properties were always strictly +L+ replicated, programmers would have to create local variations by +L+ copying the objects to be modified, creating a set of Notification +L+ Objects on the original objects, the copies of those objects, and all +L+ their properties (to be notified when either change), and reflecting +L+ the appropriate changes between the instances. Unfortunately, +L+ while this process could be automated somewhat, it would still be +L+ extremely tedious and error prone. More seriously, the overhead of +L+ creating this vast array of objects and links between them would
make this approach impractical for short transient changes, such as +L+ highlighting an object under the mouse.
To overcome this problem, Repo-3D allows the two major +L+ elements of the shared state of the graphical object scene—the +L+ properties attached to a GO and the children of a group—to have +L+ local variations applied to them. (Local variations on property +L+ values or animation handles are not supported, although we are +L+ considering adding support for the latter.)
Conceptually, local state is the state added to each object (the +L+ additions, deletions, and replacements to the properties or +L+ children) that is only accessible to the local copies and is not +L+ passed to remote processes when the object is copied to create a +L+ new replica. The existence of local state is possible because, as +L+ discussed in Section 4. 1, the shared state of a replicated object is +L+ implicitly defined by the methods that update it 6. Therefore, the +L+ new methods that manipulate the local variations are added to the +L+ GOs as non-update methods. Repo-3D combines both the global +L+ and local state when creating the graphical scene using the under- +L+ lying graphics package.
As mentioned above, local variations come in two flavors:
•	Property variations. There are three methods to set, unset, and +L+ get the global property list attached to a GO. We added the +L+ following methods to manipulate local variations: add or +L+ remove local properties (overriding the value normally used for +L+ the object), hide or reveal properties (causing the property +L+ value of the parent node to be inherited), and flush the set of +L+ local variations (removing them in one step) or atomically +L+ apply them to the global state of the object.
•	Child variations. There are five methods to add, remove, +L+ replace, retrieve, and flush the set of children contained in a +L+ group node. We added the following ones: add a local node, +L+ remove a global node locally, replace a global node with some +L+ other node locally, remove each of these local variations, flush +L+ the local variations (remove them all in one step), and atomi- +L+ cally apply the local variations to the global state.
This set of local operations supports the problems local variations +L+ were designed to solve, although some possible enhancements are +L+ discussed in Section 7.
6 EXAMPLE: AN ANIMATION EXAMINER
As an example of the ease of prototyping distributed applications +L+ with Repo-3D, we created a distributed animation examiner for the +L+ CATHI [6] animation generation system. CATHI generates short +L+ informational animation clips to explain the operation of technical +L+ devices. It generates full-featured animation scripts, including +L+ camera and object motion, color and opacity effects, and lighting +L+ setup.
It was reasonably straightforward to modify CATHI to generate +L+ Repo-3D program files, in addition to the GeomView and Render- +L+ Man script files it already generated. The resulting output is a +L+ Repo-3D program that creates two scene DAGs: a camera graph +L+ and a scene graph. The objects in these DAGs have synchronous +L+ behaviors specified for their surface and transformation properties. +L+ An entire animation is enqueued in the requests of these behaviors, +L+ lasting anywhere from a few seconds to a few minutes.
We built a distributed, multi-user examiner over the course of a +L+ weekend. The examiner allows multiple users to view the same +L+ animation while discussing it (e.g., via electronic chat or on the +L+ phone). Figure 5 shows images of the examiner running on four
6. The local state is not copied when a replicated object is first passed to a +L+ new process because the Repo-3D objects have custom serialization +L+ routines (or Picklers, in Modula-3 parlance). These routines only pass +L+ the global state, and initialize the local state on the receiving side to +L+ reasonable default values corresponding to the empty local state.
machines, each with a different view of the scene. The first step +L+ was to build a simple “loader” that reads the animation file, creates +L+ a window, adds the animation scene and camera to it, and exports +L+ the animation on the network, requiring less than a dozen lines of +L+ Repo-3D code. A “network” version, that imports the animation +L+ from the network instead of reading it from disk, replaced the lines +L+ of code to read and export the animation with a single line to +L+ import it. Figure 5(a) shows an animation being viewed by one of +L+ these clients.
The examiner program is loaded by both these simple clients, and +L+ is about 450 lines long. The examiner supports:
•	Pausing and continuing the animation, and changing the +L+ current animation time using the mouse. Since this is done by +L+ operating on the shared animation handle, changes performed +L+ by any viewer are seen by all. Because of the consistency guar- +L+ antees, all users can freely attempt to change the time, and the +L+ system will maintain all views consistently.
•	A second “overview” window (Figure 5(b)), where a new +L+ camera watches the animation scene and camera from a distant +L+ view. A local graphical child (representing a portion of the +L+ animation camera’s frustum) was added to the shared anima- +L+ tion camera group to let the attributes of the animation camera +L+ be seen in the overview window.
•	A local animation meter (bottom of Figure 5(c)), that can be +L+ added to any window by pressing a key, and which shows the +L+ current time offset into the animation both graphically and +L+ numerically. It was added in front of the camera in the anima- +L+ tion viewer window, as a local child of a GO in the camera +L+ graph, so that it would be fixed to the screen in the animation +L+ viewer.
•	Local editing (Figure 5(d)), so that users can select objects and +L+ make them transparent (to better see what was happening in the +L+ animation) or hide them completely (useful on slow machines, +L+ to speed up rendering). Assorted local feedback (highlighting +L+ the object under the mouse and flashing the selected object) +L+ was done with local property changes to the shared GOs in the +L+ scene graph.
Given the attention paid to the design of Repo-3D, it was not +L+ necessary to be overly concerned with the distributed behavior of +L+ the application (we spent no more than an hour or so). Most of that +L+ time was spent deciding if a given operation should be global or a +L+ local variation. The bulk of programming and debugging time was +L+ spent implementing application code. For example, in the overview +L+ window, the representation of the camera moves dynamically, +L+ based on the bounding values of the animation’s scene and camera +L+ graphs. In editing mode, the property that flashes the selected node +L+ bases its local color on the current global color (allowing a user +L+ who is editing while an animation is in progress to see any color +L+ changes to the selected node.)
7 CONCLUSIONS AND FUTURE WORK
We have presented the rationale for, and design of, Repo-3D, a +L+ general-purpose, object-oriented library for developing distributed, +L+ interactive 3D graphics applications across a range of heteroge- +L+ neous workstations. By presenting the programmer with the +L+ illusion of a large shared memory, using the Shared Data-Object +L+ model of DSM, Repo-3D makes it easy for programmers to rapidly +L+ prototype distributed 3D graphics applications using a familiar +L+ object-oriented programming paradigm. Both graphical and +L+ general-purpose, non-graphical data can be shared, since Repo-3D +L+ is embedded in Repo, a general-purpose, lexically-scoped, distrib- +L+ uted programming language.
Repo-3D is designed to directly support the distribution of graph- +L+ ical objects, circumventing the “duplicate database” problem and +L+ allowing programmers to concentrate on the application function-
ality of a system, rather than its communication or synchronization +L+ components. We have introduced a number of issues that must be +L+ considered when building a distributed 3D graphics library, espe- +L+ cially concerning efficient and clean support for data distribution +L+ and local variations of shared graphical scenes, and discussed how +L+ Repo-3D addresses them.
There are a number of ways in which Repo-3D could be +L+ improved. The most important is the way the library deals with +L+ time. By default, the library assumes all machines are running a +L+ time-synchronization rotocol, such as NTP, and uses an internal +L+ animation time offset�(instead of the system-specific time offset) +L+ because different OSs (e.g., NT vs. UNIX) start counting time at +L+ different dates. Hooks have been provided to allow a programmer +L+ to specify their own function to compute the “current” animation +L+ time offset within a process. Using this facility, it is possible to +L+ build inter-process time synchronization protocols (which we do), +L+ but this approach is not entirely satisfactory given our stated goal +L+ of relieving the programmer of such tedious chores. Future +L+ systems should integrate more advanced solutions, such as adjust- +L+ ing time values as they travel between machines, so that users of +L+ computers with unsynchronized clocks can collaborate8. This will +L+ become more important as mobile computers increase in popular- +L+ ity, as it may not be practical to keep their clocks synchronized. +L+ The specification of local variations in Repo-3D could benefit +L+ from adopting the notion of paths (as used in Java 3D and Inventor, +L+ for example). A path is an array of objects leading from the root of +L+ the graph to an object; when an object occurs in multiple places in +L+ one or more scene graphs, paths allow these instances to be differ- +L+ entiated. By specifying local variations using paths, nodes in the +L+ shared scene graphs could have variations within a process as well +L+ as between processes. One other limitation of Repo-3D, arising +L+ from our use of the Replicated Object package, is that there is no +L+ way to be notified when local variations are applied to an object. +L+ Recall that the methods of an automatically generated Notification +L+ Object correspond to the update methods of the corresponding +L+ Replicated Object. Since the methods that manipulate the local +L+ variations are non-update methods (i.e., they do not modify the +L+ replicated state), there are no corresponding methods for them in +L+ the Notification Objects. Of course, it would be relatively straight- +L+ forward to modify the Replicated Object package to support this, +L+ but we have not yet found a need for these notifiers.
A more advanced replicated object system would also improve +L+ the library. Most importantly, support for different consistency +L+ semantics would be extremely useful. If we could specify +L+ semantics such as “all updates completely define the state of an +L+ object, and only the last update is of interest,” the efficiency of the +L+ distribution of property values would improve significantly; in this +L+ case, updates could be applied (or discarded) when they arrive, +L+ without waiting for all previous updates to be applied, and could be +L+ applied locally without waiting for the round trip to the sequencer. +L+ There are also times when it would be useful to have support for +L+ consistency across multiple objects, either using causal ordering +L+ (as provided by systems such as ISIS and Visual-Obliq), or some +L+ kind of transaction protocol to allow large groups of changes to be +L+ applied either as a unit, or not at all. It is not clear how one would +L+ provide these features with a replicated object system such as the +L+ one used here.
While a library such as Repo-3D could be built using a variety of +L+ underlying platforms, the most likely one for future work is Java. +L+ Java shares many of the advantages of Modula-3 (e.g., threads and +L+ garbage collection are common across all architectures) and the
7. Computed as an offset from January 1, 1997.
8. Implementation details of the combination of Network and Replicated +L+ Objects made it difficult for us to adopt a more advanced solution.
packages needed to create a Repo-3D-like toolkit are beginning to +L+ appear. While Java does not yet have a replicated object system as +L+ powerful as the Replicated Object package, a package such as +L+ JSDT [36] (which focuses more on data communication than high- +L+ level object semantics) may be a good starting point. Work is also +L+ being done on interpreted, distributed programming languages on +L+ top of Java (e.g., Ambit [9]). Finally, Java 3D is very similar to +L+ Anim-3D, even though its design leans toward efficiency instead of +L+ generality when there are trade-offs to be made. For example, the +L+ designers chose to forgo Anim-3D’s general property inheritance +L+ mechanism because it imposes computational overhead. By com- +L+ bining packages such as Java 3D, JSDT, and Ambit, it should be +L+ possible to build a distributed graphics library such as Repo-3D in +L+ Java.
Acknowledgments
We would like to thank the reviewers for their helpful comments, +L+ as well as the many other people who have contributed to this +L+ project. Andreas Butz ported CATHI to use Repo-3D and helped +L+ with the examples and the video. Clifford Beshers participated in +L+ many lively discussions about the gamut of issues dealing with +L+ language-level support for 3D graphics. Tobias Höllerer and +L+ Steven Dossick took part in many other lively discussions. Xinshi +L+ Sha implemented many of the extensions to Obliq-3D that went +L+ into Repo-3D. Luca Cardelli and Marc Najork of DEC SRC +L+ created Obliq and Obliq-3D, and provided ongoing help and +L+ encouragement over the years that Repo and Repo-3D have been +L+ evolving.
This research was funded in part by the Office of Naval Research +L+ under Contract N00014-97-1-0838 and the National Tele-Immer- +L+ sion Initiative, and by gifts of software from Critical Mass and +L+ Microsoft.
References
[1] D. B. Anderson, J. W. Barrus, J. H. Howard, C. Rich, C. Shen, and +L+ R. C. Waters. Building Multi-User Interactive Multimedia Environ- +L+ ments at MERL. Technical Report Research Report TR95-17, Mit- +L+ subishi Electric Research Laboratory, November 1995.
[2] H. Bal, M. Kaashoek, and A. Tanenbaum. Orca: A Language for +L+ Parallel Programming of Distributed Systems. IEEE Transactions on +L+ Software Engineering, 18(3):190–205, March 1992.
[3] K. Bharat and L. Cardelli. Migratory Applications. In ACM UIST &apos;95, +L+ pages 133-142, November 1995.
[4] K. P. Birman. The Process Group Approach to Reliable Distributed +L+ Computing. CACM, 36(12):36–53, Dec 1993.
[5] A. Birrell, G. Nelson, S. Owicki, and E. Wobber. Network Objects. +L+ In Proc. 14th ACM Symp. on Operating Systems Principles, 1993.
[6] A Butz, Animation with CATHI, In Proceedings ofAAAI/IAAI &apos;97, +L+ pages 957–962, 1997.
[7]	J. Calvin, A. Dickens, B. Gaines, P. Metzger, D. Miller, and
D. Owen. The SIMNET Virtual World Architecture. In Proc. IEEE +L+ VRAIS ’93, pages 450–455, Sept 1993.
[8] L. Cardelli. A Language with Distributed Scope. Computing Sys- +L+ tems, 8(1):27–59, Jan 1995.
[9] L. Cardelli and A. Gordon. Mobile Ambients. In Foundations of +L+ Software Science and Computational Structures, Maurice Nivat +L+ (Ed.), LNCE 1378, Springer, 140–155. 1998.
[10] R. Carey and G. Bell. The Annotated VRML 2.0 Reference Manual. +L+ Addison-Wesley, Reading, MA, 1997.
[11] C. Carlsson and O. Hagsand. DIVE—A Multi-User Virtual Reality +L+ System. In Proc. IEEE VRAIS ’93, pages 394–400, Sept 1993.
[12] C. F. Codella, R. Jalili, L. Koved, and J. B. Lewis. A Toolkit for +L+ Developing Multi-User, Distributed Virtual Environments. In Proc. +L+ IEEE VRAIS ’93, pages 401–407, Sept 1993.
[13] C. Elliott, G. Schechter, R. Yeung and S. Abi-Ezzi. TBAG: A High +L+ Level Framework for Interactive, Animated 3D Graphics +L+ Applications, In Proc. ACM SIGGRAPH 94, pages 421–434, August, +L+ 1994.
[14] M. Fairen and A. Vinacua, ATLAS, A Platform for Distributed +L+ Graphics Applications, In Proc. VI Eurographics Workshop on Pro- +L+ gramming Paradigms in Graphics, pages 91–102, September, 1997.
[15] S. Feiner, B. MacIntyre, M. Haupt, and E. Solomon. Windows on the +L+ World: 2D Windows for 3D Augmented Reality. In Proc. ACM UIST +L+ ’93, pages 145–155, 1993.
[16] T. A. Funkhouser. RING: A Client-Server System for Multi-User +L+ Virtual Environments. In Proc. 1995 ACM Symp. on Interactive 3D +L+ Graphics, pages 85–92, March 1995.
[17] G. Grimsdale. dVS—Distributed Virtual Environment System. In +L+ Proc. Computer Graphics ’91 Conference, 1991.
[18] S. P. Harbison. Modula-3. Prentice-Hall, 1992.
[19] H.W. Holbrook, S.K. Singhal and D.R. Cheriton, Log-Based +L+ Receiver-Reliable Multicast for Distributed Interactive Simulation, +L+ Proc. ACM SIGCOMM ’95, pages 328–341, 1995.
[20] W. Levelt, M. Kaashoek, H. Bal, and A. Tanenbaum. A Comparison +L+ of Two Paradigms for Distributed Shared Memory. Software +L+ Practice and Experience, 22(11):985–1010, Nov 1992.
[21] B. Lucas. A Scientific Visualization Renderer. In Proc. IEEE +L+ Visualization &apos;92, pp. 227-233, October 1992.
[22] V. Machiraju, A Framework for Migrating Objects in Distributed +L+ Graphics Applications, Masters Thesis, University of Utah, Depart- +L+ ment of Computer Science, Salt Lake City, UT, June, 1997.
[23] B. MacIntyre. Repo: Obliq with Replicated Objects. Programmers +L+ Guide and Reference Manual. Columbia University Computer +L+ Science Department Research Report CUCS-023-97, 1997.}
[24] B. MacIntyre, and S. Feiner. Language-level Support for Exploratory +L+ Programming of Distributed Virtual Environments. In Proc. ACM +L+ UIST ’96, pages 83–94, Seattle, WA, November 6–8, 1996.
[25] M. A. Najork and M. H. Brown. Obliq-3D: A High-level, Fast-turn- +L+ around 3D Animation System. IEEE Transactions on Visualization +L+ and Computer Graphics, 1(2):175–145, June 1995.
[26] R. Ben-Natan. CORBA: A Guide to the Common Object Request +L+ Broker Architecture, McGraw Hill, 1995.
[27] D. Phillips, M. Pique, C. Moler, J. Torborg, D. Greenberg. Distribut- +L+ ed Graphics: Where to Draw the Lines? Panel Transcript, +L+ SIGGRAPH 89, available at:
http://www.siggraph.org:443/publications/panels/siggraphi89/ +L+ [28] A. Prakash and H. S. Shim. DistView: Support for Building Efficient +L+ Collaborative Applications Using Replicated Objects. In Proc. ACM +L+ CSCW ’94, pages 153–162, October 1994.
[29] J. Rohlf and J. Helman, IRIS Performer: A High Performance +L+ Multiprocessing Toolkit for Real-Time {3D} Graphics, In Proc. +L+ ACM SIGGRAPH 94, pages 381–394, 1994.
[30] M. Roseman and S. Greenberg. Building Real-Time Groupware with +L+ GroupKit, a Groupware Toolkit. ACM Transactions on Computer- +L+ Human Interaction, 3(1):66–106, March 1996.
[31] C. Shaw and M. Green. The MR Toolkit Peers Package and +L+ Experiment. In Proc. IEEE VRAIS ’93, pages 18–22, Sept 1993.
[32] G. Singh, L. Serra, W. Png, A. Wong, and H. Ng. BrickNet: Sharing +L+ Object Behaviors on the Net. In Proc. IEEE VRAIS ’95, pages 19–25, +L+ 1995.
[33] H. Sowizral, K. Rushforth, and M. Deering. The Java 3D API +L+ Specification, Addison-Wesley, Reading, MA, 1998.
[34] M. Stefik, G. Foster, D. G. Bobrow, K. Kahn, S. Lanning, and +L+ L. Suchman. Beyond The Chalkboard: Computer Support for +L+ Collaboration and Problem Solving in Meetings. CACM, 30(1):32– +L+ 47, January 1987.
[35] P. S. Strauss and R. Carey, An Object-Oriented 3D Graphics Toolkit, +L+ In Computer Graphics (Proc. ACM SIGGRAPH 92), pages 341–349, +L+ Aug, 1992.
[36] Sun Microsystems, Inc. The Java Shared Data Toolkit, 1998. +L+ Unsupported software, available at: +L+ http://developer.javasoft.com/developer/earlyAccess/jsdt/
[37] I. Tou, S. Berson, G. Estrin, Y. Eterovic, and E. Wu. Prototyping +L+ Synchronous Group Applications. IEEE Computer, 27(5):48–56, +L+ May 1994.
[38] R. Waters and D. Anderson. The Java Open Community Version 0.9 +L+ Application Program Interface. Feb, 1997. Available online at: +L+ http://www.merl.com/opencom/opencom-java-api.html
[39] A. Wollrath, R. Riggs, and J. Waldo. A Distributed Object Model for +L+ the Java System, In Proc. USENIX COOTS ’96, pages 219–231, July +L+ 1996.
[40] R. Zeleznik, D. Conner, M. Wloka, D. Aliaga, N. Huang, +L+ P. Hubbard, B. Knep, H. Kaufman, J. Hughes, and A. van Dam. An +L+ Object-oriented Framework for the Integration of Interactive +L+ Animation Techniques. In Computer Graphics (SIGGRAPH &apos;91 +L+ Proceedings), pages 105–112, July, 1991.
[41 ] M. J. Zyda, D. R. Pratt, J. G. Monahan, and K. P. Wilson. NPSNET: +L+ Constructing a 3D Virtual World. In Proc. 1992 ACM Symp. on +L+ Interactive 3D Graphics, pages 147–156, Mar. 1992.
