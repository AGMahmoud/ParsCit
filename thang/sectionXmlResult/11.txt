<?xml version="1.0" encoding="UTF-8"?>
<algorithm name="SectLabel" version="090625" confidence="0.000000">
<title confidence="0.967718">
A Functional Correspondence
between Evaluators and Abstract Machines
</title>
<author confidence="0.502024">
Mads Sig Ager, Dariusz Biernacki, Olivier Danvy, and Jan Midtgaard
</author>
<affiliation confidence="0.811588333333333">
BRICS*
Department of Computer Science
University of Aarhus
</affiliation>
<sectionHeader confidence="0.984731">
Abstract
</sectionHeader>
<bodyText confidence="0.999226684210526">
We bridge the gap between functional evaluators and abstract ma-
chines for the X-calculus, using closure conversion, transformation
into continuation-passing style, and defunctionalization.
We illustrate this approach by deriving Krivine’s abstract machine
from an ordinary call-by-name evaluator and by deriving an ordi-
nary call-by-value evaluator from Felleisen et al.’s CEK machine.
The first derivation is strikingly simpler than what can be found in
the literature. The second one is new. Together, they show that
Krivine’s abstract machine and the CEK machine correspond to the
call-by-name and call-by-value facets of an ordinary evaluator for
the X-calculus.
We then reveal the denotational content of Hannan and Miller’s
CLS machine and of Landin’s SECD machine. We formally com-
pare the corresponding evaluators and we illustrate some degrees of
freedom in the design spaces of evaluators and of abstract machines
for the X-calculus with computational effects.
Finally, we consider the Categorical Abstract Machine and the ex-
tent to which it is more of a virtual machine than an abstract ma-
chine
</bodyText>
<sectionHeader confidence="0.996572">
Categories and Subject Descriptors
</sectionHeader>
<category confidence="0.434095333333333">
D.1.1 [Software]: Programming Techniques—applicative (func-
tional) programming; D.3.4 [Programming Languages]: Proces-
sors—interpreters
</category>
<sectionHeader confidence="0.994184">
General Terms
</sectionHeader>
<keyword confidence="0.935265">
Design, Languages
</keyword>
<sectionHeader confidence="0.990902">
Keywords
</sectionHeader>
<bodyText confidence="0.9430655">
Interpreters, abstract machines, closure conversion, transformation
into continuation-passing style (CPS), defunctionalization
</bodyText>
<footnote confidence="0.28000075">
Basic Research in Computer Science (www. brics . dk),
funded by the Danish National Research Foundation.
† Ny Munkegade, Building 540, DK-8000 Aarhus C, Denmark.
Email:{mads,dabi,danvy,jmi}@brics.dk
</footnote>
<copyright confidence="0.6243958">
Permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for profit or commercial advantage and that copies bear this notice and the full citation
on the first page. To copy otherwise, to republish, to post on servers or to redistribute
to lists, requires prior specific permission and/or a fee
</copyright>
<note confidence="0.662356">
PPDP’03, August 27–29, 2003, Uppsala, Sweden
</note>
<copyright confidence="0.98567">
2003 ACM 1-58113-705-2/03/0008 ...$5.00
</copyright>
<sectionHeader confidence="0.976735">
1 Introduction and related work
</sectionHeader>
<bodyText confidence="0.999710355555555">
In Hannan and Miller’s words [23, Section 7], there are fundamen-
tal differences between denotational definitions and definitions of
abstract machines. While a functional programmer tends to be
familiar with denotational definitions [36], he typically wonders
about the following issues:
Design: How does one design an abstract machine? How were
existing abstract machines, starting with Landin’s SECD ma-
chine, designed? How does one make variants of an existing
abstract machine? How does one extend an existing abstract
machine to a bigger source language? How does one go about
designing a new abstract machine? How does one relate two
abstract machines?
Correctness: How does one prove the correctness of an abstract
machine? Assuming it implements a reduction strategy,
should one prove that each of its transitions implements a part
of this strategy? Or should one characterize it in reference to
a given evaluator, or to another abstract machine?
A variety of answers to these questions can be found in the lit-
erature. Landin invented the SECD machine as an implementa-
tion model for functional languages [26], and Plotkin proved its
correctness in connection with an evaluation function [30, Sec-
tion 2]. Krivine discovered an abstract machine from a logical
standpoint [25], and Cr´egut proved its correctness in reference to
a reduction strategy; he also generalized it from weak to strong
normalization [7]. Curien discovered the Categorical Abstract Ma-
chine from a categorical standpoint [6, 8]. Felleisen et al. invented
the CEK machine from an operational standpoint [16, 17, 19].
Hannan and Miller discovered the CLS machine from a proof-
theoretical standpoint [23]. Many people derived, invented, or
(re-)discovered Krivine’s machine. Many others proposed mod-
ifications of existing machines. And recently, Rose presented a
method to construct abstract machines from reduction rules [32],
while Hardin, Maranget, and Pagano presented a method to extract
the reduction strategy of a machine by extracting axioms from its
transitions and structural rules from its architecture [24].
In this article, we propose one constructive answer to all the ques-
tions above. We present a correspondence between functional
evaluators and abstract machines based on a two-way derivation
consisting of closure conversion, transformation into continuation-
passing style (CPS), and defunctionalization. This two-way deriva-
tion lets us connect each of the machines above with an evaluator,
and makes it possible to echo variations in the evaluator into varia-
tions in the abstract machine, and vice versa. The evaluator clarifies
the reduction strategy of the corresponding machine. The abstract
machine makes the evaluation steps explicit in a transition system
</bodyText>
<page confidence="0.996532">
8
</page>
<bodyText confidence="0.99863175">
Some machines operate on X-terms directly whereas others operate
on compiled X-terms expressed with an instruction set. Accord
ingly, we distinguish between abstract machines and virtual ma-
chines in the sense that virtual machines have an instruction set and
abstract machines do not; instead, abstract machines directly oper-
ate on source terms and do not need a compiler from source terms to
instructions. (Gr´egoire and Leroy make the same point when they
talk about a compiled implementation of strong reduction [21
</bodyText>
<construct confidence="0.555636">
Prerequisites: ML, observational equivalence, abstract
machines, X-interpreters, CPS transformation, defunc-
tionalization, and closure conversion
</construct>
<bodyText confidence="0.999683864864865">
We use ML as a meta-language, and we assume a basic familiarity
with Standard ML and reasoning about ML programs. In particu-
lar, given two pure ML expressions e and e’ we write e = e’ to
express that e and e’ are observationally equivalent. Most of our
implementations of the abstract machines raise compiler warnings
about non-exhaustive matches. These are inherent to programming
abstract machines in an ML-like language. The warnings could be
avoided with an option type or with an explicit exception, at the
price of readability and direct relation to the usual mathematical
specifications of abstract machines.
It would be helpful to the reader to know at least one of the ma-
chines considered in the rest of this article, be it Krivine’s ma-
chine, the CEK machine, the CLS machine, the SECD machine,
or the Categorical Abstract Machine. It would also be helpful
to have already seen a X-interpreter written in a functional lan-
guage [20, 31, 35, 39]. In particular, we make use of Strachey’s
notions of expressible values, i.e., the values obtained by evaluat-
ing an expression, and denotable values, i.e., the values denoted by
identifiers [38].
We make use of the CPS transformation [12, 33]: a term is CPS-
transformed by naming all its intermediate results, sequentializing
their computation, and introducing continuations. Plotkin was the
first to establish the correctness of the CPS transformation [30].
We also make use of Reynolds’s defunctionalization [31]: defunc-
tionalizing a program amounts to replacing each of its function
spaces by a data type and an apply function; the data type enu-
merates all the function abstractions that may give rise to inhabi-
tants of this function space in this program [15]. Nielsen, Banerjee,
Heintze, and Riecke have established the correctness of defunction-
alization [3, 29].
A particular case of defunctionalization is closure conversion: in
an evaluator, closure conversion amounts to replacing each of the
function spaces in expressible and denotable values by a tuple, and
inlining the corresponding apply function.
We would like to stress that all the concepts used here are elemen-
tary ones, and that the significance of this article is the one-fits-all
derivation between evaluators and abstract machines
</bodyText>
<sectionHeader confidence="0.480337">
Overview
</sectionHeader>
<bodyText confidence="0.99928675">
The rest of this article is organized as follows. We first consider
a call-by-name and a call-by-value evaluator, and we present the
corresponding machines, which are Krivine’s machine and the CEK
machine. We then turn to the CLS machine and the SECD machine,
and we present the corresponding evaluators. We finally consider
the Categorical Abstract Machine. For simplicity, we do not cover
laziness and sharing, but they come for free by threading a heap of
updateable thunks in a call-by-name evaluator [2
</bodyText>
<sectionHeader confidence="0.900076">
2 Call-by-name, call-by-value, and the X-
calculus
</sectionHeader>
<bodyText confidence="0.9996222">
We first go from a call-by-name evaluator to Krivine’s abstract ma-
chine (Section 2.1) and then from the CEK machine to a call-by-
value evaluator (Section 2.2). Krivine’s abstract machine operates
on de Bruijn-encoded X-terms, and the CEK machine operates on
X-terms with names. Starting from the corresponding evaluators, it
is simple to construct a version of Krivine’s abstract machine that
operates on X-terms with names, and a version of the CEK machine
that operates on de Bruijn-encoded X-terms (Section 2.3).
The derivation steps consist of closure conversion, transformation
into continuation-passing style, and defunctionalization of continu-
ations. Closure converting expressible and denotable values makes
the evaluator first order. CPS transforming the evaluator makes its
control flow manifest as a continuation. Defunctionalizing the con-
tinuation materializes the control flow as a first-order data structure.
The result is a transition function, i.e., an abstract machine
</bodyText>
<subsectionHeader confidence="0.7460615">
2.1 From a call-by-name evaluator to Kriv-
ine’s machine
</subsectionHeader>
<bodyText confidence="0.975271333333333">
Krivine’s abstract machine [7] operates on de Bruijn-encoded X-
terms. In this representation, identifiers are represented by their
lexical offset, as traditional since Algol 60 [40
</bodyText>
<construct confidence="0.491249833333333">
datatype term = IND of int (* de Bruijn index *)
|ABS of term
|APP of term * term
Programs are closed terms.
2.1.1 A higher-order and compositional call-by-
name evaluator
</construct>
<bodyText confidence="0.978717">
Our starting point is the canonical call-by-name evaluator for the
X-calculus [35, 37]. This evaluator is compositional in the sense of
denotational semantics [34, 37, 41] and higher order (Eval0.eval).
It is compositional because it solely defines the meaning of each
term as a composition of the meaning of its parts. It is higher or-
der because the data types Eval0 . denval and Eval0 . expval contain
functions: denotable values (denval) are thunks and expressible val-
ues (expval) are functions. An environment is represented as a list
of denotable values. A program is evaluated in an empty environ-
ment (Eval0.main
</bodyText>
<equation confidence="0.945543">
structure Eval0
= struct
datatype denval = THUNK of unit -&amp;gt; expval
and expval = FUNCT of denval -&amp;gt; expval
(* eval : term * denval list -&amp;gt; expval *)
fun eval (IND n, e)
= let val (THUNK thunk) = List.nth (e, n)
in thunk ()
end
|eval (ABS t, e)
= FUNCT (fn v =&amp;gt; eval (t, v :: e))
|eval (APP (t0, t1), e)
= let val (FUNCT f) = eval (t0, e)
in f (THUNK (fn () =&amp;gt; eval (t1, e)))
end
(* main : term -&amp;gt; expval *)
fun main t
= eval (t, nil)
end
</equation>
<page confidence="0.979169">
9
</page>
<bodyText confidence="0.9996286">
An identifier denotes a thunk. Evaluating an identifier amounts
to forcing this thunk. Evaluating an abstraction yields a func-
tion. Evaluating an application requires the evaluation of the sub-
expression in position of function; the intermediate result is a func-
tion, which is applied to a thunk
</bodyText>
<subsubsectionHeader confidence="0.991398">
2.1.2 From higher-orderfunctions to closures
</subsubsectionHeader>
<bodyText confidence="0.999301">
We now closure-convert the evaluator of Section 2.1.1.
In Eval0, the function spaces in the data types of denotable
and expressible values are only inhabited by instances of the X-
abstractions fn v =&amp;gt; eval (t, v :: e) in the meaning of abstrac-
tions, and fn () =&amp;gt; eval (t1, e) in the meaning of applications.
Each of these X-abstractions has two free variables: a term and an
environment. We defunctionalize these function spaces into clo-
sures [15, 26, 31], and we inline the corresponding apply functions
</bodyText>
<equation confidence="0.709911421052631">
structure Eval1
= struct
datatype denval = THUNK of term * denval list
and expval = FUNCT of term * denval list
(* eval : term * denval list -&amp;gt; expval *)
fun eval (IND n, e)
=let val (THUNK (t, e’)) = List.nth (e, n)
in eval (t, e’)
end
|eval (ABS t, e)
= FUNCT (t, e)
|eval (APP (t0, t1), e)
= let val (FUNCT (t, e’)) = eval (t0, e)
in eval (t, (THUNK (t1, e)) :: e’)
end
(* main : term -&amp;gt; expval *)
fun main t
= eval (t, nil)
end
</equation>
<bodyText confidence="0.8400305">
The definition of an abstraction is now Eval 1 . FUNCT (t, e) instead
of fn v =&amp;gt; Eval 0 . eval (t, v :: e) , and its use is now Eval 1 . eval
</bodyText>
<equation confidence="0.9759352">
t, (Eval1.THUNK (t1, e)) :: e’) instead of f (Eval0.THUNK
(fn () =&amp;gt; Eval0.eval (t1, e)) ). Similarly, the definition of a
thunk is now Eval1.THUNK (t1, e) instead of Eval0.THUNK (fn ()
=&amp;gt; Eval0.eval (t1, e)) and its use isEval1.eval (t, e’ ) instead
of thunk
</equation>
<bodyText confidence="0.804784857142857">
The following proposition is a corollary of the correctness of de-
functionalization.
PROPOSITION 1 (FULL CORRECTNESS).
For any ML value p : term denoting a program, evaluating
Eval0.main p yields a value FUNCT f and evaluating Eval1.main p
yields a value FUNCT (t, e) such that
f = fn v =&amp;gt; Eval1. eval (t, v :: e
</bodyText>
<subsubsectionHeader confidence="0.94261">
2.1.3 CPS transformation
</subsubsectionHeader>
<bodyText confidence="0.982813">
We transform Eval1 . eval into continuation-passing style.1 Doing
so makes it tail recursive.
1Since programs are closed, applying List. nth cannot fail and
therefore it denotes a total function. We thus keep it in direct
style [14
</bodyText>
<figure confidence="0.503145857142857">
structure Eval2
= struct
datatype denval = THUNK of term * denval list
and expval = FUNCT of term * denval list
(* eval : term * denval list * (expval -&amp;gt; ’a) * )
(* -&amp;gt;’a *)
fun eval (IND n, e, k)
= let val (THUNK (t, e’)) = List.nth (e, n)
in eval (t, e’, k)
end
|eval (ABS t, e, k)
= k (FUNCT (t, e))
|eval (APP (t0, t1), e, k)
= eval (t0, e, fn (FUNCT (t, e’))
=&amp;gt;eval (t,
(THUNK (t1, e)) :: e’,
k))
(* main : term -&amp;gt; expval *)
fun main t
= eval (t, nil, fn v =&amp;gt; v)
end
</figure>
<bodyText confidence="0.995511333333333">
The following proposition is a corollary of the correctness of the
CPS transformation. (Here observational equivalence reduces to
structural equality over ML values of type expval
</bodyText>
<equation confidence="0.71462275">
PROPOSITION 2 (FULL CORRECTNESS).
For any ML value p : term denoting a program,
Eval1.main p = Eval2.main p
2.1.4 Defunctionalizing the continuations
</equation>
<bodyText confidence="0.8893965">
The function space of the continuation is inhabited by instances of
two X-abstractions: the initial one in the definition of Eval2.main,
with no free variables, and one in the meaning of an application,
with three free variables. To defunctionalize the continuation, we
thus define a data type cont with two summands and the corre-
sponding apply cont function to interpret these summands.
structure Eval3
= struct
</bodyText>
<construct confidence="0.983711176470588">
datatype denval = THUNK of term * denval list
and expval = FUNCT of term * denval list
and cont = CONT0
 |CONT1 of term * denval list * cont
(* eval : term * denval list * cont -&amp;gt; expval * )
fun eval (IND n, e, k)
=let val (THUNK (t, e’)) = List.nth (e, n)
in eval (t, e’, k)
end
|eval (ABS t, e, k)
= apply_cont (k, FUNCT (t, e))
|eval (APP (t0, t1), e, k)
= eval (t0, e, CONT1 (t1, e, k))
and apply_cont (CONT0, v)
= v
|apply_cont (CONT1 (t1, e, k), FUNCT (t, e’))
= eval (t, (THUNK (t1, e)) :: e’, k
</construct>
<equation confidence="0.48889275">
main : term -&amp;gt; expval *)
fun main t
= eval (t, nil, CONT0)
end
</equation>
<bodyText confidence="0.998329666666667">
The following proposition is a corollary of the correctness of de-
functionalization. (Again, observational equivalence reduces here
to structural equality over ML values of type expval
</bodyText>
<page confidence="0.998626">
10
</page>
<bodyText confidence="0.9880662">
PROPOSITION 3 (FULL CORRECTNESS). Variables n are represented by their de Bruijn index, and the abstract
For any ML value p : term denoting a program, machine operates on triples consisting of a term, an environment,
Eval2.main p �= Eval3.main p and a stack of expressible values.
We identify that cont is a stack of thunks, and that the transitions
are those of Krivine’s abstract machine
</bodyText>
<subsubsectionHeader confidence="0.984028">
2.1.5 Krivine’s abstract machine
</subsubsectionHeader>
<bodyText confidence="0.9584232">
To obtain the canonical definition of Krivine’s abstract machine, we
abandon the distinction between denotable and expressible values
and we use thunks instead, we represent the defunctionalized con-
tinuation as a list of thunks instead of a data type, and we inline
apply cont
</bodyText>
<figure confidence="0.291859105263158">
structure Eval4
= struct
datatype thunk = THUNK of term * thunk list
(* eval : term * thunk list * thunk list *)
(* -&amp;gt; term * thunk list *)
fun eval (IND n, e, s)
=let val (THUNK (t, e’)) = List.nth (e, n)
in eval (t, e’ , s)
end
|eval (ABS t, e, nil)
= (ABS t, e)
|eval (ABS t, e, (t’, e’) :: s)
= eval (t, (THUNK (t’, e’)) :: e, s)
|eval (APP (t0, t1), e, s)
= eval (t0, e, (t1, e) :: s)
(* main : term -&amp;gt; term * thunk list *)
fun main t
= eval (t, nil, nil)
end
</figure>
<bodyText confidence="0.891025333333333">
The following proposition is straightforward to prove.
PROPOSITION 4 (FULL CORRECTNESS).
For any ML value p : term denoting a program,
Eval3.main p �= Eval4.main p
For comparison with Eval4, the canonical definition of Krivine’s
abstract machine is as follows [7, 22, 25], where t denotes terms, v
denotes expressible values, e denotes environments, and s denotes
stacks of expressible values:
. Source syntax
</bodyText>
<equation confidence="0.872427375">
t::= n I Xt I t0t1
.Expressible values (closures):
v ::= [t, e]
. Initial transition, transition rules, and final transition:
t =� (t, nil, nil)
(n, e, s) (t, e&amp;apos;, s), where [t, e&amp;apos;] = nth(e, n)
(Xt, e, [t&amp;apos;, e&amp;apos;] :: s) (t, [t&amp;apos;, e&amp;apos;] :: e, s)
(t0 t1, e, s) (t0, e, [t1, e] :: s
</equation>
<bodyText confidence="0.949185">
Xt, e, nil) =� [t, e]
Each line in the canonical definition matches a clause in Eval4. We
conclude that Krivine’s abstract machine can be seen as a defunc-
tionalized, CPS-transformed, and closure-converted version of the
standard call-by-name evaluator for the X-calculus. This evalua-
tor evidently implements Hardin, Maranget, and Pagano’s K strat-
egy [24, Section 3
</bodyText>
<subsectionHeader confidence="0.9395145">
2.2 From the CEK machine to a call-by-value
evaluator
</subsectionHeader>
<bodyText confidence="0.994177666666667">
The CEK machine [ 16, 17, 19] operates on X-terms with names and
distinguishes between values and computations in their syntax (i.e.,
it distinguishes trivial and serious terms, in Reynolds’s words [31
</bodyText>
<construct confidence="0.831045428571429">
datatype term = VALUE of value
|COMP of comp
and value = VAR of string (* name *)
|LAM of string * term
and comp = APP of term * term
Programs are closed terms.
2.2.1 The CEK abstract machine
</construct>
<bodyText confidence="0.967919">
Our starting point reads as follows [19, Figure 2, page 239], where
t denotes terms, w denotes values, v denotes expressible values, k
denotes evaluation contexts, and e denotes environments:
. Source syntax
</bodyText>
<equation confidence="0.9822966">
t::= w t0 t1
w::= x Xx.t
. Expressible values (closures) and evaluation contexts:
v::= [x, t, e]
k::= stop � fun(v,k) � arg(t,e,k)
. Initial transition, transition rules (two kinds), and final transi-
tion:
t�init (t, mt, stop)
(w, e, k) Leval Leval (k, y(w,e))
(t0 t1, e, k) (t0, e, arg (t1 ,e,k))
(arg(t1,e,k), v) )cont (t1, e, fun(v,k))
(fun([x, t, e], k), v) )cont (t, e[x�H v], k)
(stop, v) �final v
where y(x, e) = e(x)
y(Xx.t, e) = [x, t, e
</equation>
<bodyText confidence="0.999507">
Variables x are represented by their name, and the abstract machine
consists of two mutually recursive transition functions. The first
transition function operates on triples consisting of a term, an envi-
ronment, and an evaluation context. The second operates on pairs
consisting of an evaluation context and an expressible value. Envi-
ronments are extended in the fun-transition, and consulted in y. The
empty environment is denoted by mt.
This specification is straightforward to program in ML
</bodyText>
<page confidence="0.996084">
11
</page>
<figure confidence="0.97165625">
signature ENV
=
sig
type ’a env
val mt : ’a env
val lookup : ’a env * string -&amp;gt; ’a
val extend : string * ’a * ’a env -&amp;gt; ’a env
end
</figure>
<bodyText confidence="0.97954775">
Environments are represented as a structure Env : ENV containing
a representation of the empty environment mt, an operation lookup
to retrieve the value bound to a name in an environment, and an
operation extend to extend an environment with a binding
</bodyText>
<figure confidence="0.639474833333333">
eval_value (LAM (x, t), e)
= CLOSURE (x, t, e)
(* main : term -&amp;gt; expval *)
fun main t
= eval (t, Env.mt, fn w =&amp;gt; w)
end
</figure>
<bodyText confidence="0.993486">
The following proposition is a corollary of the correctness of de-
functionalization. (Observational equivalence reduces here to struc-
tural equality over ML values of type expval
</bodyText>
<figure confidence="0.854171777777778">
structure Eval0
= struct
datatype expval
= CLOSURE of string * term * expval Env.env
datatype ev_context
= STOP
|ARG of term * expval Env.env * ev_context
|FUN of expval * ev_context
(* eval : term * expval Env.env * ev_context
</figure>
<construct confidence="0.937596615384615">
amp;gt; expval *)
fun eval (VALUE v, e, k)
= continue (k, eval_value (v, e))
|eval (COMP (APP (t0, t1)), e, k)
= eval (t0, e, ARG (t1, e, k))
and eval_value (VAR x, e)
= Env.lookup (e, x)
|eval_value (LAM (x, t), e)
= CLOSURE (x, t, e)
and continue (STOP, w)
= w
|continue (ARG (t1, e, k), w)
= eval (t1, e, FUN (w, k
</construct>
<figure confidence="0.705527">
continue (FUN (CLOSURE (x, t, e), k), w)
= eval (t, Env.extend (x, w, e), k)
(* main : term -&amp;gt; expval *)
fun main t
= eval (t, Env.mt, STOP)
end
</figure>
<subsubsectionHeader confidence="0.812606">
2.2.2 Refunctionalizing the evaluation contexts into
continuations
</subsubsectionHeader>
<bodyText confidence="0.98644875">
We identify that the data type ev context and the function continue
are a defunctionalized representation. The corresponding higher-
order evaluator reads as follows. As can be observed, it is in
continuation-passing style
</bodyText>
<equation confidence="0.720402611111111">
structure Eval1
= struct
datatype expval
= CLOSURE of string * term * expval Env.env
(* eval : term * expval Env.env * (expval -&amp;gt; ’a) *)
(* -&amp;gt;’a *)
fun eval (VALUE v, e, k)
= k (eval_value (v, e))
|eval (COMP (APP (t0, t1)), e, k)
= eval (t0, e,
fn (CLOSURE (x, t, e’) )
=&amp;gt;eval (t1, e,
fn w
=&amp;gt;eval (t, Env.extend (x, w, e’),
k)))
and eval_value (VAR x, e)
= Env.lookup (e, x)
PROPOSITION 5 (FULL CORRECTNESS
</equation>
<bodyText confidence="0.697781">
For anyML value p : term denoting a program
</bodyText>
<figure confidence="0.295771">
Eval0.main p = Eval1.main p
</figure>
<subsubsectionHeader confidence="0.954483">
2.2.3 Back to direct style
</subsubsectionHeader>
<bodyText confidence="0.8620485">
CPS-transforming the following direct-style evaluator yields the
evaluator of Section 2.2.2 [10
</bodyText>
<equation confidence="0.7868532">
structure Eval2
= struct
datatype expval
= CLOSURE of string * term * expval Env.env
(* eval : term * expval Env.env -&amp;gt; expval *)
fun eval (VALUE v, e)
= eval_value (v, e)
|eval (COMP (APP (t0, t1)), e)
= let val (CLOSURE (x, t, e’)) = eval (t0, e)
val w = eval (t1, e)
in eval (t, Env.extend (x, w, e’))
end
and eval_value (VAR x, e)
= Env.lookup (e, x)
|eval_value (LAM (x, t), e)
= CLOSURE (x, t, e)
(* main : term -&amp;gt; expval *)
fun main t
= eval (t, Env.mt)
end
</equation>
<bodyText confidence="0.9562734">
The following proposition is a corollary of the correctness of the
direct-style transformation. (Again, observational equivalence re-
duces here to structural equality over ML values of type expval.)
PROPOSITION 6 (FULL CORRECTNESS).
For anyML value p : term denoting a program
</bodyText>
<equation confidence="0.523024">
Eval1.main p = Eval2.main p
</equation>
<subsubsectionHeader confidence="0.984857">
2.2.4 From closures to higher-orderfunctions
</subsubsectionHeader>
<bodyText confidence="0.951382333333333">
We observe that the closures, in Eval2, are defunctionalized rep-
resentations with an apply function inlined. The corresponding
higher-order evaluator reads as follows
</bodyText>
<footnote confidence="0.7146175">
structure Eval3
= struct
datatype expval = CLOSURE of expval -&amp;gt; expval
(* eval : term * expval Env.env -&amp;gt; expval *)
fun eval (VALUE v, e)
= eval_value (v, e
</footnote>
<page confidence="0.935831">
12
</page>
<figure confidence="0.839095066666667">
eval (COMP (APP (t0, t1)), e)
= let val (CLOSURE f) = eval (t0, e)
val w = eval (t1, e)
infw
end
and eval_value (VAR x, e)
= Env.lookup (e, x)
|
eval_value (LAM (x, t), e)
= CLOSURE (fn w
=&amp;gt; eval (t, Env.extend (x, w, e)))
(* main : term -&amp;gt; expval *)
fun main t
= eval (t, Env.mt)
end
</figure>
<bodyText confidence="0.492445">
The following proposition is a corollary of the correctness of de-
functionalization
</bodyText>
<equation confidence="0.820346857142857">
PROPOSITION 7 (FULL CORRECTNESS).
For any ML value p : term denoting a program, evaluating
Eval2.main p yields a value CLOSURE (x, t, e) and evaluating
Eval3.main p yields a value CLOSURE f such that
fn w =&amp;gt; Eval2.eval (t, Env. extend (x, w, e)) �= f
2.2.5 A higher-order and compositional call-by-
value evaluator
</equation>
<bodyText confidence="0.925499333333333">
The result in Eval3 is a call-by-value evaluator that is composi-
tional and higher-order. This call-by-value evaluator is the canoni-
cal one for the X-calculus [31, 35, 37]. We conclude that the CEK
machine can be seen as a defunctionalized, CPS-transformed, and
closure-converted version of the standard call-by-value evaluator
for X-terms
</bodyText>
<subsectionHeader confidence="0.990632">
2.3 Variants of Krivine’s machine and of the
</subsectionHeader>
<sectionHeader confidence="0.86943">
CEK machine
</sectionHeader>
<bodyText confidence="0.999084555555556">
It is easy to construct a variant of Krivine’s abstract machine for X-
terms with names, by starting from a call-by-name evaluator for
X-terms with names. Similarly, it is easy to construct a variant
of the CEK machine for X-terms with de Bruijn indices, by start-
ing from a call-by-value evaluator for X-terms with indices. It is
equally easy to start from a call-by-value evaluator for X-terms with
de Bruijn indices and no distinction between values and computa-
tions; the resulting abstract machine coincides with Hankin’s eager
machine [22, Section 8.1.2
</bodyText>
<subsectionHeader confidence="0.972795">
2.4 Conclusion
</subsectionHeader>
<bodyText confidence="0.999444545454545">
We have shown that Krivine’s abstract machine and the CEK ab-
stract machine are counterparts of canonical evaluators for call-by-
name and for call-by-value X-terms, respectively. The derivation of
Krivine’s machine is strikingly simpler than what can be found in
the literature. That the CEK machine can be derived is, to the best
of our knowledge, new. That these two machines are two sides of
the same coin is also new. We have not explored any other aspect
of this call-by-name/call-by-value duality [9].
Using substitutions instead of environments or inlining one of the
standard computational monads (state, continuations, etc. [39]) in
the call-by-value evaluator yields variants of the CEK machine that
have been documented in the literature [16, Chapter 8]. For ex-
ample, inlining the state monad in a monadic evaluator yields a
state-passing evaluator. The corresponding abstract machine has
one more component to represent the state. In general, inlining
monads provides a generic recipe to construct arbitrarily many new
abstract machines. It does not seem as straightforward, however, to
construct a “monadic abstract machine” and then to inline a monad;
we are currently studying the issue.
On another note, one can consider an evaluator for strictness-
annotated X-terms—represented either with names or with indices,
and with or without distinction between values and computations.
One is then led to an abstract machine that generalizes Krivine’s
machine and the CEK machine [13].
Finally, it is straightforward to extend Krivine’s machine and the
CEK machine to bigger source languages (with literals, primi-
tive operations, conditional expressions, block structure, recursion,
etc.), by starting from evaluators for these bigger languages. For
example, all the abstract machines in “The essence of compiling
with continuations” [19] are defunctionalized continuation-passing
evaluators, i.e., interpreters.
In the rest of this article, we illustrate further the correspondence
between evaluators and abstract machines
</bodyText>
<sectionHeader confidence="0.995677">
3 The CLS abstract machine
</sectionHeader>
<bodyText confidence="0.9749694">
The CLS abstract machine is due to Hannan and Miller [23]. In the
following, t denotes terms, v denotes expressible values, c denotes
lists of directives (a term or the special tag ap), e denotes environ-
ments, l denotes stacks of environments, and s denotes stacks of
expressible values
</bodyText>
<table confidence="0.84089925">
Abstract machines processing X-terms with de Bruijn indices often •Source syntax:
resolve indices with transitions: t::= nIXtIt0t1
(0,v::e,s) v::s • Expressible values (closures):
(n+1,v::e,s) (n, e, s) v ::= [t, e
</table>
<bodyText confidence="0.958226666666667">
Compared to the evaluator of Section 2.1.1, the evaluator corre-
sponding to this machine has List. nth inlined and is not composi-
tional
</bodyText>
<equation confidence="0.9034474">
fun eval (IND 0, denval :: e, s)
= ... denval ...
 |eval (IND n, denval :: e, s)
=eval (IND (n - 1), e, s
</equation>
<listItem confidence="0.8425695">
Initial transition, transition rules, and final transition:
t (t:: nil, nil:: nil, nil
</listItem>
<equation confidence="0.7631245">
Xt :: c, e ::l, s) (c, l, [t, e] :: s)
( (t0 t1) :: c, e ::l, s) (t0 :: t1 :: ap :: c, e :: e ::l, s)
(0:: c, (v:: e) ::l, s) (c, l, v:: s)
(n + 1 :: c, (v:: e) ::l, s) (n:: c, e ::l, s)
(ap :: c,l, v :: [t, e] :: s) (t :: c, (v :: e) ::l, s)
(nil, nil, v:: s) v
</equation>
<page confidence="0.992614">
13
</page>
<bodyText confidence="0.994944333333333">
Variables n are represented by their de Bruijn index, and the abstract
machine operates on triples consisting of a list of directives, a stack
of environments, and a stack of expressible values
</bodyText>
<subsectionHeader confidence="0.937512">
3.1 The CLS machine
</subsectionHeader>
<figure confidence="0.894625846153846">
Hannan and Miller’s specification is straightforward to program in
ML:
datatype term = IND of int (* de Bruijn index *)
|ABS of term
|APP of term * term
Programs are closed terms.
structure Eval0
= struct
datatype directive = TERM of term
|AP
datatype env = ENV of expval list
and expval = CLOSURE of term * env
(* run : directive list * env list * expval list
</figure>
<equation confidence="0.971365952380952">
amp;gt; expval *)
fun run (nil, nil, v :: s)
= v
|run ((TERM (IND 0)) :: c, (ENV (v :: e)) :: l, s)
= run (c, l, v :: s)
|run ((TERM (IND n)) :: c, (ENV (v :: e)) :: l, s)
=run ((TERM (IND (n - 1))) :: c,
(ENV e) :: l,
s)
|run ((TERM (ABS t)) :: c, e :: l, s)
= run (c, l, (CLOSURE (t, e)) :: s)
|run ((TERM (APP (t0, t1))) :: c, e :: l, s)
=run ((TERM t0) :: (TERM t1) :: AP :: c,
e :: e :: l,
s)
|run (AP :: c, l, v :: (CLOSURE (t, ENV e)) :: s)
= run ((TERM t) :: c, (ENV (v :: e)) :: l, s)
(* main : term -&amp;gt; expval *)
fun main t
= run ((TERM t) :: nil, (ENV nil) :: nil, nil)
end
</equation>
<subsectionHeader confidence="0.990647">
3.2 A disentangled definition of the CLS ma-
chine
</subsectionHeader>
<bodyText confidence="0.9924512">
In the definition of Section 3. 1, all the possible transitions are
meshed together in one recursive function, run. Instead, let us fac-
tor run into several mutually recursive functions, each of them with
one induction variable.
In this disentangled definition
</bodyText>
<listItem confidence="0.988000888888889">
run c interprets the list of control directives, i.e., it specifies
which transition to take if the list is empty, starts with a term,
or starts with an apply directive. If the list is empty, the com-
putation terminates. If the list starts with a term, run t is
called, caching the term in the first parameter. If the list starts
with an apply directive, run a is called.
• run t interprets the top term in the list of control directives.
• run a interprets the top value in the current stack.
The disentangled definition reads as follows
</listItem>
<figure confidence="0.965207333333333">
structure Eval1
= struct
datatype directive = TERM of term
|AP
datatype env = ENV of expval list
and expval = CLOSURE of term * env
(* run_c : directive list * env list * expval list *)
(* -&amp;gt; expval *)
fun run_c (nil, nil, v :: s)
= v
|run_c ((TERM t) :: c, l, s)
= run _t (t, c, l, s
</figure>
<construct confidence="0.682007333333333">
run_c (AP :: c, l, s)
= run_a (c, l, s)
and run_t (IND 0, c, (ENV (v :: e) ) :: l, s)
= run_c (c, l, v :: s)
|run_t (IND n, c, (ENV (v :: e) ) :: l, s)
= run_t (IND (n - 1), c, (ENV e) :: l, s)
|run_t (ABS t, c, e :: l, s)
= run_c (c, l, (CLOSURE (t, e)) :: s)
|run_t (APP (t0, t1), c, e :: l, s
</construct>
<equation confidence="0.981062909090909">
run_t (t0,
(TERM t1) :: AP :: c,
e :: e :: l,
s)
and run_a (c, l, v :: (CLOSURE (t, ENV e)) :: s)
= run _t (t, c, (ENV (v :: e) ) :: l, s)
(* main : term -&amp;gt; expval *)
fun main t
= run _t (t, nil, (ENV nil) :: nil, nil)
end
PROPOSITION 8 (FULL CORRECTNESS
</equation>
<bodyText confidence="0.734683">
For anyML value p : term denoting a program
</bodyText>
<figure confidence="0.4689475">
Eval0.main p = Eval1.main p
PROOF. By fold-unfold [5]. The invariants are as follows. For any
ML values t : term, e : expval list, and s : expval list,
Eval1. run c (c, l, s) = Eval0. run (c, l, s)
Eval1. run t (t, c, l, s) = Eval0. run ((TERM t) :: c, l, s)
Eval1. run a (c, l, s) = Eval0. run (AP :: c, l, s
</figure>
<subsectionHeader confidence="0.988763">
3.3 The evaluator corresponding to the CLS
machine
</subsectionHeader>
<bodyText confidence="0.962004555555556">
In the disentangled definition of Section 3.2, there are three possible
ways to construct a list of control directives (nil, cons’ing a term,
and cons’ing an apply directive). We could specify these construc-
tions as a data type rather than as a list. Such a data type, together
with run c, is in the image of defunctionalization (run c is the apply
functions of the data type). The corresponding higher-order evalu-
ator is in continuation-passing style. Transforming it back to direct
style yields the following evaluator:
structure Eval3
</bodyText>
<equation confidence="0.840378576923077">
struct
datatype env = ENV of expval list
and expval = CLOSURE of term * env
(* run_t : term * env list * expval list *)
(* -&amp;gt; env list * expval list *)
fun run_t (IND 0, (ENV (v :: e)) :: l, s)
= (l, v :: s)
|run_t (IND n, (ENV (v :: e)) :: l, s)
= run _t (IND (n - 1), (ENV e) :: l, s)
|run_t (ABS t, e :: l, s)
= (l, (CLOSURE (t, e)) :: s)
14
|run_t (APP (t0, t1), e :: l, s)
= let val (l, s) = run_t (t0, e :: e :: l, s)
val (l, s) = run_t (t1, l, s)
in run_a (l, s)
end
and run _a (l, v :: (CLOSURE (t, ENV e)) :: s)
= run _t (t, (ENV (v :: e)) :: l, s)
(* main : term -&amp;gt; expval *)
fun main t
= let val (nil, v :: s)
= run_t (t, (ENV nil) :: nil, nil)
in v
end
end
</equation>
<bodyText confidence="0.999102">
The following proposition is a corollary of the correctness of de-
functionalization and of the CPS transformation. (Here observa-
tional equivalence reduces to structural equality over ML values of
</bodyText>
<equation confidence="0.9791275">
type expval.)
PROPOSITION 9 (FULL CORRECTNESS).
For any ML value p : term denoting a program,
Eval1.main p = Eval3.main p
</equation>
<bodyText confidence="0.998379363636363">
As in Section 2, this evaluator can be made compositional by re-
functionalizing the closures into higher-order functions and by fac-
toring the resolution of de Bruijn indices into an auxiliary lookup
function.
We conclude that the evaluation model embodied in the CLS ma-
chine is a call-by-value interpreter threading a stack of environ-
ments and a stack of intermediate results with a caller-save strategy
(witness the duplication of environments on the stack in the mean-
ing of applications) and with a left-to-right evaluation of sub-terms.
In particular, the meaning of a term is a partial endofunction over a
stack of environments and a stack of intermediate results
</bodyText>
<sectionHeader confidence="0.988833">
4 The SECD abstract machine
</sectionHeader>
<bodyText confidence="0.9861314">
The SECD abstract machine is due to Landin [26]. In the follow-
ing, t denotes terms, v denotes expressible values, c denotes lists of
directives (a term or the special tag ap), e denotes environments, s
denotes stacks of expressible values, and d denotes dumps (list of
triples consisting of a stack, an environment and a list of directives
</bodyText>
<listItem confidence="0.989621">
Source syntax:
t::� x I ax.t I t0t1
•Expressible values (closures):
v::� [x, t, e]
• Initial transition, transition rules, and final transition
</listItem>
<equation confidence="0.8143278">
t (nil, mt, t :: nil, nil)
(s, e, x :: c, d) (e(x) :: s, e, c, d)
(s, e, (Ax.t) :: c, d) ( [x, t, e] :: s, e, c, d)
(s, e, (t0t1) :: c, d) (s, e, t1 :: t0:: ap :: c, d)
([x,t,e&amp;apos;]::v::s,e,ap::c,d) (nil,e&amp;apos;[x��v],t::nil, d&amp;apos
</equation>
<bodyText confidence="0.855114">
where d&amp;apos; _ (s, e, c) :: d
(v :: s, e, nil, (s&amp;apos;,e&amp;apos;,d&amp;apos;) :: d) (v:: s&amp;apos;, e&amp;apos;, c&amp;apos;, d)
(v :: s, e, nil, nil) v
Variables x are represented by their name, and the abstract machine
operates on quadruples consisting of a stack of expressible values,
an environment, a list of directives, and a dump. Environments are
consulted in the first transition rule, and extended in the fourth. The
empty environment is denoted by mt
</bodyText>
<subsectionHeader confidence="0.989401">
4.1 The SECD machine
</subsectionHeader>
<bodyText confidence="0.904331">
Landin’s specification is straightforward to program in ML. Pro-
grams are closed terms. Environments are as in Section 2.2
</bodyText>
<figure confidence="0.977462470588235">
datatype term = VAR of string (* name *)
|LAM of string * term
|APP of term * term
structure Eval0
= struct
datatype directive = TERM of term
|AP
datatype value
= CLOSURE of string * term * value Env.env
fun run (v :: nil, e’, nil, nil)
= v
|run (s, e, (TERM (VAR x)) :: c, d)
= run ((Env.lookup (e, x)) :: s, e, c, d)
|run (s, e, (TERM (LAM (x, t))) :: c, d)
= run ((CLOSURE (x, t, e)) :: s, e, c, d)
|run (s, e, (TERM (APP (t0, t1))) :: c, d)
= run (s,
e,
(TERM t1) :: (TERM t0) :: AP :: c,
d)
|run ((CLOSURE (x, t, e’)) :: v :: s,
e,
AP :: c,
d)
= run (nil,
Env.extend (x, v, e’),
(TERM t) :: nil,
(s, e, c) :: d)
|run (v :: nil, e’ , nil, (s, e, c) :: d)
= run (v :: s, e, c, d)
(* main : term -&amp;gt; value *)
fun main t
= run (nil, Env.mt, (TERM t) :: nil, nil)
end
</figure>
<subsectionHeader confidence="0.9877635">
4.2 A disentangled definition of the SECD ma-
chine
</subsectionHeader>
<bodyText confidence="0.999821384615385">
As in the CLS machine, in the definition of Section 4. 1, all the pos-
sible transitions are meshed together in one recursive function, run.
Instead, we can factor run into several mutually recursive functions,
each of them with one induction variable. These mutually recur-
sive functions are in defunctionalized form: the one processing the
dump is an apply function for the data type representing the dump
(a list of stacks, environments, and lists of directives), and the one
processing the control is an apply function for the data type repre-
senting the control (a list of directives). The corresponding higher-
order evaluator is in continuation-passing style with two nested con-
tinuations and one control delimiter, reset [12, 18]. The delimiter
resets the control continuation when evaluating the body of a X-
abstraction. (More detail is available in a technical report [11
</bodyText>
<page confidence="0.997816">
15
</page>
<subsectionHeader confidence="0.929465">
4.3 The evaluator corresponding to the SECD
machine
</subsectionHeader>
<bodyText confidence="0.998503714285714">
The direct-style version of the evaluator from Section 4.2 reads as
follows:
dump register is explained by the control delimiter in the evaluator
(reset in Eval4. eval).2 Removing this control delimiter gives rise
to an abstract machine with a single stack component for control—
not by a clever change in the machine itself, but by a straightforward
simplification in the corresponding evaluator
</bodyText>
<figure confidence="0.93950375">
structure Eval4
= struct
datatype value
= CLOSURE of string * term * value Env.env
(* eval : term * value list * value Env.env *)
(* -&amp;gt; value list * value Env.env *)
fun eval (VAR x, s, e)
= ((Env.lookup (x, e)) :: s, e)
|eval (LAM (x, t), s, e)
= ((CLOSURE (x, t, e)) :: s, e)
|eval (APP (t0, t1), s, e)
= let val (s, e) = eval (t1, s, e
</figure>
<equation confidence="0.997161333333333">
val (s, e) = eval (t0, s, e)
in apply (s, e)
end
and apply ((CLOSURE (x, t, e’)) :: v :: s, e)
= let val (v :: nil, _)
= reset (fn ()
=&amp;gt;eval (t,
nil,
Env.extend (x,
v,
e’)))
in (v :: s, e)
end
(* main : term -&amp;gt; value *)
fun main t
= let val (v :: nil, _)
= reset (fn ()
=&amp;gt;eval (t, nil, Env.mt))
in v
end
end
</equation>
<bodyText confidence="0.923811666666667">
The following proposition is a corollary of the correctness of de-
functionalization and of the CPS transformation. (Here observa-
tional equivalence reduces to structural equality over ML values of
type value.)
PROPOSITION 10 (FULL CORRECTNESS).
For any ML value p : term denoting a program,
Eval0.main p = Eval4.main p
As in Sections 2 and 3, this evaluator can be made compositional
by refunctionalizing the closures into higher-order functions.
We conclude that the evaluation model embodied in the SECD ma-
chine is a call-by-value interpreter threading a stack of intermediate
results and an environment with a callee-save strategy (witness the
dynamic passage of environments in the meaning of applications),
a right-to-left evaluation of sub-terms, and a control delimiter. In
particular, the meaning of a term is a partial endofunction over a
stack of intermediate results and an environment. Furthermore, this
evaluator evidently implements Hardin, Maranget, and Pagano’s L
strategy, i.e., right-to-left call by value, without us having to “guess”
its inference rules [24, Section 4].
The denotational content of the SECD machine puts a new light
on it. For example, its separation between a control register and a
</bodyText>
<sectionHeader confidence="0.977957">
5 Variants of the CLS machine and of the
SECD machine
</sectionHeader>
<bodyText confidence="0.9994275">
It is straightforward to construct a variant of the CLS machine for
X-terms with names, by starting from an evaluator for X-term with
names. Similarly, it is straightforward to construct a variant of the
SECD machine for X-terms with de Bruijn indices, by starting from
an evaluator for X-term with indices. In the same vein, it is simple
to construct call-by-name versions of the CLS machine and of the
SECD machine, by starting from call-by-name evaluators. It is also
simple to construct a properly tail recursive version of the SECD
machine, and to extend the CLS machine and the SECD machine to
bigger source languages, by extending the corresponding evaluator
</bodyText>
<sectionHeader confidence="0.970005">
6 The Categorical Abstract Machine
</sectionHeader>
<bodyText confidence="0.996857176470588">
What is the difference between an abstract machine and a virtual
machine? Elsewhere [1], we propose to distinguish them based on
the notion of instruction set: A virtual machine has an instruction
set whereas an abstract machine does not. Therefore, an abstract
machine directly operates on a X-term, but a virtual machine op-
erates on a compiled representation of a X-term, expressed using
an instruction set. (This distinction can be found elsewhere in the
literature [21].)
The Categorical Abstract Machine [6], for example, has an in-
struction set—categorical combinators—and therefore (despite its
name) it is a virtual machine, not an abstract machine. In con-
trast, Krivine’s machine, the CEK machine, the CLS machine, and
the SECD machine are all abstract machines, not virtual machines,
since they directly operate on X-terms. In this section, we present
the abstract machine corresponding to the Categorical Abstract Ma-
chine (CAM). We start from the evaluation model embodied in the
CAM [1
</bodyText>
<subsectionHeader confidence="0.998972">
6.1 The evaluator corresponding to the CAM
</subsectionHeader>
<bodyText confidence="0.999434875">
The evaluation model embodied in the CAM is an interpreter
threading a stack with its top element cached in a register, represent-
ing environments as expressible values (namely nested pairs linked
as lists), with a caller-save strategy (witness the duplication of the
register on the stack in the meaning of applications below), and with
a left-to-right evaluation of sub-terms. In particular, the meaning of
a term is a partial endofunction over the register and the stack. This
evaluator reads as follows
</bodyText>
<table confidence="0.99752625">
datatype term = IND of int (* de Bruijn index *)
|ABS term
of
|APP term * term
of
|NIL
|CONS term * term
of
|CAR term
of
 |term
CDR of
</table>
<footnote confidence="0.5281785">
Programs are closed terms.
2A rough definition of reset is fun reset t = t
</footnote>
<bodyText confidence="0.9464825">
A more accurate definition, however, falls out of the scope of this
article [12, 18
</bodyText>
<page confidence="0.96537">
16
</page>
<figure confidence="0.943500183673469">
structure Eval0
= struct
datatype expval
= NULL
|PAIR of expval * expval
|CLOSURE of expval * (expval * expval list
-&amp;gt; expval * expval list)
(* access : int * expval * expval list *)
(* -&amp;gt; expval * expval list *)
fun access (0, PAIR (v1, v2), s)
= (v2, s)
|access (n, PAIR (v1, v2), s)
= access (n - 1, v1, s)
(* eval : term * expval * expval list *)
(* -&amp;gt; expval * expval list *)
fun eval (IND n, v, s)
= access (n, v, s)
|eval (ABS t, v, s)
= (CLOSURE (v, fn (v, s) =&amp;gt; eval (t, v, s)), s)
|eval (APP (t0, t1), v, s)
= let val (v, v’ :: s)
= eval (t0, v, v :: s)
val (v’ , (CLOSURE (v, f)) :: s)
= eval (t1, v’ , v :: s)
in f (PAIR (v, v’ ) , s)
end
|eval (NIL, v, s)
= (NULL, s)
|eval (CONS (t1, t2), v, s)
= let val (v, v’ :: s) = eval (t1, v, v :: s)
val (v, v’ :: s) = eval (t2, v’ , v :: s)
in (PAIR (v’ , v) , s)
end
|eval (CAR t, v, s)
= let val (PAIR (v1, v2), s) = eval (t, v, s)
in (v1, s)
end
|eval (CDR t, v, s)
= let val (PAIR (v1, v2), s) = eval (t, v, s)
in (v2, s)
end
(* main : term -&amp;gt; expval *)
fun main t
= let val (v, nil) = eval (t, NULL, nil)
in v
end
end
This evaluator evidently implements Hardin, Maranget, and
Pagano’s X strategy [24, Section 6
</figure>
<subsectionHeader confidence="0.943398">
6.2 The abstract machine corresponding to
the CAM
</subsectionHeader>
<bodyText confidence="0.987285">
As in Sections 2, 3, and 4, we can closure-convert the evaluator of
Section 6.1 by defunctionalizing its expressible values, transform
it into continuation-passing style, and defunctionalize its continu-
ations. The resulting abstract machine reads as follows, where t
denotes terms, v denotes expressible values, k denotes evaluation
contexts, and s denotes stacks of expressible values.
. Source syntax
</bodyText>
<equation confidence="0.850488714285714">
t ::= n Xt t0t1 � nil (const1 t2)
(cart) (cdrt)
. Expressible values (unit value, pairs, and closures) and evalu-
ation contexts:
v::= null (v1, v2) [v, t[
k::= CONT0 CONT1(t,k) CONT2(k) CONT3(t,k)
CONT4(k) CONT5(k) CONT6(k
</equation>
<table confidence="0.961714705882353">
Initial transition, transition rules (two kinds), and final transi-
tion:
tLinit (t, null, nil, CONT0)
(n, v, s, k) Leval Leval Leval Leval Leval Leval Leval (k, y(n,v), s)
(Xt, v, s, k) (k, [v, t[, s)
(nil, v, s, k) (k, null, s)
(t0t1, v, s, k) (t0, v, v:: s, CONT1(t1, k))
((cons t1 t2), v, s, k) (t1, v, v:: s, CONT3(t2, k))
((cart), v, s, k) (t, v, s, CONT5(k))
((cdrt), v, s, k) (t, v, s, CONT6(k))
(CONT1(t, k), v, v&amp;apos; :: s) Lcont Lcont Lcont Lcont Lcont Lcont (t, v&amp;apos;, v:: s, CONT2(k))
(CONT2 (k), v&amp;apos;, [v, t[ :: s) (t, (v, v&amp;apos;), s, k)
(CONT3(t1, k), v, v&amp;apos; :: s) (t1, v&amp;apos;, v:: s, CONT4(k))
(CONT4 (k), v, v&amp;apos; :: s) (k, (v&amp;apos;, v), s)
(CONT5(k), (v1, v2), s) (k, v1, s)
(CONT6(k), (v1, v2), s) (k, v2, s)
(CONT0, v, nil) Lfinal v
</table>
<equation confidence="0.96458">
where y(0, (v1, v2)) = v2
y(n,(v1,v2)) = y(n - 1,v1
</equation>
<bodyText confidence="0.9962896">
Variables n are represented by their de Bruijn index, and the ab-
stract machine consists of two mutually recursive transition func-
tions. The first transition function operates on quadruples consist-
ing of a term, an expressible value, a stack of expressible values,
and an evaluation context. The second transition function operates
on triples consisting of an evaluation context, an expressible value,
and a stack of expressible values.
This abstract machine embodies the evaluation model of the CAM.
Naturally, more intuitive names could be chosen instead of CONT0,
CONT1, etc
</bodyText>
<sectionHeader confidence="0.989516">
7 Conclusion and issues
</sectionHeader>
<bodyText confidence="0.985645">
We have presented a constructive correspondence between func-
tional evaluators and abstract machines. This correspondence
builds on off-the-shelf program transformations: closure conver-
sion, CPS transformation, defunctionalization, and inlining .3 We
have shown how to reconstruct known machines (Krivine’s ma-
chine, the CEK machine, the CLS machine, and the SECD ma-
chine) and how to construct new ones. Conversely, we have re-
vealed the denotational content of known abstract machines. We
have shown that Krivine’s abstract machine and the CEK machine
correspond to canonical evaluators for the X-calculus. We have also
shown that they are dual of each other since they correspond to
call-by-name and call-by-value evaluators in the same direct style.
In terms of denotational semantics [27, 34], Krivine’s machine and
the CEK machine correspond to a standard semantics, whereas the
CLS machine and the SECD machine correspond to a stack seman-
tics of the X-calculus. Finally, we have exhibited the abstract ma-
chine corresponding to the CAM, which puts the reader in a new
position to answer the recurrent question as to whether the CLS
machine is closer to the CAM or to the SECD machine.
3Indeed the push-enter twist of Krivine’s machine is obtained
by inlining apply cont in Section 2.1.5
</bodyText>
<page confidence="0.998474">
17
</page>
<bodyText confidence="0.999620142857143">
Since this article was written, we have studied the correspondence
between functional evaluators and abstract machines for call by
need [2] and for Propositional Prolog [4]. In both cases, we de-
rived sensible machines out of canonical evaluators.
It seems to us that this correspondence between functional evalua-
tors and abstract machines builds a reliable bridge between denota-
tional definitions and definitions of abstract machines. On the one
hand, it allows one to identify the denotational content of an ab-
stract machine in the form of a functional interpreter. On the other
hand, it gives one a precise and generic recipe to construct arbitrar-
ily many new variants of abstract machines (e.g., with substitutions
or environments, or with stacks) or of arbitrarily many new abstract
machines, starting from an evaluator with any given computational
monad [28
</bodyText>
<sectionHeader confidence="0.950365">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.9978924">
We are grateful to Małgorzata Biernacka, Julia Lawall, and Hen-
ning Korsholm Rohde for timely comments. Thanks are also due to
the anonymous reviewers.
This work is supported by the ESPRIT Working Group APPSEM II
(http://www.appsem.org
</bodyText>
<sectionHeader confidence="0.999574">
8 References
</sectionHeader>
<reference confidence="0.999928680851064">
1] Mads Sig Ager, Dariusz Biernacki, Olivier Danvy, and Jan
Midtgaard. From interpreter to compiler and virtual ma-
chine: a functional derivation. Technical Report BRICS RS-
03-14, DAIMI, Department of Computer Science, University
of Aarhus, Aarhus, Denmark, March 2003.
[2] Mads Sig Ager, Olivier Danvy, and Jan Midtgaard. A func-
tional correspondence between call-by-need evaluators and
lazy abstract machines. Technical Report BRICS RS-03-
24, DAIMI, Department of Computer Science, University of
Aarhus, Aarhus, Denmark, June 2003.
[3] Anindya Banerjee, Nevin Heintze, and Jon G. Riecke. Design
and correctness of program transformations based on control-
flow analysis. In Naoki Kobayashi and Benjamin C. Pierce,
editors, Theoretical Aspects of Computer Software, 4th Inter-
national Symposium, TACS 2001, number 2215 in Lecture
Notes in Computer Science, Sendai, Japan, October 2001.
Springer-Verlag.
[4] Dariusz Biernacki and Olivier Danvy. From interpreter to
logic engine: A functional derivation. Technical Report
BRICS RS-03-25, DAIMI, Department of Computer Science,
University of Aarhus, Aarhus, Denmark, June 2003. Accepted
for presentation at LOPSTR 2003.
[5] Rod M. Burstall and John Darlington. A transformational
system for developing recursive programs. Journal ofACM,
24(1):44–67, 1977.
[6] Guy Cousineau, Pierre-Louis Curien, and Michel Mauny. The
categorical abstract machine. Science of Computer Program-
ming, 8(2):173–202, 1987.
[7] Pierre Cr´egut. An abstract machine for lambda-terms nor-
malization. In Mitchell Wand, editor, Proceedings of the
1990ACM Conference on Lisp and Functional Programming,
pages 333–340, Nice, France, June 1990. ACM Press.
[8] Pierre-Louis Curien. Categorical Combinators, Sequential
Algorithms and Functional Programming. Progress in The-
oretical Computer Science. Birkha¨user, 1993.
[9] Pierre-Louis Curien and Hugo Herbelin. The duality of com-
putation. In Philip Wadler, editor, Proceedings of the 2000
ACM SIGPLAN International Conference on Functional Pro-
gramming, SIGPLAN Notices, Vol. 35, No. 9, pages 233–
243, Montr´eal, Canada, September 2000. ACM Press.
[10] Olivier Danvy. Back to direct style. Science of Computer
Programming, 22(3):183–195, 1994.
[11] Olivier Danvy. A lambda-revelation of the SECD machine.
Technical Report BRICS RS-02-53, DAIMI, Department of
Computer Science, University of Aarhus, Aarhus, Denmark,
December 2002.
[12] Olivier Danvy and Andrzej Filinski. Representing control, a
study of the CPS transformation. Mathematical Structures in
Computer Science, 2(4):361–391, 1992.
[13] Olivier Danvy and John Hatcliff. CPS transformation after
strictness analysis. ACMLetters on Programming Languages
and Systems, 1(3):195–212, 1993.
[14] Olivier Danvy and John Hatcliff. On the transformation be-
tween direct and continuation semantics. In Stephen Brookes,
Michael Main, Austin Melton, Michael Mislove, and David
Schmidt, editors, Proceedings ofthe 9th Conference on Math-
ematical Foundations of Programming Semantics, number
802 in Lecture Notes in Computer Science, pages 627–648,
New Orleans, Louisiana, April 1993. Springer-Verlag.
[15] Olivier Danvy and Lasse R. Nielsen. Defunctionalization
at work. In Harald Søndergaard, editor, Proceedings of the
Third International ACMSIGPLANConference on Principles
and Practice ofDeclarative Programming (PPDP’01), pages
162–174, Firenze, Italy, September 2001. ACM Press. Ex-
tended version available as the technical report BRICS RS-
01-23.
[16] Matthias Felleisen and Matthew Flatt. Programming lan-
guages and lambda calculi. Unpublished lecture notes.
http://www.ccs.neu.edu/home/matthias/3810-w02/
readings. html,1989-2003.
[ 17] Matthias Felleisen and Daniel P. Friedman. Control operators,
the SECD machine, and the X-calculus. In Martin Wirsing, ed-
itor, Formal Description ofProgramming Concepts III, pages
193–217. Elsevier Science Publishers B.V. (North-Holland),
Amsterdam, 1986.
[18] Andrzej Filinski. Representing monads. In Hans-J. Boehm,
editor, Proceedings of the Twenty-First Annual ACM Sympo-
sium on Principles of Programming Languages, pages 446–
457, Portland, Oregon, January 1994. ACM Press.
[19] Cormac Flanagan, Amr Sabry, Bruce F. Duba, and Matthias
Felleisen. The essence of compiling with continuations. In
David W. Wall, editor, Proceedings of the ACM SIGPLAN’93
Conference on Programming Languages Design and Imple-
mentation, SIGPLAN Notices, Vol. 28, No 6, pages 237–247,
Albuquerque, New Mexico, June 1993. ACM Press.
[20] Daniel P. Friedman, Mitchell Wand, and Christopher T.
Haynes. Essentials of Programming Languages, second edi-
tion. The MIT Press, 2001.
[21] Benjamin Gr´egoire and Xavier Leroy. A compiled imple-
mentation of strong reduction. In Simon Peyton Jones, ed-
itor, Proceedings of the 2002 ACM SIGPLAN International
Conference on Functional Programming, SIGPLAN Notices,
Vol. 37, No. 9, pages 235 –246, Pittsburgh, Pennsylvania,
September 2002. ACM Press
</reference>
<page confidence="0.969505">
18
</page>
<reference confidence="0.998879396825397">
22] Chris Hankin. Lambda Calculi, a guide for computer scien-
tists, volume 1 of Graduate Texts in Computer Science. Ox-
ford University Press, 1994.
[23] John Hannan and Dale Miller. From operational semantics
to abstract machines. Mathematical Structures in Computer
Science, 2(4):415–459, 1992.
[24] Th´er`ese Hardin, Luc Maranget, and Bruno Pagano. Func-
tional runtime systems within the lambda-sigma calculus.
Journal ofFunctional Programming, 8(2):131–172, 1998.
[25] Jean-Louis Krivine. Un interpr`ete du X-calcul. Brouil-
lon. Available online at http://www.logique.jussieu.fr/
˜krivine,1985.
[26] Peter J. Landin. The mechanical evaluation of expressions.
The Computer Journal, 6(4):308–320, 1964.
[27] Robert E. Milne and Christopher Strachey. A Theory of Pro-
gramming Language Semantics. Chapman and Hall, London,
and John Wiley, New York, 1976.
[28] Eugenio Moggi. Notions of computation and monads. Infor-
mation and Computation, 93:55–92, 1991.
[29] Lasse R. Nielsen. A denotational investigation of defunction-
alization. Technical Report BRICS RS-00-47, DAIMI, De-
partment of Computer Science, University of Aarhus, Aarhus,
Denmark, December 2000.
[30] Gordon D. Plotkin. Call-by-name, call-by-value and the X-
calculus. Theoretical Computer Science, 1:125–159, 1975.
[31] John C. Reynolds. Definitional interpreters for higher-order
programming languages. Higher-Order and Symbolic Com-
putation, 11(4):363–397, 1998. Reprinted from the proceed-
ings of the 25th ACM National Conference (1972).
[32] Kristoffer H. Rose. Explicit substitution – tutorial &amp;amp; sur-
vey. BRICS Lecture Series LS-96-3, DAIMI, Department of
Computer Science, University of Aarhus, Aarhus, Denmark,
September 1996.
[33] Amr Sabry and Matthias Felleisen. Reasoning about pro-
grams in continuation-passing style. Lisp and Symbolic Com-
putation, 6(3/4):289–360, 1993.
[34] David A. Schmidt. Denotational Semantics: A Methodology
for Language Development. Allyn and Bacon, Inc., 1986.
[35] Guy L. Steele Jr. and Gerald J. Sussman. The art of
the interpreter or, the modularity complex (parts zero, one,
and two). AI Memo 453, Artificial Intelligence Labora-
tory, Massachusetts Institute of Technology, Cambridge, Mas-
sachusetts, May 1978.
[36] Joseph Stoy. Some mathematical aspects of functional
programming. In John Darlington, Peter Henderson, and
David A. Turner, editors, Functional Programming and its
Applications. Cambridge University Press, 1982.
[37] Joseph E. Stoy. Denotational Semantics: The Scott-Strachey
Approach to Programming Language Theory. The MIT Press,
1977.
[38] Christopher Strachey. Fundamental concepts in program-
ming languages. Higher-Order and Symbolic Computation,
13(1/2):1–49,2000.
[39] Philip Wadler. The essence of functional programming (in-
vited talk). In Andrew W. Appel, editor, Proceedings of the
Nineteenth Annual ACM Symposium on Principles of Pro-
gramming Languages, pages 1–14, Albuquerque, New Mex-
ico, January 1992. ACM Press.
[40] Mitchell Wand. A short proof of the lexical addressing algo-
rithm. Information Processing Letters, 35:1–5, 1990.
[41] Glynn Winskel. The Formal Semantics ofProgramming Lan-
guages. Foundation of Computing Series. The MIT Press,
1993
</reference>
<page confidence="0.999269">
19
</page>
</algorithm>
